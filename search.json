[{"title":"强连通分量 2-SAT","url":"/2022/07/11/2-SAT/","content":"一举一动，都是承诺，会被另一个人看在眼里，记在心上的。\n\n强连通分量对于无向图，连通分量很好定义：有边相连的两个点属于一个连通分量。\n但对于有向图，需要考虑 “方向”，这一属性，定义：在有向图中，如果存在一条从  到  的路径，也存在一条从  到  的路径，则  和  在同给一个强连通分量里。\n这就给解决有向图相关问题提供了两个层面，宏观上，把每一个强连通分量缩成一个点后，图会是一个 DAG ；微观上，每一个强连通分量里的点，任意两个点都可以互达。\nkosaraju求强连通分量。\n洛谷P3387\n给一个  个点，  条边的有向图，每个点有一个权值，求一条路径，最大化经过的点权值之和（允许多次经过一条边或一个点，但是，重复经过的点，权值只计算一次。）\n思路：求强连通分量对应的 DAG 。对于每一个强连通分量，走到里面任何一个点，则整个强连通分量里的点都可以到达，所以缩点以后，每一个强连通分量的权值就是包含的所有的点的权值之和。在缩点以后的图上，跑DP。DP数组 f[u] 表示，走到  这个点的最大权值之和是多少。\n#define N 10007bool vis[N];queue&lt;int&gt; Q;int a[N], bl[N], w[N], scc, deg[N], f[N];vector&lt;int&gt; e[N], re[N], post, g[N];void dfs1(int u) {    vis[u] = 1;    for (auto v : re[u])        if (!vis[v]) dfs1(v);    post.push_back(u);}void dfs2(int u) {    bl[u] = scc;    w[scc] += a[u];    for (auto v : e[u])        if (!bl[v]) dfs2(v);}int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) a[i] = rd();    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd();        e[u].push_back(v);        re[v].push_back(u);    }    for (int u = 1; u &lt;= n; ++u)        if (!vis[u]) dfs1(u);    reverse(post.begin(), post.end());    for (auto u : post)        if (!bl[u]) {++scc; dfs2(u);}    for (int u = 1; u &lt;= n; ++u)        for (auto v : e[u])            if (bl[u] != bl[v]) {g[bl[u]].push_back(bl[v]); ++deg[bl[v]];}    for (int u = 1; u &lt;= scc; ++u)        if (!deg[u]) {f[u] = w[u]; Q.push(u);}    while (!Q.empty()) {        int u = Q.front(); Q.pop();        for (auto v : g[u]) {            f[v] = max(f[v], f[u] + w[v]);            --deg[v];            if (!deg[v]) Q.push(v);        }    }    int ans = 0;    for (int u = 1; u &lt;= scc; ++u) ans = max(ans, f[u]);    printf(\"%d\\n\", ans);    return 0;}\n2-SAT2-SAT 问题可以用强连通分量和拓扑排序解决。\n2-SAT 问题是一个数字逻辑问题：有  个布尔变量，其中一些布尔变量之间有限制关系；用这  个布尔变量组成序列，使得其满足所有限制关系；判断序列是否存在。\n基本的模型是：对于每一个变量建立两个点，一个表示该变量取值为  ， 一个表示该变量取值为  。如果条件是 “ 若  则  ”，就在图中连一条从  指向  的边，同时，对于其逆否命题 “ 若  则  ” ，在图中连一条从  指向  的边。 \n建立好图之后，在图中跑 kosaraju 算法，求强连通分量。首先每一个强连通分量里的点赋值应该相同，所以如果有一个变量对应的两个点在同一个强连通分量里，则无解。如果想要求一组解，需要找出原图的反拓扑序，所以在使用 kosaraju 算法时，应在原图中计算 post_number ，再在反图上跑 dfs2 ，求出来的每个连通块的标号就是反拓扑序。再遍历每个变量，如果代表该变量取值为  的点拓扑序小于代表该变量取值为  的点，则该变量取值为  。\n洛谷P4782\n有  个布尔变量，其中一些布尔变量之间有限制关系；用这  个布尔变量组成序列，使得其满足所有限制关系；判断序列是否存在。限制条件形式如下：a val1 b val2 ，含义为 a = val1 || b = val2 ，所以当 a != val1 时，b = val2 ；当 b != val2 时，a = val1 。\n#define N 2000007bool vis[N];int bl[N], scc;vector&lt;int&gt; e[N], re[N], post;void dfs1(int u) {    vis[u] = 1;    for (auto v : e[u])        if (!vis[v]) dfs1(v);    post.push_back(u);}void dfs2(int u) {    bl[u] = scc;    for (auto v : re[u])        if (!bl[v]) dfs2(v);}int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), a = rd();        int v = rd(), b = rd();        e[u + a * n].push_back(v + (1 - b) * n);        e[v + b * n].push_back(u + (1 - a) * n);        re[v + (1 - b) * n].push_back(u + a * n);        re[u + (1 - a) * n].push_back(v + b * n);    }    for (int u = 1; u &lt;= (n &lt;&lt; 1); ++u)        if (!vis[u]) dfs1(u);    reverse(post.begin(), post.end());    for (auto u : post)        if (!bl[u]) {++scc; dfs2(u);}    for (int u = 1; u &lt;= n; ++u)        if (bl[u] == bl[u + n]) {puts(\"IMPOSSIBLE\"); return 0;}    puts(\"POSSIBLE\");    for (int u = 1; u &lt;= n; ++u) {        if (bl[u] &lt; bl[n + u]) printf(\"0 \");        else printf(\"1 \");    }    return 0;}\n洛谷P5782\n每个党派有两个人 （ 和 ），两个人里选一个出席委员会。在所有人中，存在限制条件。条件形式如下 a b 表示 a 和 b 不能同时出席。问是否有解，如果有，给出一种委员会的成员表。\n思路：挺裸的吧…… 需要注意隐藏条件，就是每个党派的两个人里必须要选恰好一个。\n#define N 320007bool vis[N];int bl[N], scc, deg[N];vector&lt;int&gt; e[N], re[N], post;void dfs1(int u) {    vis[u] = 1;    for (auto v : e[u])        if (!vis[v]) dfs1(v);    post.push_back(u);}void dfs2(int u) {    bl[u] = scc;    for (auto v : re[u])        if (!bl[v]) dfs2(v);}int main() {    int n = (rd() &lt;&lt; 1), m = rd();    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd();        e[u].push_back(v + n); e[v].push_back(u + n);         re[v + n].push_back(u); re[u + n].push_back(v);    }    for (int i = 1; i &lt;= n; ++i) {        e[2 * i - 1].push_back(2 * i + n); e[2 * i].push_back(2 * i - 1 + n);        e[2 * i + n].push_back(2 * i - 1); e[2 * i - 1 + n].push_back(2 * i);        re[2 * i - 1].push_back(2 * i + n); re[2 * i].push_back(2 * i - 1 + n);        re[2 * i + n].push_back(2 * i - 1); re[2 * i - 1 + n].push_back(2 * i);    }    for (int u = 1; u &lt;= (n &lt;&lt; 1); ++u)        if (!vis[u]) dfs1(u);    reverse(post.begin(), post.end());    for (auto u : post)        if (!bl[u]) {++scc; dfs2(u);}    for (int u = 1; u &lt;= n; ++u)        if (bl[u] == bl[u + n]) {puts(\"NIE\"); return 0;}    for (int u = 1; u &lt;= n; ++u)        if (bl[u] &gt; bl[n + u]) printf(\"%d\\n\", u);    return 0;}\n洛谷P4171\n有  个布尔变量，限制关系形式如下：a = 1 || b = 1 ，问是否有解。\n#define N 320007bool vis[N];int bl[N], scc;vector&lt;int&gt; e[N], re[N], post;void dfs1(int u) {    vis[u] = 1;    for (auto v : e[u])        if (!vis[v]) dfs1(v);    post.push_back(u);}void dfs2(int u) {    bl[u] = scc;    for (auto v : re[u])        if (!bl[v]) dfs2(v);}inline void work() {    memset(vis, 0, sizeof(vis));    memset(bl, 0, sizeof(bl));    scc = 0; post.clear();    int n = rd(), m = rd();    for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) {e[i].clear(); re[i].clear();}    for (int i = 1; i &lt;= m; ++i) {        char c1 = getchar();        for (; c1 != 'm' &amp;&amp; c1 != 'h'; c1 = getchar());        int u = rd();        char c2 = getchar();        for (; c2 != 'm' &amp;&amp; c2 != 'h'; c2 = getchar());        int v = rd();        int a = (c1 == 'm'), b = (c2 == 'm');        e[u + a * n].push_back(v + (1 - b) * n);        e[v + b * n].push_back(u + (1 - a) * n);        re[v + (1 - b) * n].push_back(u + a * n);        re[u + (1 - a) * n].push_back(v + b * n);    }    for (int u = 1; u &lt;= (n &lt;&lt; 1); ++u)        if (!vis[u]) dfs1(u);    reverse(post.begin(), post.end());    for (auto u : post)        if (!bl[u]) {++scc; dfs2(u);}    for (int u = 1; u &lt;= n; ++u)        if (bl[u] == bl[u + n]) {puts(\"BAD\"); return;}    puts(\"GOOD\");}int main() {    for (int t = rd(); t; --t) work();    return 0;}\nacwing370\n有  个布尔变量，限制关系以三个位运算的形式给出，AND OR XOR ，问是否有解。\n#define N 20007bool vis[N], ans[N];int bl[N], scc;vector&lt;int&gt; e[N], re[N], post;void dfs1(int u) {    vis[u] = 1;    for (auto v : e[u])        if (!vis[v]) dfs1(v);    post.push_back(u);}void dfs2(int u) {    bl[u] = scc;    for (auto v : re[u])        if (!bl[v]) dfs2(v);}int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd(), c = rd();        string s; cin &gt;&gt; s;        if (s == \"AND\") {            if (c) {                e[u + n].push_back(u); e[v + n].push_back(v);                re[u].push_back(u + n); re[v].push_back(v + n);            } else {                e[u].push_back(v + n); e[v].push_back(u + n);                re[v + n].push_back(u); re[u + n].push_back(v);            }        } else if (s == \"OR\") {            if (c) {                e[u + n].push_back(v); e[v + n].push_back(u);                re[v].push_back(u + n); re[u].push_back(v + n);            } else {                e[u].push_back(u + n); e[v].push_back(v + n);                re[u + n].push_back(u); re[v + n].push_back(v);            }        } else if (s == \"XOR\") {            if (c) {                e[u].push_back(v + n); e[v].push_back(u + n);                e[u + n].push_back(v); e[v + n].push_back(u);                re[v + n].push_back(u); re[u + n].push_back(v);                re[v].push_back(u + n); re[u].push_back(v + n);            } else {                e[u].push_back(v); e[v].push_back(u);                e[u + n].push_back(v + n); e[v + n].push_back(u + n);                re[u].push_back(v); re[v].push_back(u);                re[u + n].push_back(v + n); re[v + n].push_back(u + n);            }        }    }    for (int u = 1; u &lt;= (n &lt;&lt; 1); ++u)        if (!vis[u]) dfs1(u);    reverse(post.begin(), post.end());    for (auto u : post)        if (!bl[u]) {++scc; dfs2(u);}    for (int u = 1; u &lt;= n; ++u)        if (bl[u] == bl[u + n]) {puts(\"NO\"); return 0;}    puts(\"YES\");    return 0;}\nacwing371\n\n思路：每场婚礼建两个点，表示是在婚礼开始时举行仪式，还是结束时。枚举每两场婚礼，判断是否有冲突，建图。\n#define N 20007bool vis[N];int bl[N], scc, t[N], s[N], l[N];vector&lt;int&gt; e[N], re[N], post;void dfs1(int u) {    vis[u] = 1;    for (auto v : e[u])        if (!vis[v]) dfs1(v);    post.push_back(u);}void dfs2(int u) {    bl[u] = scc;    for (auto v : re[u])        if (!bl[v]) dfs2(v);}inline int gettime() {    int h = rd(), m = rd();    return h * 60 + m;}inline bool tt(int x, int y) {    if (t[y] &gt;= t[x] + l[x]) return 0;    if (t[x] &gt;= t[y] + l[y]) return 0;    return 1;}inline bool tw(int x, int y) {    if (t[x] &gt;= s[y]) return 0;    if (s[y] - l[y] &gt;= t[x] + l[x]) return 0;    return 1;}inline bool ww(int x, int y) {    if (s[x] - l[x] &gt;= s[y]) return 0;    if (s[y] - l[y] &gt;= s[x]) return 0;    return 1;}inline void printpre(int x) {    int h = t[x] / 60, m = t[x] % 60;    int h_ = (t[x] + l[x]) / 60, m_ = (t[x] + l[x]) % 60;    printf(\"%02d:%02d %02d:%02d\\n\", h, m, h_, m_);}inline void printlst(int x) {    int h = (s[x] - l[x]) / 60, m = (s[x] - l[x]) % 60;    int h_ = s[x] / 60, m_ = s[x] % 60;    printf(\"%02d:%02d %02d:%02d\\n\", h, m, h_, m_);}int main() {    int n = rd();    for (int i = 1; i &lt;= n; ++i) {t[i] = gettime(); s[i] = gettime(); l[i] = rd();}    for (int i = 1; i &lt;= n; ++i) {        for (int j = 1; j &lt; i; ++j) {            if (tt(i, j)) {                e[i].push_back(j + n); e[j].push_back(i + n);                re[i + n].push_back(j); re[j + n].push_back(i);            }            if (tw(i, j)) {                e[i].push_back(j); e[j + n].push_back(i + n);                re[j].push_back(i); re[i + n].push_back(j + n);            }            if (tw(j, i)) {                e[j].push_back(i); e[i + n].push_back(j + n);                re[i].push_back(j); re[j + n].push_back(i + n);            }            if (ww(i, j)) {                e[i + n].push_back(j); e[j + n].push_back(i);                re[i].push_back(j + n); re[j].push_back(i + n);            }        }    }    for (int u = 1; u &lt;= (n &lt;&lt; 1); ++u)        if (!vis[u]) dfs1(u);    reverse(post.begin(), post.end());    for (auto u : post)        if (!bl[u]) {++scc; dfs2(u);}    for (int u = 1; u &lt;= n; ++u)        if (bl[u] == bl[u + n]) {puts(\"NO\"); return 0;}    puts(\"YES\");    for (int u = 1; u &lt;= n; ++u)        if (bl[u] &gt; bl[u + n]) printpre(u);        else printlst(u);    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"2021","url":"/2022/01/30/2021/","content":"2022 我们来啦！！！！\n\n(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"hotkey\":true,\"preload\":\"metadata\",\"video\":{\"url\":\"/img/2021.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() \n","categories":["HDU's Life"],"tags":["Daily"]},{"title":"Yes! We had a fight.","url":"/2021/12/11/About-we-had-a-fight/","content":"我们可以对爱情失望，但是不可以因为失望就不再去爱。人要相信世界上美好的事物永远存在，真挚的爱情永不磨灭。\n\n(Co老师在打比赛，所以我可以有时间偷偷写东西)\n谨以此 blog 纪念我难过超过一天的 “fight”\n谁知道，一支牙膏竟会是导火索表面上发生的事情，其实很简单。Co老师牙膏用完了，本来该去拿快递，但因为我的墨迹还是什么，最后我们没能去拿快递。回到寝室后，我怕他不高兴，就去买了一管牙膏给他送了过去（考虑到可能他会不喜欢我买的，就拿上了我寝室里他之前给我买的）。我让他选，他要哪个，果不其然，他要了他之前买的，这没什么。（毕竟以我对他的了解，这已经是意料之中了）。后来他想送我回寝室，在走回去的路上，他忽然变卦了，要了我买的牙膏（男人真善变），这可能也没什么）让我爆炸的是后面的对话：\nE：你为什么要这个啊\nC：因为是你买的\nE：不给（因为我感觉其实他不是很喜欢我买的牙膏\nC：我喜欢它的（大概是就要的意思，并且从我手上拿走了它\nE：（心想：这话我能信吗）那你说出你喜欢它的十个理由\nC：（此处省略几个理由……）因为我不喜欢它 （就是这句话，引发了后面一系列的事情\n后来就是，闹来闹去，我哭了，Co老师大概也很懵，后来我一个人走掉了（我不开心喜欢一个人静静……）\n这就完了吗？不，当然没有！\nCo老师是最受不了我不开心的时候一个人走掉。因为他觉得，不开心应该在两个人之间说出来。但我就喜欢一个人……\n我在寝室门前的小道里一直往里面走（晚上的情侣真的多……我都没眼看了……），找到了一个没有人的角落，然后自己哭了起来。我感觉我差不多哭完了，打算缓一下就回寝室了。哪知道Co老师，就站在我俩抢牙膏的地方，一动不动。（你这是想干啥）他给我发消息：“你能来拉拉我吗？”（我懂他的意思，他不想我在不开心的时候把他扔在原地）我当时心想：“老娘自个儿还不开心呢，还要我拉你？男人就离谱。” 不过后来想了想，Co老师还是个孩子。我回去了，把他送回了寝室。\n战争要结束了吗？没有……\nCo老师一直想要听我说出我为什么如此委屈。（我当时哪知道呢，不过是感情上头了，也不是完全不知道，但是是真的没法给你说出个一二三）\n我拒绝回答，Co老师继续追问。几个回合就给爷整无语了……\n后来也没做什么吧，他又不放心我一个人走回去，他把我送到寝室楼下，看我上去了以后就回去了。\n一般我不开心吧，都是晚上睡一觉，第二天就好了。谁还会记得昨天的不开心呢。\n前面都只是开头，正文居然才刚刚开始我回到寝室，也不太想聊天，就自己玩儿手机玩儿到了十二点多。后来去洗漱，打算睡觉。没想到的是，我上了床，又看了会儿手机，看到了一些什么杀人的新闻，看的我害怕极了，我给Co老师发消息，表示好害怕。\n我没想到的是Co老师那个时候已经在爆发的边缘了。Co老师特别看重睡觉，谁害他晚睡他跟谁急。（我也不例外）再加上，我一直没给他发消息，就是害怕了才发了消息。Co老师简直火冒三丈。非但没安慰我，还说了一些让我觉得十分恐怖的话。在那一刻，我都担心他会 kill me……\n他急了，但我太困了，在他骂完我之前，我就晚安了……\n第二天早上，我醒来的时候，确实昨天的害怕还有伤心都还没过去，我打开手机，看到了Co老师的长文，害，当时大概就是，心凉、无语，不想说啥。第二天我也没怎么理Co老师，也不是没理，就是比较冷淡。Co老师有在想让我开心一点，因为我一直说很久没有去玩儿，他提议下午一起学习，晚上一起去玩儿，我刚开始拒绝了，后来我妥协了“你安排吧”。意料之外的是，我们俩下午在各自的寝室昏睡了一下午，然后Co老师像是心情好了，但我还处在我的悲伤里。（我的悲伤 == 比较冷淡）所以Co老师不断被我泼冷水。一起到了实验室，他让我不要玩儿手机了，（当时我在和闺蜜聊天），我没怎么理他，继续在玩儿。Co老师绷不住了。几分钟过后，Co老师收拾了书包，自己说要走，我问：”那我呢。“ 他表示不管我，他走了。我：额，好的。（冷淡 ing）后来晚上，我们都自己阳光长跑了，我决定自己出去吃晚饭。在我出去的路上Co老师问我要不要一起吃晚饭。我拒绝了，他不放心我，企图跟着我，我给他看了我的位置，把他赶回去了。晚一些时候，Co老师得知我在排练，说要来接我，我拒绝了。（我简直冷漠起来 == 冰块）（PS，我第三天早上才知道，他在那个晚上，一个人买了20块钱板栗，一个人吃完了，撑的要死，一个人在学校里走了很久，边吃边落泪。后来还买了红薯，因为想去接我，但被我拒绝了，就一个人默默吃掉了） 晚上我们也没有再见面。\n到了第三天早上，Co老师说他做梦了。他很害怕，他怕没有人会喜欢他。我跟他说，爸爸妈妈很爱他。（大概懂的都懂，这话可能在间接表达着什么）Co老师很难过，我们又吵了几句。我开始翻 qq 空间，翻到这样一句话\n\n“少跟你对象作吧，他也不容易，十几岁的年纪，连自己都照顾不好还要照顾你，就算心情不好还要顾及你的感受，他也会累，他不是欠你的。嗯，好好爱他吧，不是每个人都会惯着你，嗯，好好珍惜吧 ”\n——网易云音乐热评《那个男孩》 \n\n确实吧，Co老师虽然过分起来挺过分的，但真的是个很可爱的人，没必要欺负一个小孩子。后来我就开始认真安慰他，一起吃早饭，慢慢就好了。\n故事讲完了！！！\n透过现象看本质其实从军训开始，就会有一些时不时的小矛盾。我又很喜欢一个人忍，忍多了积攒在一起，得不得哪天就爆发了。其实我们都还算了解彼此吧。所以伤害对方的方式也会格外”残忍“。我们称之为”折磨“。总是会说”你就这样折磨我吧“。其实也没有真的想把对方怎么样。只是自己在气头上。我们都很了解彼此，但却一直没有办法用对方喜欢的方式去对待彼此。所以总是会有摩擦，总是会有争吵。（虽然我们都曾自认为是不会争吵的人）以前总听别人说，啊，两个人要走下去有多么多么难。是啊，想想身边那么多人，想想自己和身边那么多人，有多少其实彼此相爱的人也在彼此伤害。\n这次 fight ，可以说是有惊无险。还好两个人的爆发点存在着时间差。还好我们都还不愿意放弃。\n最后我想说：如果没有相等的爱，那就让我爱多一些吧。\n最后的最后科普一个冷知识……\n（其实我们在很久以前就不再是男女朋友了…… \n","categories":["HDU's Life"],"tags":["Daily"]},{"title":"基环树","url":"/2022/08/28/Base-ring-tree/","content":"There is considerable debate over how we should react if we detect a signal from an alien civilisation.— IELTS\n\n基环树基环树，是基于环的树，基环树分为两类：无向和有向。\n无向基环树特征： 个点  条边的连通图。一个环，换上挂着很多子树。\n\n有向基环树特征： 个点每个点一条出边。往往不只是一棵树，是一个森林。每个树有一个环。\n\n无向基环树https://atcoder.jp/contests/abc266/tasks/abc266_f\n给一个无向基环树， 次询问，每次询问查询两个点之间是否存在唯一的简单路径。\n思路：等价于询问两个点是否属于同一个子树。先拓扑排序，每次删除叶子（入度为 ）。没有入过队列的就是环上的点，（环上的点度数都为 ）。再给环上的点打上不一样的标记，并把挂在该点上的子树打上一样的标记。\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_backinline ll rd() {    ll x = 0;    bool f = 0;    char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}#define N 200007vector&lt;int&gt; e[N];int deg[N], vis[N], bl[N], col;queue&lt;int&gt; q;void dfs(int u, int fa) {    for (auto v : e[u])        if (v != fa &amp;&amp; !bl[v]) {            bl[v] = bl[u]; dfs(v, u);        }}int main() {    int n = rd();    for (int i = 1; i &lt;= n; ++i) {        int u = rd(), v = rd();        e[u].pb(v); e[v].pb(u);        ++deg[u]; ++deg[v];    }    for (int i = 1; i &lt;= n; ++i)        if (deg[i] == 1) q.push(i);    while (!q.empty()) {        int u = q.front(); q.pop(); vis[u] = 1;        for (auto v : e[u]) {            --deg[v];            if (deg[v] == 1) q.push(v);        }    }    for (int i = 1; i &lt;= n; ++i)        if (!vis[i]) bl[i] = ++col;    for (int i = 1; i &lt;= n; ++i)        if (!vis[i]) dfs(i, i);    for (int q = rd(); q; --q) {        int u = rd(), v = rd();        puts(bl[u] == bl[v] ? \"Yes\" : \"No\");    }    return 0;}\n有向基环树https://codeforces.com/gym/393017/problem/B\n思路：注意到，首先，每个点最多只会操作一次；其次，最后的复读值一定出现在每个环里。拓扑排序，找出环。统计该环里出现过的复读值，对这些复读值的计数器 +1 ，再枚举可能的最后的复读值，更新答案。\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_backinline ll rd() {    ll x = 0;    bool f = 0;    char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}#define N 1000007int a[N], b[N], indeg[N], vis[N], cnt;vector&lt;int&gt; e[N];queue&lt;int&gt; q;map&lt;int, int&gt; m, m0; // val cntset&lt;int&gt; s;void dfs(int u) {    vis[u] = 1; s.insert(a[u]);    for (auto v : e[u]) {        if (!vis[v]) dfs(v);    }}inline void work() {    int n = rd(); m.clear(); m0.clear(); cnt = 0;    for (int i = 1; i &lt;= n; ++i) {        a[i] = rd(); vis[i] = 0; indeg[i] = 0; e[i].clear();        m0[a[i]]++;    }    for (int i = 1; i &lt;= n; ++i) {        b[i] = rd(); e[i].pb(b[i]); ++indeg[b[i]];    }    for (int i = 1; i &lt;= n; ++i)        if (!indeg[i]) q.push(i);    while (!q.empty()) {        int u = q.front(); q.pop(); vis[u] = 1;        for (auto v : e[u]) {            --indeg[v];            if (!indeg[v]) q.push(v);        }    }    int ans = 1e7;    for (int i = 1; i &lt;= n; ++i)        if (!vis[i]) {            ++cnt; dfs(i);            for (auto val : s) m[val]++;            s.clear();        }    for (auto node : m) {        int val = node.first, cntt = node.second;        if (cntt != cnt) continue;        ans = min(ans, n - m0[val]);    }    if (ans == 1e7) puts(\"-1\");    else printf(\"%d\\n\", ans);}int main() {    for (int t = rd(); t; --t) work();    return 0;}","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"CF Round 760","url":"/2021/12/15/CF-Round760-Div3/","content":"好像有了些体验感……\n\n已经是第二次打 cf 了，第一次一道题都没过，这次过了四道题，大概确实是有些了体验感。（虽然别人几分钟就过题了，但我十分稳定地半小时过一道，从开头做到结尾\n来补题\nF ReverseProblem Restatement给两个正实数  , 问能不能经过下面的操作将  变成  。\n操作：将  转化成二进制数（无前导0），在它的后面加上一个 0 或 1 ，然后前后反转得到新的  。\n思路加 0 其实是没有意义的，所以我们只需要讨论加不加 1 。对于一个二进制末尾有 0 的  , 不加 1 相当于去掉末尾连续的 0 ；加 1 相当于保留末尾的 0 ，并在末尾加 1 后反转。仔细思考以后，我们可以发现，在第一次操作之后， 中 0 的个数就确定了。故问题转化为经过变化的  是否是  的二进制的子串，且 在中  中所有的  是否都被该子串覆盖。\n故我们需要考虑 4 种  ，看看是否存在符合上述条件的  。即去掉原来  的后缀 0 ，去掉后缀 0 后翻转，在原来  后加 1 ，加 1 后翻转。\n代码#include&lt;bits/stdc++.h&gt;#define N 10007using namespace std;typedef long long ll;inline ll rd() {  ll x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int a[67], b[67], c[67], m, n, len;bool check(int pos){    for(int i = 1; i &lt; pos; ++i)        if(b[i] == 0) return 0;    for(int i = pos + len; i &lt;= m; ++i)        if(b[i] == 0) return 0;    for(int i = 1; i &lt;= len; ++i)        if(b[pos + i - 1] != c[i]) return 0;    return 1;}int main() {    ll x = rd(), y = rd();    if(x == y) {puts(\"YES\"); return 0;}    while(x != 0){        a[++n] = x % 2;        c[n] = a[n];        x /= 2;    }    while(y != 0){        b[++m] = y % 2;        y /= 2;    }    reverse(a + 1, a + 1 + n);    reverse(b + 1, b + 1 + m);    reverse(c + 1, c + 1 + n);    len = n;    while(c[len] == 0) len--;    for(int i = 1; i &lt;= m - len + 1; ++i){        if(check(i)) {puts(\"YES\"); return 0;}    }    reverse(c + 1, c + 1 + len);    for(int i = 1; i &lt;= m - len + 1; ++i){        if(check(i)) {puts(\"YES\"); return 0;}    }    a[++n] = 1;    for(int i = 1; i &lt;= n; ++i) c[i] = a[i];    len = n;    for(int i = 1; i &lt;= m - len + 1; ++i){        if(check(i)) {puts(\"YES\"); return 0;}    }    reverse(c + 1, c + 1 + len);    for(int i = 1; i &lt;= m - len + 1; ++i){        if(check(i)) {puts(\"YES\"); return 0;}    }    puts(\"NO\");    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"求和、差分、哈希","url":"/2021/08/17/ColinClass1/","content":"Colin 课堂开课啦 ~ ~ 孩子代码总不会，多半是学不会啦！（不是\n\n复杂度先来说说关于复杂度的事情，为什么要关注一个算法的复杂度嘞？（因为不关注会 TLE\n首先，常见的计算机运算能力大概是 3e7 ，这是常识（不是\n根据上面的常识，我们来列列如下的表格：\n\n再比如，如果一个题，它的数据范围大概是5000，那么我们要选的算法的复杂度可能是  或 ​​​ 等\n（学了复杂度，大概就能知道，我写的代码大部分都会 TLE）\n离散的积分和微分离散的积分，其本质为求和；离散的微分，其本质为差分。\n给定一组数列 ，我们可以分别用积分和微分的想法求 \n\na_k = \\sum_{i = 1}^k (a_i - a_{i - 1}) = \\sum_{i = 1}^k a_i - \\sum_{i = 1}^{k - 1} a_i例1（求和）给定一组数列  ，共有  次询问，每次询问给出一组  和  ，问  到  的和。\n解1如果暴力直接做，复杂度是  大概是  级别的，而  的范围为  ，所以不能暴力做。\n我们可以发现，要求  到  的和，可用如下公式\n\n\\sum_{i = l}^r a_i = \\sum_{i = 1}^r a_i - \\sum_{i = 1}^{l - 1} a_i 我们记  ，则上面的公式可表示为  。\n那么，问题就转换为，对于每个位置 ，求出从  到  的和。\n如果暴力对每个位置求从  到  的和，复杂度还是  。观察可发现有如下式子成立 ​​ ，用此方法求前缀和。\n综上，该算法的复杂度为  \n例2（差分）给定一组数列  ，共有  次询问，每次询问给出一组    ，对从  到  范围里的数 ， 次问询后，输出数列的每一项。\n解2如果暴力直接做，复杂度是  大概是  级别的，而  的范围为 ​ ，所以不能暴力做。\n利用积分微分思想求 ​ ，我们利用等式的前半部分即 ​ ，若令 ​\n\n注： 且 \n\n那么每一次操作就相当于 ，\n综上，该算法的复杂度为  \n练1给定一组数列 ​​​​​ ，共有 ​​​​​ 次询问，每次询问给出一组 ​​​​​  ​​​​​ ，对从 ​​​​​ 到 ​​​​​ 范围里的数 ​​。​​​​​ 次问询后，输出数列的每一项。\n#include &lt;bits/stdc++.h&gt;#define N 1000007using namespace std;int a[N], b[N], c[N];int main(){\tint n, q, l, r;\tcin &gt;&gt; n &gt;&gt; q;\tfor(int i = 1; i &lt;= n; ++i){\t\tcin &gt;&gt; a[i];\t\tb[i] = a[i] - a[i - 1];\t\tc[i] = b[i] - b[i - 1];\t}\t\twhile(q--){ //l &amp; r 从1开始数 \t\tcin &gt;&gt; l &gt;&gt; r;\t\tc[l] += 1;\t\tc[r + 1] -= r - l + 2;\t\tc[r + 2] += r - l + 1;\t}\tfor(int i = 1; i &lt;= n; ++i){\t\tb[i] = b[i - 1] + c[i];\t\ta[i] = a[i - 1] + b[i];\t\tcout &lt;&lt; a[i] &lt;&lt; ' ';\t}\treturn 0;}\n两次差分，最后两次求和。\n练二https://codeforces.com/gym/102770/problem/A\n串（哈希篇）\n哈希 是用来干啥的呢？？我们想用哈希来干啥呢？？？\n字符串一般比较长，且比较难处理，但一般来说，数字是比较好处理的。所以我们想构造一个，字符串和数字之间的一种双射关系。受各种进制相互转换的感发，我们尝试把字符串看作一种进制，并让该字符串与转换为十进制的数字相对应。举个例子，假设我们有个字符串 abdc 因为这个串中只有4个不同的字符，我们可以选定 ​​ （&gt;4即可），并按字母的顺序，视 ​ ，则该字符串对应的数字为 ​ 。在计算的同时，我们能发现一个问题，就是这个数字可能会很大，甚至超出 int 所能存储的范围。为了解决这个问题我们选择取模的方式，将数字控制在一定的范围之内。\n为了减少 哈希冲突 （取模后两个不同字符串对应数字相同），我们需要选一个大质数作为模数，通常会选用  或 ​​​ 。若想更近一步减少哈希冲突，我们可以选择“哈哈”（双哈），即让一个字符串对应的数字分别对两个不同的大质数取模。对于两个字符串，只有当两个取模后的数都相同时，我们才认为这两个字符串相等。“哈哈”能十分有效避免哈希冲突。\n秦九昭如果字符串很长，那我们就需要 base 的高次运算。就算使用快速幂，这个过程也会十分麻烦。故我们采用下面的计算方式，还引用上面的例子，对应数字将如下计算 ​​ 。\n这个式子有什么好处呢？\n\n计算方便\n我们观察能发现，这个式子括号里面的值，就是该字符串从开头到当前字符的哈希值。什么意思呢？还引用上面的例子。 是  对应的值，而  是  对应的值，以此类推。故这个式子，可以利用前一项已知串的哈希值计算出后一项的哈希值。​\n\n例1https://loj.ac/p/103\n解1根据 秦九昭 我们可以很方便的计算出， 即从第  个字符到第  个字符这个字符串对应的哈希值。那么我们要怎么得到字符串  里每一个长度为  子串的哈希值呢？经过思考不难得出如下式子： 。故要判断  串在  串中出现的次数，只需要依次比较  中长度为  的字串的哈希值是否与  串的哈希值相同即可。\n\n不要忘记取模，在任何可能出现过大数字的地方都要及时取模。\n取模前若有可能出现负数，则应该先 ，再  。\n\n#include &lt;bits/stdc++.h&gt;#define N 1000007#define base 53#define mod 1000000007using namespace std;char a[N], b[N];int h[N], B[N];int get(char c) {    if (c &lt;= 'Z' &amp;&amp; c &gt;= 'A')        return c - 'A';    else        return c - 'a' + 32;}int hh(int l, int r) {    return (h[r] - 1ll * h[l - 1] * B[r - l + 1] % mod + mod) % mod;}int main() {    scanf(\"%s\", a + 1);    scanf(\"%s\", b + 1);    int n = strlen(a + 1);    int m = strlen(b + 1);    int cnt = 0, hash = 0;    for (int i = 1; i &lt;= m; ++i)        hash = (1ll * hash * base + get(b[i])) % mod;    B[0] = 1;    for (int i = 1; i &lt;= n; ++i) {        B[i] = 1ll * B[i - 1] * base % mod;        h[i] = (1ll * h[i - 1] * base + get(a[i])) % mod;    }    for (int i = m; i &lt;= n; ++i)        if (hh(i - m + 1, i) == hash)            cnt++;    cout &lt;&lt; cnt &lt;&lt; endl;    return 0;}\n常用 base: 31 53 mod: 1e9+7 (双哈 mod2 = 1e9+9)\n跟Co老师学习好累……\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"二分","url":"/2021/08/18/ColinClass2/","content":"问你啥，你就二分啥 ~\n\n二分查找二分查找的前提是一个顺序表，即一张有序（升序或降序）的表。\n例1在一组升序的数组中   ，查找值为  的数组下标，若找不到，则输出“Can’t find”。\n解1这题十分常规，核心代码如下：\nl = 1, r = n;while(l &lt; r){    mid = (l + r) / 2;    if(a[mid] == x) {cout &lt;&lt; mid &lt;&lt; endl; return;}    if(a[mid] &lt; x) l = mid + 1;    else r = mid - 1;}cout &lt;&lt; \"Can't find\" &lt;&lt; endl; return;\n例2在一组升序的数组中   ，查找值为  的数组下标，若找不到，则输出比  小的最大值的下标。\n解2这道题和例1的区别就是，当找不到时，需要返回比  小的最大值的下标，核心代码如下：\nl = 1, r = n;while(l &lt; r){    mid = (l + r + 1) / 2;    if(a[mid] &lt;= x) l = mid;    else r = mid - 1;}cout &lt;&lt; l &lt;&lt; endl; return;\n\nmid = (l + r + 1) / 2 是因为，如果 mid = (l + r) / 2 ，当 l = 1, r = 2 且 a[1] &lt;= x 时，将会陷入死循环。所以在书写代码时，我们可以适当检验，来决定 mid 的取值。\n\n二分答案\n典型的使用场景:  要求我们求出某种条件的最大值的最小可能情况或者最小值的最大情况 \n使用前提:  \n\n答案在一个固定的区间内 \n难以通过搜索来找到符合要求的值, 但给定一个值你可以很快的判断它是不是符合要求 \n可行解对于区间要符合单调性, 因为有序才能二分嘛\n\n\n要想利用二分答案我们需要找到单调性，如图所示\n\n例1https://www.luogu.com.cn/problem/P2678\n解1-1最怕写什么 dfs\\bfs 结果Co老师让我先不管复杂度，dfs 一下，我真是太难了。枚举拿走的  块石头。，代表石头，伪代码如下：\nvector&lt;int&gt; S; // 存放拿走的石头dfs(int x, int y){ //x为a的下标，y为当前向量中的元素个数    if(x == n + 1 || y == m) {give(S); return;}    S.push_bach(a[x]); //a[x]放进去    dfs(x + 1, y + 1);     S.pop_back();    dfs(x + 1, y); //a[x] 不放进去}int main(){    dfs(1,0);}\n解1-2对于这道题来说，我们令横坐标  的含义为，拿走石头以后，每一步的距离都大于等于  ，即最短路径大于等于 ，而判断是否成立的条件就是，拿走石头的数量是否小于等于  。\n在  很小的时候一定成立，在  很大的时候一定不成立。\n#include &lt;bits/stdc++.h&gt;#define N 50008using namespace std;int a[N];int m, n, l;inline bool valid(int x){\tint nowl = 0, cnt = 0;\tfor(int i = 1; i &lt;= n; ++i){\t\tif(a[i] - nowl &lt; x) ++cnt;\t\telse nowl = a[i];\t}\treturn cnt &lt;= m;}int main(){\tcin &gt;&gt; l &gt;&gt; n &gt;&gt; m;\tfor(int i = 1; i &lt;= n; ++i){\t\tcin &gt;&gt; a[i];\t}\tint le = 0, re = l;\twhile(le &lt; re){\t\tint mid = (le + re + 1) / 2;\t\tif(valid(mid)) le = mid;\t\telse re = mid - 1;\t}\tcout &lt;&lt; le &lt;&lt; endl;\treturn 0;}\n例2https://www.acwing.com/problem/content/141/\n解2根据上一篇博客的内容，我们知道，要判断两个串是否相等，可以采用哈希的方式。因为要判断的是回文串，所以我们需要计算正反两种哈希值。\n在这里我们可以发现，对于一个固定的中间位置（可能是一个字符，可能是空），长度大的时候成立，则长度小的时候一定成立，长度很小的时候（为0）一定成立，所以长度就是我们要找的单调性，即要二分的  。\n#include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;#define N 1000007#define base 31#define mod 100000007using namespace std;char s[N];int h[N], h1[N], B[N], Max, cnt;inline int hhr(int l, int r) {    return (h[r] - 1ll * h[l - 1] * B[r - l + 1] % mod + mod) % mod;}inline int hhl(int l, int r) {    return (h1[l] - 1ll * h1[r + 1] * B[r - l + 1] % mod + mod) % mod;}inline bool valid(int pos, int len){\treturn hhl(pos - len, pos - 1) == hhr(pos + 1, pos + len);}inline bool valid1(int pos, int len){\treturn hhl(pos - len + 1, pos) == hhr(pos + 1, pos + len);}inline void cB(){\tB[0] = 1;\tfor (int i = 1; i &lt;= N; ++i)        B[i] = 1ll * B[i - 1] * base % mod;}int main() {\tcB();\twhile(scanf(\"%s\", s + 1)){\t\tMax = 0;\t\tif(s[1] == 'E') return 0;\t\telse{\t\t\tint len = strlen(s + 1);\t\t\t    \t\tfor (int i = 1; i &lt;= len; ++i)        \t\th[i] = (1ll * h[i - 1] * base + s[i] - 'a') % mod;        \t\t        \th1[len + 1] = 0;    \t\tfor (int i = len; i; --i)        \t\th1[i] = (1ll * h1[i + 1] * base + s[i] - 'a') % mod;        \t\t        \tfor(int i = 1; i &lt;= len; ++i){        \t\t        \t\tint ll = 0; int rr = min(i - 1, len - i);        \t\twhile(ll &lt; rr){        \t\t\tint mid = (ll + rr + 1) / 2;        \t\t\tif(valid(i, mid)) ll = mid;        \t\t\telse rr = mid - 1;\t\t\t\t}\t\t\t\tMax = max(Max, 2 * ll + 1);\t\t\t\tll = 0; rr = min(i, len - i);        \t\twhile(ll &lt; rr){        \t\t\tint mid = (ll + rr + 1) / 2;        \t\t\tif(valid1(i, mid)) ll = mid;        \t\t\telse rr = mid - 1;\t\t\t\t}\t\t\t\tMax = max(Max, 2 * ll);\t\t\t}\t\t}\t\tprintf(\"Case %d: %d\\n\", ++cnt, Max);\t}}\n例3实数域：https://www.luogu.com.cn/problem/P1577\n解3#include &lt;bits/stdc++.h&gt;#define N 10008using namespace std;double a[N];int n, k;inline bool valid(double x){\tint cnt = 0;\tfor(int i = 1; i &lt;= n; ++i){\t\tcnt += a[i] / x;\t}\treturn cnt &gt;= k;}int main(){\tcin &gt;&gt; n &gt;&gt; k;\tfor(int i = 1; i &lt;= n; ++i){\t\tcin &gt;&gt; a[i];\t}\tdouble le = 0.0, re = 100007.3;\twhile(le + 0.01 &lt; re){\t\tdouble mid = (le + re) / 2.0;\t\tif(valid(mid)) le = mid;\t\telse re = mid;\t}\tcout &lt;&lt; le &lt;&lt; endl;\treturn 0;}\n例4https://www.luogu.com.cn/problem/P1182\n解4#include &lt;bits/stdc++.h&gt;#define N 100005using namespace std;int a[N], n, m;inline bool work(int x){ //每段的长度都小于等于x\tint cnt = 0, sum = 0;\tfor(int i = 1; i &lt;= n; ++i){\t\tsum = a[i];\t\twhile(i &lt; n &amp;&amp; sum + a[i + 1] &lt;= x) {\t\t\ti++;\t\t\tsum += a[i];\t\t}\t\tcnt++;\t}\treturn cnt &lt;= m;}int main(){\tcin &gt;&gt; n &gt;&gt; m;\tint i = 0, j = 0;\tfor(int k = 1; k &lt;= n; ++k){\t\tcin &gt;&gt; a[k];\t\tif(a[k] &gt; i) i = a[k];\t\tj += a[k];\t}\twhile(i &lt; j){\t\tint mid = (i + j)/2;\t\tif(work(mid)) j = mid;\t\telse i = mid + 1;;\t}\tcout &lt;&lt; j;\treturn 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"ST Table、数论初步","url":"/2021/08/19/ColinClass3/","content":"Co老师也太强了吧 ！！！\n\nST 表ST 表是基于 倍增 思想，用于解决 可重复贡献问题 的数据结构。\n什么是可重复贡献问题？ 可重复贡献问题 是指对于运算   ，满足     ，则对应的区间询问就是一个可重复贡献问题。例如，max 有  , gcd 有  ，所以区间最大值或最小值、区间 GCD 就是一个可重复贡献问题。可重复地意思是指，假设已经知道了一个区间的两个子区间（可重叠）的答案，且这两个子区间的并集包含该区间，则可由这两个子区间的答案，快速计算出该区间的答案。像区间和就不具有这个性质，如果求区间和的时候采用的预处理区间重叠了，则会导致重叠部分被计算两次。另外，  还必须满足结合律         才能使用 ST 表求解。\n\n综上想要使用 ST 表，需具备以下条件：\n\n  \n区间重叠不影响答案的正确性\n       \n\n\n例1来看一道模板题吧~\nhttps://www.luogu.com.cn/problem/P3865\n解1补充常识：\nmx[i][j] 的含义：起点为  ，长度为  的区间的最大值。\n #include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#define N 100008using namespace std;int mx[N][20]; inline int read(){\tint x = 0,f = 1;\tchar ch = getchar();\twhile (ch&lt;'0'||ch&gt;'9'){if (ch=='-') f=-1;ch=getchar();}\twhile (ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-48;ch=getchar();}\treturn x*f;}inline int getmx(int l, int r){\tint len = r - l + 1;\tint t = (int)log2(len);\treturn max(mx[l][t], mx[r - (1 &lt;&lt; (t)) + 1][t]);}int main(){\tint n, m;\tn = read(); m = read();\tfor(int i = 1; i &lt;= n; ++i) mx[i][0] = read();\tfor(int j = 1; j &lt;= log2(n); ++j)\t\tfor(int i = 1; i &lt;= n - pow(2, j) + 1; ++i)\t\t\tmx[i][j] = max(mx[i][j - 1], mx[i + (1 &lt;&lt; (j - 1))][j - 1]);\twhile(m--){\t\tint l = read();\t\tint r = read();\t\tprintf(\"%d\\n\", getmx(l, r));\t}\treturn 0;}\n数论初步 （约数相关）素数与合数素数  的约数只有  和  \n 既不是素数，也不是合数\n算数基本定理内容 如果不考虑排列次序的话，每个大于1的自然数都只能有一种方式分解成若干个（大于等于 1 个）素数的乘积。\n性质1.（存在性）每个大于 1 的自然数都可以分解成素数的乘积。\n2.（唯一 性）这种分解，再不考虑排列次序的意义下，是唯一的。\n约数与倍数对于  如果  称  是  的公约数。对于其中最大的  ，称  是  的最大公约数，记为 \n对于  如果  称  是  的公倍数。对于其中最小的  ，称  是  的最小公倍数，记为 \n集合含义 ， \nGCD ：\nLCM ：\n除法对于整数  ，存在唯一的两个整数  使得： \n带余除法   = \n整除 记做  ，此时也称  是  的倍数， 是  的约数。\n\n 性质\n\n \n \n \n\n\n一些常用的复杂度常识素数分布：\n调和级数：  \n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"two pointer + greedy、欧几里得算法","url":"/2021/08/21/ColinClass4/","content":"祝亲爱的”汉堡“（涵宝）生快~\n\n\n双指针此指针非彼指针 ~\n双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的。\n双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。\n例1https://codeforces.com/problemset/problem/1007/A\n解1两个指针均从最大值的地方开始进行扫描，指针  代表当前需要被匹配的数字，指针  代表当前所剩数字中最大的数字，若  则  ，否则  指针继续向前移。\n#include &lt;bits/stdc++.h&gt;#define N 100007using namespace std;int a[N];int main(){\tint n;\tcin &gt;&gt; n;\tfor(int i = 1; i &lt;= n; ++i){\t\tcin &gt;&gt; a[i];\t}\tsort(a + 1, a + n + 1);\tint i = n, j = n, cnt = 0;\twhile(i){\t\tif(a[i] &lt; a[j]) {++cnt; --j;}\t\ti--;\t}\tcout &lt;&lt; cnt &lt;&lt; endl;\treturn 0;}\n例2https://codeforces.com/problemset/problem/1133/C\n解2#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;int a[N];int main(){\tint n;\tcin &gt;&gt; n;\tfor(int i = 1; i &lt;= n; ++i){\t\tcin &gt;&gt; a[i];\t}\tsort(a + 1, a + n + 1);\tint i, j = n, cnt, Max = 0;\tfor(int i = n; i &gt; 0; --i){\t\twhile(j &gt; 0 &amp;&amp; a[i] - 5 &lt;= a[j]){\t\t\tcnt = i - j + 1;\t\t\tj--;\t\t}\t\tMax = max(Max, cnt);\t}\tcout &lt;&lt; Max &lt;&lt; endl;\treturn 0;}\n欧几里得算法求最大公约数利用的性质   \n模板int gcd(int a, int b){\treturn b ? gcd(b, a % b) : a;}\n复杂度分析\n\\begin{cases}\na < b &\\rightarrow & change(b,a)\\\\\na > b &\\rightarrow & a\\mod b < \\frac a 2 ","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"01BFS","url":"/2021/08/24/ColinClass6/","content":"学不会的BFS，神仙建图\n\n干啥的用来解决：边权值为  或  ，或者能够转化为这种边权值的最短路问题\n在 bfs 的基础上做如下改动：\n\n用 deque 取代 queue\n边权为  时，从双端队列的前端插入；边权为  时，从双端队列的后端插入。\n\n悟悟悟例1Eva.oj 0005\n给一个  迷宫， . 代表道路，# 代表墙 ，求从  到  所需要拐弯的最少次数。\n解1技巧：拆点。把每一个点拆成水平方向和垂直方向的两个点。\n依次给拆开的点编号。先存水平方向的，再存垂直方向的，水平点之间的边和垂直点之间的边边权为  ，再在垂直点和水平点之间连一条边，边权为  。\n水平方向的点用 ida(int x, int y) 计算编号，依次从  到  。\n垂直方向的点用 idb(int x, int y) 计算编号，依次从  到  。\npair(int a, int b) ：a 代表点的编号，b 代表边权 。\n再连接同一个点的水平点和垂直点，边权为  。\ne[N * N * 2] 邻接表。\ndis[N * N * 2] 存放距离。\n#include&lt;bits/stdc++.h&gt;#define N 1007 #define mp make_pair#define pii pair&lt;int, int&gt;#define fr first#define sc second#define pb push_back#define pf push_front using namespace std;int n, m, dis[N * N * 2];deque&lt;int&gt; dq;int ida(int x, int y) {return (x - 1) * m + y;}int idb(int x, int y) {return (x - 1) * m + y + n * m;}bool ty[N][N];inline bool valid(int x, int y) {\treturn x &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &gt; 0 &amp;&amp; y &lt;= m &amp;&amp; ty[x][y];}vector&lt;pii&gt; e[N * N * 2];const int dx[4] = {0, 0, 1, -1};const int dy[4] = {1, -1, 0, 0};int main() {\tscanf(\"%d%d\", &amp;n, &amp;m);\tfor (int i = 1; i &lt;= n; ++i)\t\tfor (int j = 1; j &lt;= m; ++j) {\t\t\tchar c = getchar();\t\t\twhile (c != '.' &amp;&amp; c != '#') c = getchar();\t\t\tty[i][j] = (c == '.');\t\t}\tfor (int x = 1; x &lt;= n; ++x)\t\tfor (int y = 1; y &lt;= m; ++y) {\t\t\tdis[ida(x, y)] = dis[idb(x, y)] = 1000000000;\t\t\tif (ty[x][y]) {\t\t\t\tfor (int k = 0, tx, ty; k &lt; 2; ++k) {\t\t\t\t\ttx = x + dx[k]; ty = y + dy[k];\t\t\t\t\tif (valid(tx, ty)) e[ida(x, y)].pb(mp(ida(tx, ty), 0));\t\t\t\t}\t\t\t\tfor (int k = 2, tx, ty; k &lt; 4; ++k) {\t\t\t\t\ttx = x + dx[k]; ty = y + dy[k];\t\t\t\t\tif (valid(tx, ty)) e[idb(x, y)].pb(mp(idb(tx, ty), 0));\t\t\t\t}\t\t\t\te[ida(x, y)].pb(mp(idb(x, y), 1));\t\t\t\te[idb(x, y)].pb(mp(ida(x, y), 1)); \t\t\t}\t\t}\tdis[1] = dis[n * m + 1] = 0;\tdq.pb(1); dq.pb(n * m + 1);\twhile(!dq.empty()){\t\tint t = dq.front();\t\tdq.pop_front();\t\tfor(auto i : e[t]){\t\t\tif(dis[i.fr] &gt; dis[t] + i.sc) {\t\t\t\tdis[i.fr] = dis[t] + i.sc;\t\t\t\ti.sc ? dq.pb(i.fr) : dq.pf(i.fr);\t\t\t}\t\t}\t}\tint ans = min(dis[n * m], dis[n * m * 2]);\tif(ans == 1000000000) printf(\"Impossible!!!!\");\telse printf(\"%d\", ans);\treturn 0;} \n练练练例1Wizard in Maze\nhttps://atcoder.jp/contests/abc176/tasks/abc176_d\n给一个无向图，. 代表道路 # 代表墙。有两种移动方法：\n\n向上下左右走，代价为  \n使用一次魔法，可以任意移动到以该点为中心的 5*5 的矩阵中的任意一点，代价为  \n\n给定起点和终点，问从起点运动到终点所需代价最小为多少。\n解1我们先将起点放入队列中，依次扫描跟起点相连的点（上下左右，和 5*5 矩阵里的点），当 dis 能被更新时，就更新。更新以后放入队列。\n这里为什么不开 vis 呢？？\n因为有可能出现以下情况：队列里的两个点  都与点  相连，从  到  的代价为  ，而从  到  的代价为  。如果用 vis 打标记的话，它最终会从  点连边到  ，而不是  \n#include&lt;bits/stdc++.h&gt;#define N 1007using namespace std;int n, m, bex, bey, fix, fiy, dis[N][N];bool ty[N][N];deque&lt;pair&lt;int, int&gt; &gt; q;inline bool valid(int x, int y) {\treturn x &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &gt; 0 &amp;&amp; y &lt;= m &amp;&amp; ty[x][y];}const int dx[4] = {0, 0, 1, -1};const int dy[4] = {1, -1, 0, 0};int main() {\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; bex &gt;&gt; bey &gt;&gt; fix &gt;&gt; fiy;\tfor (int i = 1; i &lt;= n; ++i)\t\tfor (int j = 1; j &lt;= m; ++j) {\t\t\tchar c = getchar();\t\t\twhile (c != '.' &amp;&amp; c != '#') c = getchar();\t\t\tty[i][j] = (c == '.');\t\t\tdis[i][j] = 1000000000;\t\t}\tif(!valid(bex, bey)){\t\tcout &lt;&lt; \"-1\" &lt;&lt; endl;\t\treturn 0;\t}\tdis[bex][bey] = 0;\tq.push_front(make_pair(bex, bey));\twhile(!q.empty()){\t\tpair&lt;int, int&gt; t = q.front();\t\tq.pop_front();\t\tfor(int i = 0; i &lt; 4; ++i){\t\t\tint tx = t.first + dx[i];\t\t\tint ty = t.second + dy[i];\t\t\tif(valid(tx, ty) &amp;&amp; dis[tx][ty] &gt; dis[t.first][t.second]) {\t\t\t\tdis[tx][ty] = dis[t.first][t.second];\t\t\t\tq.push_front(make_pair(tx, ty));\t\t\t}\t\t}\t\tfor(int i = -2; i &lt;= 2; ++i){\t\t\tfor(int j = -2; j &lt;= 2; ++j){\t\t\t\tint tx = t.first + i;\t\t\t\tint ty = t.second + j;\t\t\t\tif(valid(tx, ty) &amp;&amp; dis[tx][ty] &gt; dis[t.first][t.second] + 1){\t\t\t\t\tdis[tx][ty] = dis[t.first][t.second] + 1;\t\t\t\t\tq.push_back(make_pair(tx, ty));\t\t\t\t}\t\t\t}\t\t}\t}\tif(dis[fix][fiy] == 1000000000) cout &lt;&lt; \"-1\" &lt;&lt; endl;\telse cout &lt;&lt; dis[fix][fiy] &lt;&lt; endl;\treturn 0;}\n例2https://codeforces.com/problemset/problem/1046/D\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"拓扑排序 (有向图嘞)","url":"/2021/08/25/ColinClass7/","content":"排序的啰 ~ 那么这次按啥顺序排嘞？？？\n\n按啥顺序排呢？该排序满足这样的条件——对于图中的任意两个结点  和  ，若存在一条有向边从  指向  ，则在拓扑排序中  一定出现在  前面\n悟悟悟例1Eva.oj 0006\n给一个有向图，判断图中是否存在“环”。\nInput Format\n第一行两个整数  和  ，代表图中的点数和边数，接些来  行，每行两个整数  ，有一条边从  号点指向  号点。\nOutput Format\n有环则输出 ”exist loop!“ ；否则第一行输出 “no loop!”，然后输出任意一个包含所有点的序列。\n解1采用邻接表的方式存图，数组 indeg[N] ，用来存每个点的入度，当入度为  时，说明这个点已经没有前置的点了，把这个点放到队列里。每次从队列里出一个元素，代表这个点进入序列，所有这个点的出边指向的点的入度  。seq 用来存储最后要被输出的序列，\nint indeg[N];vector &lt;int&gt; e[N], seq;queue&lt;int&gt; q;inline int rd(){\tchar c = getchar();\twhile(!isdigit(c)) c = getchar();\treturn c - '0';}int main() {\tint n = rd(), m = rd();\tfor (int i = 1, u, v; i &lt;= m; ++i) {\t\tu = rd(); v = rd();\t\t++indeg[v]; e[u].push_back(v));\t} \tfor (int i = 1; i &lt;= n; ++i)\t\tif (!deg[i]) q.push(i);\twhile (!q.empty()) {\t\tint u = q.front();\t\tq.pop(); seq.push_back(u);\t\tfor (auto v : e[u]) {\t\t\t—-deg[v];\t\t\tif (!deg[v]) q.push(v);\t\t}\t\t}\tif (seq.size() &lt; n) puts(“exist loop!”);\telse {\t\tputs(“no loop!”);\t\tfor (auto u : seq) printf(“%d “, u);\t}\t\treturn 0;}\n例2Eva.oj 0007\n在一个有向图中，输出最长路径的长度，若图不连通，输出 “inf”。\nInput Format\n第一行两个整数  和  ，代表图中的点数和边数，接些来  行，每行两个整数  ，有一条边从  号点指向  号点。\nOutput Format\n一个整数代表该图中的最长路径长度。若不连通输出 ”inf“。\n解2来 dp 吧！！！！\ndp 就需要状态转移方程啰。f[i] 代表以  号点为终点的路径的最长长度。则状态转移方程为 ;  为有出边指向  号点的点的编号。\nqueue&lt;int&gt; q;int indeg[N], f[N]; vector&lt;int&gt; a[N], seq;inline int rd(){\tchar c = getchar();\twhile(!isdigit(c)) c = getchar();\treturn c - '0';}int main(){\tint n = rd(), m = rd();\tfor(int i = 1; i &lt;= m; ++i){\t\tint u = rd(), v = rd();\t\t\t\t++indeg[v];\t\ta[u].push_back(v);\t}\tfor(int i = 1; i &lt;= n; ++i){ \t\tif(!indeg[i]){\t\t\tq.push(i);\t\t\tseq.push_back(i);            f[i] = 0;\t\t}\t}\twhile(!q.empty()){\t\tint u = q.front();\t\tq.pop();\t\tfor(auto i : a[u]){\t\t\t—-indeg[i]; \t\t\tf[i] = max(f[i], f[u] + 1);\t\t\tif(!indeg[i]){\t\t\t\tq.push(i);\t\t\t\tseq.push_back(i);\t\t\t}\t\t}\t}\tif(seq.size() &lt; n) printf(“inf”);\telse{\t\tint Max = 0;\t\tfor(int i = 1; i &lt;= n; ++i) Max = max(Max, f[i]);\t\tprintf(“%d”, Max);\t}\treturn 0;}\n例3Eva.oj 0008\n给一个有向图，输出该图中不同路径的条数。不同路径定义须满足的条件如下：\n\n长度不同\n同样的长度存在不同的点\n\nInput Format \n第一行两个整数  和  ，代表图中的点数和边数，接些来  行，每行两个整数  ，有一条边从  号点指向  号点。\nOutput Format\n一个整数代表该图中不同路径的长度。若不连通，输出 ”inf“。\n\n注：一个点到自己也算一条路径\n\n解3状态转移方程为  ，因为每个点都需要 +1 ，所以我们将每个点的 f[i] 初值设为  。\nqueue&lt;int&gt; q;int indeg[N], f[N]; vector&lt;int&gt; a[N], seq;inline int rd(){\tchar c = getchar();\twhile(!isdigit(c)) c = getchar();\treturn c - '0';}int main(){\tint n = rd(), m = rd();\tfor(int i = 1; i &lt;= m; ++i){\t\tint u = rd(), v = rd();\t\t\t\t++indeg[v];\t\ta[u].push_back(v);\t}\tfor (int i = 1; i &lt;= n; ++i) f[i] = 1;\tfor(int i = 1; i &lt;= n; ++i){ \t\tif(!indeg[i]){\t\t\tq.push(i);\t\t\tseq.push_back(i);\t\t}\t}\twhile(!q.empty()){\t\tint u = q.front();\t\tq.pop();\t\tfor(auto i : a[u]){\t\t\t—-indeg[i]; \t\t\tf[i] += f[u];\t\t\tif(!indeg[i]){\t\t\t\tq.push(i);\t\t\t\tseq.push_back(i);\t\t\t}\t\t}\t}\tif(seq.size() &lt; n) printf(“inf”);\telse{\t\tint ans = 0;\t\tfor(int i = 1; i &lt;= n; ++i) ans += f[i];\t\tprintf(“%d”, ans);\t}\treturn 0;}\n练练练例1最大食物链计数\nhttps://www.luogu.com.cn/problem/P4017\n解1求食物链的条数。状态转移方程为  ，入度为  的点初值为  ，其余点为  。最后答案是，所有出度为  的点的 f[i] 之和。 \n#include &lt;bits/stdc++.h&gt;#define N 5007#define mod 80112002using namespace std;int n, m;long long Ans;queue&lt;int&gt; q;vector&lt;int&gt; a[N];int indeg[N], f[N], outdeg[N];int main(){\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1; i &lt;= m; ++i){\t\tint u, v;\t\tcin &gt;&gt; u &gt;&gt; v;\t\ta[v].push_back(u);\t\t++indeg[u];\t\t++outdeg[v];\t}\tfor(int i = 1; i &lt;= n; ++i){\t\tif(!indeg[i]){\t\t\tf[i] = 1;\t\t\tq.push(i);\t\t}\t}\twhile(!q.empty()){\t\tint u = q.front();\t\tq.pop();\t\tfor(auto i : a[u]){\t\t\t--indeg[i];\t\t\tf[i] = (f[i] + f[u]) % mod;\t\t\tif(!indeg[i]){\t\t\t\tq.push(i);\t\t\t}\t\t}\t}\tfor(int i = 1; i &lt;= n; ++i){\t\tif(!outdeg[i]) Ans = (Ans + f[i]) % mod;\t}\tcout &lt;&lt; Ans &lt;&lt; endl; \treturn 0;} \n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"最短路","url":"/2021/09/05/ColinClass8/","content":"跑图？？\n\n最短路最短路问题，我们可以根据下面两种方式来分类\n第一种，按是否有边权。对于无边权的有向图，求最短路，我们用 BFS 。对于有边权的图，特殊的图可以采用 01BFS 求解，对于一般的图，将在后文详细讨论。\n第二种，根据“源”和“汇”的关系。分为单源单汇、单源多汇、多源单汇、多源多汇。 在实际算法中，我们其实不太关心单汇还是多汇。哦，原来只是因为老师都是简单讲讲。\nFloyd复杂度： \n顺序很重要！！！别的就不管了\n枚举  是用来更新的点，  是起点，  是终点。\nfor(int k = 1; k &lt;= n; ++k)\tfor(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= n; ++j)            a[i][j] = min(a[i][j], a[i][k] + a[k][j]);\nDijkstra\n每次从 「未求出最短路径的点」中 取出 距离起点 最小路径的点，以这个点为桥梁 刷新「未求出最短路径的点」的距离\n#include &lt;bits/stdc++.h&gt;#define N 10007using namespace std;int dis[N];bool vis[N];int main() {\tmemset(vis, 0, sizeof(vis));\tmemset(dis, 0x3f, sizeof(dis));\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\t// 读入存图 略 \tdis[s] = 0;\tfor(int i = 1; i &lt;= n; ++i){\t\t//find the min dis\t\tint nwmn = 1e9, u = 0;\t\tfor(int j = 1; j &lt;= n; ++j)\t\t\tif(!vis[j] &amp;&amp; dis[j] &lt; nwmn){\t\t\t\tnwmn = dis[j]; u = j;\t\t\t}\t\tvis[u] = 1;\t\tfor(int j = hd[u], v; j; j = e[j].nxt){\t\t\tdis[v = e[i].to] = min(dis[v], dis[u] + e[j].w);\t\t}\t}    return 0;}\nSPFASPFA(Shortest Path Faster Algorithm)算法是求单源最短路径的一种算法，它是Bellman-ford的队列优化，它是一种十分高效的最短路算法。\n很多时候，给定的图存在负权边，这时类似Dijkstra等算法便没有了用武之地，而Bellman-Ford算法的复杂度又过高，SPFA算法便派上用场了。SPFA的复杂度大约是 O(kE) ,  是每个点的平均进队次数(一般的， 是一个常数，在稀疏图中小于2)。\n但是，SPFA算法稳定性较差，在稠密图中SPFA算法时间复杂度会退化。\n实现方法：建立一个队列，初始时队列里只有起始点，在建立一个表格记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到他本身的路径赋为0）。然后执行松弛操作，用队列里有的点去刷新起始点到所有点的最短路，如果刷新成功且被刷新点不在队列中则把该点加入到队列最后。重复执行直到队列为空。\n此外，SPFA算法还可以判断图中是否有负权环，即一个点入队次数超过N。\n#include &lt;bits/stdc++.h&gt;#define N 10007using namespace std;int dis[N];bool vis[N];queue&lt;int&gt; q;int main() {\tmemset(vis, 0, sizeof(vis));\tmemset(dis, 0x3f, sizeof(dis));\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\t// 读入存图 略 \tdis[s] = 0; q.push(s); vis[s] = 1;\twhile(!q.empty()){\t\tint u = q.front();\t\tq.pop(); vis[u] = 0;\t\tfor(int i = hd[u], v; i; i = e[i].nxt){\t\t\tif(dis[v = e[i].to] &gt; dis[u] + e[i].w){\t\t\t\tdis[v] = dis[u] + e[i].w;\t\t\t\tif(!vis[v]) {q.push(v); vis[v] = 1;}\t\t\t}\t\t}\t}\treturn 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"背包","url":"/2022/01/20/DP1/","content":"What makes the desert beautiful is that somewhere it hides a well.\n\n0-1背包 个物品，书包体积为 ​ 。每个物品只能用一次。对于每个物品  分别表示物品的体积和价值。\n状态定义：f[i][j] 表示 前  个物品总体积为  时的最大收益。\n转移方程：f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]) \n#include&lt;bits/stdc++.h&gt;#define N 1007using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[1007][1007];int v[1007], w[1007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd();    }    int ans = 0;    memset(f, 0, sizeof(f));    for (int i = 1; i &lt;= n; ++i) {        for (int j = 0; j &lt;= m; ++j) {            if (j &lt; v[i]) f[i][j] = f[i - 1] [j];            else f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);            ans = max(ans, f[i][j]);        }    }    printf(\"%d\\n\", ans);    return 0;}\n因为初始化时 f[i][j] = 0 所以即使最后的总体积不到  ，我们也可以认为不到  的那部分体积用价值为  的物品填充好了，故最后答案可直接输出 f[n][m] 。\n#include&lt;bits/stdc++.h&gt;#define N 1007using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[1007][1007];int v[1007], w[1007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd();    }    memset(f, 0, sizeof(f));    for (int i = 1; i &lt;= n; ++i) {        for (int j = 0; j &lt;= m; ++j) {            if (j &lt; v[i]) f[i][j] = f[i - 1] [j];            else f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);        }    }    printf(\"%d\\n\", f[n][m]);    return 0;}\n压缩空间滚动数组因为我们在计算结果时只关心，该层上一层的答案是多少，故我们可用一个临时的一维数组保存下一层的答案。在计算完一层的答案后，将临时数组的值再赋值给数组 f 。\n#include&lt;bits/stdc++.h&gt;#define N 1007using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[1007], g[1007], v[1007], w[1007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd();    }    memset(f, 0, sizeof(f));    memset(g, 0, sizeof(g));    for (int i = 1; i &lt;= n; ++i) {        for (int j = 0; j &lt;= m; ++j) {            if (j &lt; v[i]) g[j] = f[j];            else g[j] = max(f[j], f[j - v[i]] + w[i]);        }        memcpy(f, g, sizeof(g));    }    printf(\"%d\\n\", f[m]);    return 0;}\n压成一个一维数组还可以发现，在计算某个位置时，我们只关心上一层小于等于当前位置的部分。故我们可以在一个一维数组里，选择从后往前更新，这样子也不会影响其他位置的计算结果。\n\n#include&lt;bits/stdc++.h&gt;#define N 1007using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[1007], v[1007], w[1007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd();    }    memset(f, 0, sizeof(f));    for (int i = 1; i &lt;= n; ++i) {        for (int j = m; j &gt;= 0; --j) {            if (j &lt; v[i]) f[j] = f[j];            else f[j] = max(f[j], f[j - v[i]] + w[i]);        }    }    printf(\"%d\\n\", f[m]);    return 0;}\n完全背包 个物品，书包体积为  。每个物品能用无限次。对于每个物品  分别表示物品的体积和价值。\n状态定义：f[i][j] 表示 前  个物品总体积为  时的最大收益。\n转移方程：f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i]) \n#include&lt;bits/stdc++.h&gt;#define N 1007using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[1007][1007], v[1007], w[1007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd();    }    memset(f, 0, sizeof(f));    for (int i = 1; i &lt;= n; ++i) {        for (int j = 0; j &lt;= m; ++j) {            if (j &lt; v[i]) f[i][j] = f[i - 1][j];            else f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i]);        }    }    printf(\"%d\\n\", f[n][m]);    return 0;}\n压缩#include&lt;bits/stdc++.h&gt;#define N 1007using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[1007], v[1007], w[1007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd();    }    memset(f, 0, sizeof(f));    for (int i = 1; i &lt;= n; ++i) {        for (int j = 0; j &lt;= m; ++j) {            if (j &lt; v[i]) f[j] = f[j];            else f[j] = max(f[j], f[j - v[i]] + w[i]);        }    }    printf(\"%d\\n\", f[m]);    return 0;}\n多重背包 个物品，书包体积为  。每个物品能用  次。对于每个物品  分别表示物品的体积和价值。\n拆成一个一个\n状态定义：f[i][j] 表示 前  组物品总体积为  时的最大收益。\n转移方程： \n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[1007], v[1007], w[1007], l[1007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd(); l[i] = rd();    }    memset(f, 0, sizeof(f));    for (int i = 1; i &lt;= n; ++i) {        for (int k = 1; k &lt;= l[i]; ++k)            for (int j = m; j &gt;= 0; --j) {                if (j &lt; v[i]) f[j] = f[j];                else f[j] = max(f[j], f[j - v[i]] + w[i]);            }    }    printf(\"%d\\n\", f[m]);    return 0;}\n二进制拆分\n#include&lt;bits/stdc++.h&gt;#define N 1007using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[2007], v[2007], w[2007], l[2007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd(); l[i] = rd();    }    for (int i = 1; i &lt;= n; ++i) {        int res = l[i];        for (int k = 1; k &lt;= res; res -= k, k &lt;&lt;= 2) {            int lim = v[i] * k, val = w[i] * k;            for (int j = m; j &gt;= lim; --j)               f[j] = max(f[j], f[j - lim] + val);        }        int lim = v[i] * res, val = w[i] * res;        for (int j = m; j &gt;= lim; --j)            f[j] = max(f[j], f[j - lim] + val);    }    printf(\"%d\\n\", f[m]);    return 0;}\n单调队列引入\n 是尾指针， 是头指针。\n 表示当前队列里的各个生物的攻击力。  表示队列里的各个生物的消失时间。\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int c[100007][2], a[100007], b[100007];int main() {    int n = rd();    for (int i = 1; i &lt;= n; ++i) {        a[i] = rd(); b[i] = rd();    }    int k = 0, l = 1;    for (int i = 1; i &lt;= n; ++i) {        for (; k &gt;= l &amp;&amp; b[i] &gt;= c[k][0]; --k);        c[++k][0] = b[i]; c[k][1] = a[i];        printf(\"%d\\n\", c[l][0]);        for(; k &gt;= l &amp;&amp; c[l][1] == i; ++l);    }    return 0;}\n优化背包 \n状态定义：f[i][j] 表示 前  组物品总体积为  时的最大收益。\n转移方程： \n没学会，等Co老师教我……\n分组背包物品属于不同的组，每一个组里只能取一个物品，每个物品只能用一次。\n状态定义：f[i][j] 表示 前  组物品总体积为  时的最大收益。\n转移方程： \n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[1007][1007], a[1007], v[1007], w[1007];vector&lt;int&gt; c[1007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        a[i] = rd(); v[i] = rd(); w[i] = rd();        c[a[i]].push_back(i);    }    for (int i = 1; i &lt;= 1000; ++i) {       for (int j = 0; j &lt;= m; ++j) {           f[i][j] = f[i - 1][j];           for (auto k : c[i])                if (v[k] &lt;= j)                   f[i][j] = max(f[i][j], f[i - 1][j - v[k]] + w[k]);       }    }    printf(\"%d\\n\", f[1000][m]);    return 0;}\n压缩跟0-1背包同理\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[1007], a[1007], v[1007], w[1007];vector&lt;int&gt; c[1007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        a[i] = rd(); v[i] = rd(); w[i] = rd();        c[a[i]].push_back(i);    }    for (int i = 1; i &lt;= 1000; ++i)       for (int j = m; j; --j)           for (auto k : c[i])                if (v[k] &lt;= j)                   f[j] = max(f[j], f[j - v[k]] + w[k]);    printf(\"%d\\n\", f[m]);    return 0;}\n二维背包不仅有体积限制，还有体力限制，每个物品只能用一次。\n状态定义：f[i][j][k] 表示 前  个物品，总体积为  ，消耗总体力为  时的最大收益。\n转移方程：\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[107][107][107], t[107], v[107], w[107];int main() {    int n = rd(), m = rd(), k = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd(); t[i] = rd();    }    for (int i = 1; i &lt;= n; ++i) {        for (int j = 0; j &lt;= m; ++j) {            for (int x = 0; x &lt;= k; ++x) {                f[i][j][x] = f[i - 1][j][x];                if (v[i] &lt;= j &amp;&amp; t[i] &lt;= x)                    f[i][j][x] = max(f[i][j][x], f[i - 1][j - v[i]][x - t[i]] + w[i]);            }        }    }    printf(\"%d\\n\", f[n][m][k]);    return 0;}\n压缩#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[107][107], t[107], v[107], w[107];int main() {    int n = rd(), m = rd(), k = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd(); t[i] = rd();    }    for (int i = 1; i &lt;= n; ++i)        for (int j = m; j &gt;= v[i]; --j)            for (int x = k; x &gt;= t[i]; --x)                    f[j][x] = max(f[j][x], f[j - v[i]][x - t[i]] + w[i]);    printf(\"%d\\n\", f[m][k]);    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"区间DP && 树形DP","url":"/2022/01/26/DP2/","content":"But the well is not easy to find.\n\n区间DP\n枚举区间长度\n枚举区间起点\n枚举分割点\n\n石子合并#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[507][507], a[507], s[507];int main() {    int n = rd();    for (int i = 1; i &lt;= n; ++i) {        a[i] = rd(); s[i] = s[i - 1] + a[i];    }    memset(f, 127, sizeof(f));    for (int i = 1; i &lt;= n; ++i) f[i][i] = 0;    for (int i = 1; i &lt; n; ++i) {        for (int j = 1; j &lt;= n - i; ++j) {            for (int k = j; k &lt; j + i; ++k) {                f[j][j + i] = min(f[j][j + i], f[j][k] + f[k + 1][j + i] + s[j + i] - s[j - 1]);            }        }    }    printf(\"%d\\n\", f[1][n]);    return 0;}\n石子合并2思路1：把环拆成线，枚举拆哪条边\n思路2：把环拆成线，再倍长这个线，用“石子合并”的思路就可以做\n这里采用思路2\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[507][507], a[507], s[507];int main() {    int n = rd();    for (int i = 1; i &lt;= n; ++i) {        a[i] = a[i + n] = rd();    }    n *= 2;    for (int i = 1; i &lt;= n; ++i) {        s[i] = s[i - 1] + a[i];    }    memset(f, 127, sizeof(f));    for (int i = 1; i &lt;= n; ++i) f[i][i] = 0;    for (int i = 1; i &lt; n; ++i) {        for (int j = 1; j &lt;= n - i; ++j) {            for (int k = j; k &lt; j + i; ++k) {                f[j][j + i] = min(f[j][j + i], f[j][k] + f[k + 1][j + i] + s[j + i] - s[j - 1]);            }        }    }    int ans = 1 &lt;&lt; 30;    for (int i = 1; i &lt;= n/2; ++i)        ans = min(ans, f[i][i + n/2 - 1]);    printf(\"%d\\n\", ans);    return 0;}\n括号序列#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int f[507][507];char s[507];int main() {    int n = rd();    scanf(\"%s\", s + 1);    memset(f, 0, sizeof(f));    for (int i = 1; i &lt; n; ++i) {        for (int j = 1; j &lt;= n - i; ++j) {            if ((s[j] == '(' &amp;&amp; s[j + i] == ')') || (s[j] == '[' &amp;&amp; s[j + i] == ']'))                f[j][j + i] = f[j + 1][j + i - 1] + 2;            for (int k = j; k &lt; j + i; ++k)                f[j][j + i] = max(f[j][j + i], f[j][k] + f[k + 1][j + i]);        }    }    printf(\"%d\\n\", f[1][n]);    return 0;}\n树型DP统计人数一家公司里有 ​ 个员工，除了公司 CEO 外，每个人都有一个直接上司。我们想知道，每个人的团队（包括他/她自己、他的直接下属和间接下属）一共有多少人\n\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}struct node {    node *nxt;    int where;} *first[100001], a[100001];int n, l, f[100001];inline void makelist(int x, int y) {    a[++l].where = y;    a[l].nxt = first[x];    first[x] = &amp;a[l];}inline void solve(int i) {    f[i] = 1;    for (node *x = first[i]; x; x = x -&gt; nxt) {        solve(x -&gt; where);        f[i] += f[x -&gt; where];    }}int main() {    n = rd();    memset(first, 0, sizeof(first));    l = 0;    for (int i = 2; i &lt;= n; ++i) {        int x;        scanf(\"%d\", &amp;x);        makelist(x, i);    }    solve(1);    for (int i = 1; i &lt;= n; ++i ){        printf(\"%d \", f[i]);    }    return 0;}\n没有上司的舞会一家公司里有  个员工，除了公司 CEO 外，每个人都有一个直接上司。今天公司要办一个舞会，为了大家玩得尽兴，如果某个员工的直接上司来了，他/她就不想来了。第  个员工来参加舞会会为大家带来 ​ 点快乐值。请求出快乐值最大是多少。\n\n\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}struct node {    node *nxt;    int where;} *first[100001], a[100001];int n, l, v[100001];ll f[100001][2];inline void makelist(int x, int y) {    a[++l].where = y;    a[l].nxt = first[x];    first[x] = &amp;a[l];}inline void solve(int i) {    f[i][1] = v[i];    for (node *x = first[i]; x; x = x -&gt; nxt) {        solve(x -&gt; where);        f[i][0] += max(f[x -&gt; where][0], f[x -&gt; where][1]);        f[i][1] += f[x -&gt; where][0];    }}int main() {    n = rd();    memset(first, 0, sizeof(first));    l = 0;    for (int i = 2; i &lt;= n; ++i) {        int x;        scanf(\"%d\", &amp;x);        makelist(x, i);    }    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd();    }    solve(1);    printf(\"%lld\\n\", max(f[1][0], f[1][1]));    return 0;}\n没有上司的舞会2一家公司里有  个员工，除了公司 CEO 外，每个人都有一个直接上司。今天公司要办一个舞会，为了大家玩得尽兴，如果某个员工的直接上司来了，他/她就不想来了。第  个员工来参加舞会会为大家带来  点快乐值。由于场地有大小限制，场地最多只能容纳  个人。请求出快乐值最大是多少。\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}struct node {    node *nxt;    int where;} *first[100001], a[100001];int n, m, l, v[501];ll f[501][501][2];inline void makelist(int x, int y) {    a[++l].where = y;    a[l].nxt = first[x];    first[x] = &amp;a[l];}inline void solve(int i) {    for (node *x = first[i]; x; x = x -&gt; nxt) {        solve(x -&gt; where);        for (int j = m; j &gt;= 0; --j)            for (int k = 0; k &lt;= j; ++k) {                f[i][j][0] = max(f[i][j][0], f[i][j - k][0] + max(f[x -&gt; where][k][0], f[x -&gt; where][k][1]));                f[i][j][1] = max(f[i][j][1], f[i][j - k][1] + f[x -&gt; where][k][0]);            }    }    for (int j = m; j; --j)        f[i][j][1] = f[i][j - 1][1] + v[i];    f[i][0][1] = 0;}int main() {    n = rd(); m = rd();    memset(first, 0, sizeof(first));    l = 0;    for (int i = 2; i &lt;= n; ++i) {        int x;        scanf(\"%d\", &amp;x);        makelist(x, i);    }    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd();    }    solve(1);    printf(\"%lld\\n\", max(f[1][m][0], f[1][m][1]));    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"差分约束","url":"/2022/03/29/Difference-Cons/","content":"用最短路解决数学问题\n\n差分约束标准形式一组数列有  个元素。对这  个元素有  条约束，约束形如下，求  号元素与  号元素差值的最大值：\n\na[i] - a[j] \\le b[k]转换为求最短路问题。\n如：\n一组不等式：\n\\begin{array}{}\na[1] - a[0] \\le 9 \\\\\na[1] - a[2] \\le 2 \\\\\na[2] - a[3] \\le 2 \\\\\na[2] - a[0] \\le 6 \\\\\na[3] - a[0] \\le 3\n\\end{array}可以转换为如下图：\n\n解的情况有负环 - 无解\n不存在最短路 - 无穷多解\n变形\n若要求两个元素差值的最大值，将形式转换为：\n\n\na[i] - a[j] \\ge b[k]\n若约束为  ，可将约束改为  并且 \n\n若约束为  ，且为整数域，可将约束改为  \n\n\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"Dijkstra based on priority queue","url":"/2022/03/08/Dijkstra%20based%20on%20priority%20queue/","content":"又来跑图了！\n\n链式前向星~(-1) = 0 \n#include &lt;bits/stdc++.h&gt;#define N 100007#define M 10000007using namespace std;struct node{\tint v, w, nxt;}e[M];int tot, hd[N];inline void add(int u, int v, int w) {\t++tot;\te[tot].v = v; e[tot].w = w;\te[tot].nxt = hd[u];\thd[u] = tot;}int main(){\tint m, n;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1; i &lt;= m; ++i){\t\tint u, v, w;\t\tcin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\t\tadd(u, v, w);\t}\treturn 0;}\n最短路径问题Dijkstra\n按最短路径的长度递增的次序，依次求得源点到其余各点的最短路径。\nint tot, hd[N];struct node {    int v, w, nxt;}e[M];void add(int u, int v, int w) {\t++tot;    e[tot].v = v; e[tot].w = w;    e[tot].nxt = hd[u];    hd[u] = tot;}int main(){    int n = rd(), m = rd();    for (int i = 1; i &lt;= m; ++i) {    \tint u = rd(), v = rd(), w= rd();        add(u, v, w); add(v, u, w);    }        return 0;}\n邻接矩阵实现int a[N][N], dis[N], vis[N];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= m; ++i) {    \tint u = rd(), v = rd(), w= rd();        a[u][v] = min(a[u][v], w);        a[v][u] = min(a[v][u], w);    }    for (int i = 1; i &lt;= n; ++i) {        dis[i] = 100000;    }    dis[1] = 0;    int pos= 1;    for (int i = 1; i &lt;= n; ++i) {        int mn = 100000; vis[pos] = 1;        for (int j = 1; j &lt;= n; ++j) {            if (a[pos][j] != 100000) dis[j] = min(dis[j], a[pos][j] + dis[pos]);            if (!vis[j] &amp;&amp; dis[j] &lt; mn){                mn = dis[j]; pos = j;            }        }        if (mn == 100000) break;    }    cout &lt;&lt; dis[n];    return 0;}\n优先队列维护dis（堆优化洛谷 \nstruct edge{\tint v, w, nxt;}e[M];int tot, hd[N];inline void add(int u, int v, int w) {\t++tot;\te[tot].v = v; e[tot].w = w;\te[tot].nxt = hd[u];\thd[u] = tot;}struct node{    int id, dis;    bool operator &lt; (const node &amp;a) const {return a.dis &lt; dis;}};int a[N][N], dis[N], vis[N];void dij() {    priority_queue&lt;node&gt; q;    q.push(node{start, 0});    for (int i = 1;i &lt;= n; ++i) dis[i] = INF;    dis[start] = 0;\twhile (!q.empty()) {        node a = q.top(); q.pop();        int nw = a.id;        if (vis[nw]) continue;        vis[nw] = 1;        for (int i = hd[nw]; i; i = e[i].nxt) {            int j = e[i].v;            if (dis[nw] + e[i].w &lt; dis[j]) {                dis[j] = dis[nw] + e[i].w;                q.push(node{j, dis[j]});            }        }    }}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"Dormitry","url":"/2021/01/24/Dormitry/","content":"来看看我的大学寝室吧~\n\n都是漂亮的小姐姐\n林晨曦（班里唯二女孩纸 相依为命\n叶涵    （yea~\n杨艺茜（又名唐怀瑟\n亲爱的小羽羽（文艺少女\n\n\n\n来一段 2020 年度总结的大视频吧（有声音，小心入内……）\n","categories":["HDU's Life"],"tags":["Daily"]},{"title":"Greedy","url":"/2022/02/28/Greedy/","content":"Don’t be greedy !\n\n贪心贪心，就是 局部最优解 和 全局最优解 保持一致。故只需要考虑当前收益，而不用考虑后续情况。\n贪心需要，一个固定的方向。\n最小覆盖 / 最大独立集最小覆盖：\n给定   个区间，以   形式给出。问最少放多少个点，能覆盖所有区间。\n对于答案点集里的点：若按从小到大排好序，最小的点一定要覆盖右端点最小的区间，不然这个区间就不能被覆盖了。且对于右端点最小的区间，将点放在右端点处是最不浪费的（即可能覆盖的区间数最多。由此可得，贪心的思路为：将所有区间按右端点的大小排好序，然后选择在右端点最小的区间的右端点上放一个点，记录当前最大的点的位置，若某个区间的左端点比这个点的位置要大，则该区间需要重新选一个点进行覆盖。\n最大独立集：\n极大化区间数量，要求：区间之间无交。\npair&lt;int, int&gt; a[N]; // pair 默认第一维为第一关键字，第二维为第二关键字，所以第一维存 r，第二维存 l，方便后面的排序。int main() {    int n = rd();    for (int i = 1; i &lt;= n; ++i) {        int l = rd(), r = rd();        a[i].first = r; a[i].second = l;    }    sort(a + 1, a + 1 + n);    int mxpos = 0, ans = 0;    for (int i = 1; i &lt;= n; ++i) {        if (mxpos &lt; a[i].second) {            ++ans;            mxpos = a[i].first;        }    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}\nhttps://www.luogu.com.cn/problem/P1803\n#include&lt;bits/stdc++.h&gt;using namespace std;#define N 1000007typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}pair&lt;int, int&gt; a[N]; // pair 默认第一维为第一关键字，第二维为第二关键字，所以第一维存 r，第二维存 l，方便后面的排序。int main() {    int n = rd();    for (int i = 1; i &lt;= n; ++i) {        int l = rd(), r = rd();        a[i].first = r - 1; a[i].second = l;    }    sort(a + 1, a + 1 + n);    int mxpos = -1, ans = 0;    for (int i = 1; i &lt;= n; ++i) {        if (mxpos &lt; a[i].second) {            ++ans;            mxpos = a[i].first;        }    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}\nhttp://www.51nod.com/Challenge/Problem.html#problemId=3086\n#include&lt;bits/stdc++.h&gt;using namespace std;#define N 2000007typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}pair&lt;int, int&gt; a[N]; // pair 默认第一维为第一关键字，第二维为第二关键字，所以第一维存 r，第二维存 l，方便后面的排序。int main() {    int n = rd();    for (int i = 1; i &lt;= n; ++i) {        int l = rd(), r = rd();        if (l &gt; r) swap(l, r);        a[i].first = r - 1; a[i].second = l;    }    sort(a + 1, a + 1 + n);    int mxpos = 0, ans = 0;    for (int i = 1; i &lt;= n; ++i) {        if (mxpos &lt; a[i].second) {            ++ans;            mxpos = a[i].first;        }    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}\n最小覆盖2最小化区间数量，使得：区间的并能覆盖整个区间。\n首先 l = 1 的所有区间里，必须选一个，选哪个呢？要选 r 最大的。然后要尽可能不选，用 mxpos 记录当前可以不选的区间里 r 的最大值，r 记录当前已选区间 r 的最大值。\nint mxpos = 0, r = 0, ans = 0;for (int i = 1; i &lt;= n; ++i) {    if (a[i].second &gt; r + 1) {        r = mxpos;        ++ans;    }    mxpos = max(mxpos, a[i].first);}\nhttp://poj.org/problem?id=2376\n#include&lt;bits/stdc++.h&gt;using namespace std;#define N 2000007typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}pair&lt;int, int&gt; a[N]; // pair 默认第一维为第一关键字，第二维为第二关键字，所以第一维存 r，第二维存 l，方便后面的排序。int main() {    int n = rd(), t = rd();    for (int i = 1; i &lt;= n; ++i) {        int l = rd(), r = rd();        if (l &gt; r) swap(l, r);        a[i].first = l; a[i].second = r;    }    sort(a + 1, a + 1 + n);    int mxpos = 0, r = 0, ans = 0;    for (int i = 1; i &lt;= n; ++i) {        if (a[i].first &gt; r + 1) {puts(\"-1\"); return 0;}        r = max(r, a[i].second);    }    if (r != t) {puts(\"-1\"); return 0;}    r = 0;    for (int i = 1; i &lt;= n; ++i) {        if (a[i].first &gt; r + 1) {            r = mxpos;            ++ans;        }        mxpos = max(mxpos, a[i].second);    }    ans += (r != t);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"A scene to remember","url":"/2021/08/03/Imitation/","content":"勇于尝试\n\nGood afternoon, ladies and gentlemen. Today I would like to begin with a story.\nThere was once a physical therapist who traveled all the way from America to Africa to do a census about mountain gorillas. These gorillas are a main attraction to tourists from all over the world; this put them severely under threat of poaching and being put into the zoo. She went there out of curiosity, but what she saw strengthened her determination to devote her whole life to fighting for those beautiful creatures. She witnessed a scene, a scene taking us to a place we never imaged we’ve ever been, where in the very depth of the African rainforest, surrounded by trees, flowers and butterflies, the mother gorillas cuddled their babies. Yes, that’s a memorable scene in one of my favorite movies, called Gorillas in the Mist, based on a true story of Mrs. Dian Fossey, who spent most of her lifetime in Rwanda to protect the ecoenvironment there until the very end of her life. To me, the movie not only presents an unforgettable scene but also acts as a timeless reminder that we should not develop the tourist industry at the cost of our ecoenvironment.\nToday, we live in a world of prosperity but still threatened by so many new problems. On the one hand, tourism, as one of the most promising industries in the 21st century, provides people with the great opportunity to see everything there is to see and to go any place there is to go. It has become a lifestyle for some people, and has turned out to be the driving force in GDP growth. It has the magic to turn a backward town into a wonderland of prosperity. But on the other hand, many problems can occur—natural scenes aren’t natural anymore. Deforestation to heat lodges is devastating Nepal. \n","categories":["HDU's Learning"],"tags":["English speech"]},{"title":"Life shines on life","url":"/2021/08/02/Life-shines-on-life/","content":"“Yeah we all shine on, like the moon, and the stars, and the sun.”   ——John Lennon\n\n\n\nself-introHello, sir or madam. I’m Qi Yingying, a freshman learning computer science in Hangzhou Dianzi University. In school, I’m a down-to-earth student. I believe in the words that “no pains, no gains”. Speaking of my hobbies, I’m a music buff and also love sporting. Running along Qianjiang River, immersing my ears into sweet songs and filling my eyes with the marvelous light of sun shine really keep me spellbound. \nNow, let’s move into the topic speech.\nTopic speechIn 2017, I went to an orphanage and spent a whole week with children there. In seven days I built a strong band with a girl who was abandoned when she was born. At the first day, she seldom spoke even a word, and refused any of our help but always smiled. To me she was adorable but fragile. One of the adults said she was once adopted but was abandoned again due to her rejection to everything. I didn’t know how to help her. I chose to be her side silently. Just let her know I was there.  And then I began to share with her many things in my life. Day by day, she was not that kind of autistic. And she even asked me whether she could sleep with me. On August 7th, 2021, I couldn’t be more excited when she said she was staying at home.\nYeah we all shall shine on and we all can shine on, like the moon, and the stars, and the sun. Shining on life isn’t a tough task. Just by helping people in need and being grateful for the people who once helped us. Smile to a passer-by, pick up a rubbish on the road, give a hug to a crying man,  and say thank you. If only we are willing, we can shine our lives on lives. Thank you!\n\nWe can shine in many ways. Nhat Hanh said, “Awareness is like the sun. When it shines on things, they are transformed.” Michael Jackson appeals people to love, heal and educate children. Let’s all do our duties on shining on lives.\n\nOver 85 years ago, The Red Army fears not the trials of the Long March, holding light ten thousand crags and torrents. The Five Ridges wind like gentle ripples, and the majestic Wumeng roll by. Oprah Winfrey said, “let your light shine. Shine within you so that it can shine on someone else.” yes, they still shines on our lives with their persistence and bravery. \nIn 2020, during the pandemic, retrogrades put on gloves and protective suits, devoted themselves into the fight against the virus. Their selflessness and love warmed our hearts in that cold winter.\n\n（写这些不想写的东西 已经要写吐了……\n果然 对于喜欢的东西 过犹不及……\n当初一腔热血，现在头都要没了……\n冲！！\n","categories":["HDU's Learning"],"tags":["English speech"]},{"title":"单调队列","url":"/2022/02/04/Monotonic%20deque/","content":"Keep going ~\n\n单调队列今天和Co老师学了单调队列\n定义单调队列，就是队列内元素单调的队列。\n易错点\n每次访问队列内元素时，都要保证队列非空，否则会 RE 。\n\n做题步骤\n去除队头不合法的元素\n用当前元素，更新队列（从队尾\n求当前位置的解\n\n\n注：不一定按照 1 2 3 的顺序\n\n例题一洛谷 \n给一个数列，和区间长度  ，要求输出，所有长度为  的子串中的最小值和最大值。\n\n思路：\n枚举窗口的右端点（从数列第一个元素开始向后枚举），队头不合法即队头元素不在当前的窗口范围里；求最大值时，更新队列，就是把队尾中小于等于当前元素的都 pop 掉，求最小值时，时大于等于；当前位置的解，即为队头元素。\n#include&lt;deque&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;#define N 1000007typedef long long ll;inline ll rd() {  ll x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}deque&lt;int&gt; Q;ll a[N];int fi[N], fa[N], n, k;inline void work() {    n = rd(), k = rd();    for (int i = 1; i &lt;= n; ++i) a[i] = rd();    Q.clear();    for (int i = 1; i &lt;= n; ++i) {        while (!Q.empty() &amp;&amp; Q.front() &lt; i - k + 1) Q.pop_front();        while (!Q.empty() &amp;&amp; a[Q.back()] &gt;= a[i]) Q.pop_back();        Q.push_back(i);        if (!Q.empty()) fi[i] = Q.front();    }    Q.clear();    for (int i = 1; i &lt;= n; ++i) {        while (!Q.empty() &amp;&amp; Q.front() &lt; i - k + 1) Q.pop_front();        while (!Q.empty() &amp;&amp; a[Q.back()] &lt;= a[i]) Q.pop_back();        Q.push_back(i);        if (!Q.empty()) fa[i] = Q.front();    }    for (int i = k; i &lt;= n; ++i) printf(\"%lld \", a[fi[i]]);    puts(\"\");    for (int i = k; i &lt;= n; ++i) printf(\"%lld \", a[fa[i]]);}int main() {    work();    return 0;}\n二HDU \n给一组数列，还有  。求最长子串满足：  \n思路：\n枚举区间右端点。两个队列分别用于计算区间最大值和最小值。做题步骤 2 即可进行；固定右端点的情况下，像右移动左端点，会使得  变小；我们对  的值进行讨论：\n\n  符合要求\n 不论怎么操作都得不到合法的解\n 向右移动左端点，直到  \n\n判断  是否大于  ，如果大于  就计算一次结果即区间长度，和原来的值取较大的；否则不计算，保留之前的答案。\n下一个问题就是左端点：每次有元素  弹出队列时， 。 \n #include&lt;deque&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;#define N 1000007typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}deque&lt;int&gt; mn, mx;int a[N];int n, L, R;inline void work() {    for (int i = 1; i &lt;= n; ++i) a[i] = rd();    mn.clear(); mx.clear();    int l = 1, ans = 0;    for (int r = 1; r &lt;= n; ++r) {        while (!mn.empty() &amp;&amp; a[mn.back()] &gt; a[r]) mn.pop_back();        while (!mx.empty() &amp;&amp; a[mx.back()] &lt; a[r]) mx.pop_back();        mx.push_back(r); mn.push_back(r);        while (a[mx.front()] - a[mn.front()] &gt; R) {            if (mx.front() &lt; mn.front()) {                l = mx.front() + 1; mx.pop_front();            }else if (mx.front() &gt; mn.front()) {                l = mn.front() + 1; mn.pop_front();            }else {                l = mn.front() + 1; mn.pop_front(); mx.pop_front();            }        }        if (a[mx.front()] - a[mn.front()] &gt;= L) ans = max(ans, r - l + 1);    }    printf(\"%d\\n\", ans);}int main() {    while (cin &gt;&gt; n &gt;&gt; L &gt;&gt; R) work();    return 0;}\n三HDU \n给一个数  ，问最少通过几次变换可以把  变成  。\n变换有以下两种：\n\n \nif  （如果  是  的倍数） ，​ 。\n\n变换 2 是 O(1) 的，但变换 1 是 O(t) 的。所以我们需要对变换 1 进行优化。\n我们先写出动态转移的方程：\n\n \n \n\n可以看出变换 1 的本质就是找出一个区间里的最小值，我们用单调队列进行优化。\n注意：一定要在从队尾更新队列之前，保证当前位置的结果已经正确了。\n#include&lt;deque&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;#define N 1000007typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}deque&lt;int&gt; q;int f[N];inline void work() {    int x = rd(), k = rd(), t = rd();    q.clear();    f[1] = 0; q.push_back(1);    for (int i = 2; i &lt;= x; ++i) {        f[i] = 1000007;        if (i % k == 0) f[i] = min(f[i/k] + 1, f[i]);        while (!q.empty() &amp;&amp; q.front() &lt; i - t) q.pop_front();        if (!q.empty()) f[i] = min(f[q.front()] + 1, f[i]);        while (!q.empty() &amp;&amp; f[q.back()] &gt;= f[i]) q.pop_back();        q.push_back(i);    }    printf(\"%d\\n\", f[x]);}int main() {    int t = rd();    while (t--) work();    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"单调栈","url":"/2022/02/02/Monotonic%20stack/","content":"Life is a journey to experience to learn and to enjoy. \n\n单调栈今天和Co老师学习了单调栈\n定义单调栈，就是栈内元素单调的栈。\n易错点\n每次访问栈内元素时，都要保证栈非空，否则会 ​ 。\n栈的清空。\n\n应用询问Co老师，什么时候要用单调栈，Co老师说，要多做题，自己就有感觉了。但Co老师还是给了我几条：\n\n“最近”：因为栈是先入后出，所以往往栈顶的元素会比栈里的其他元素离当前元素近。\n“单调”：就是那种，遇到一个更优解时，栈内较劣的元素就可以不断弹掉，且能保证剩下的元素还能保证“单调性”。\n\n其他的我好像还没悟出来，等我多做做题了，再回来补充吧。\n例题一给一组类似于柱形图的每一个柱子的高度，宽度默认均为 1 。\n求最大的矩形面积。\n分析可得：S[i] = a[i] * (r[i] - l[i] + 1) （ l[i] 是以 a[i] 为高的，可延伸到最远的左端点，r[i] 同理）\n这应该是一个单调增栈。\n\n#include&lt;stack&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;#define N 100007typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}stack&lt;int&gt; S;int a[N], l[N], r[N];void clearStack(){    while(!S.empty()) S.pop();}inline void work(int n) {    for (int i = 1; i &lt;= n; ++i) {        a[i] = rd();    }    clearStack();    S.push(1); l[1] = 1;    for (int i = 2; i &lt;= n; ++i) {        if (a[i] &lt;= a[S.top()]) {            while (!S.empty() &amp;&amp; a[i] &lt;= a[S.top()]) {                l[i] = l[S.top()]; S.pop();            }        } else {            l[i] = i;        }        S.push(i);    }    clearStack();    S.push(n); r[n] = n;    for (int i = n - 1; i &gt;= 1; --i) {        if (a[i] &lt;= a[S.top()]) {            while (!S.empty() &amp;&amp; a[i] &lt;= a[S.top()]) {                r[i] = r[S.top()]; S.pop();            }        } else {            r[i] = i;        }        S.push(i);    }    ll ans = 0;    for (int i = 1; i &lt;= n; ++i) {       ans = max(ans, 1ll * a[i] * (r[i] - l[i] + 1));    }    printf(\"%lld\\n\", ans);}int main() {    int n = rd();    while (n) {work(n); n = rd();}    return 0;}\n来做优化吧就是说算 l[n] 要一次循环，算 r[n] 还要一次循环，浪费呀~\n可以注意到 ：\n若  把  弹出来，就说明  ，那所以  的  ，又因为  ，所以  肯定也知道了啊，所以其实对于被弹出来的元素其最大面积已经知道了。\n优化一在最后加一个 a[n++] = 0 \n#include&lt;stack&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;#define N 100007typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}stack&lt;int&gt; S;int a[N], l[N];void clearStack(){    while(!S.empty()) S.pop();}inline void work(int n) {    for (int i = 1; i &lt;= n; ++i) {        a[i] = rd(); l[i] = i;    }    a[++n] = 0; l[n] = n;    ll ans = 0;    clearStack();    S.push(1); l[1] = 1;    for (int i = 2; i &lt;= n; ++i) {        while (!S.empty() &amp;&amp; a[i] &lt;= a[S.top()]) {            ans = max(ans, 1ll * a[S.top()] * (i - l[S.top()]));            l[i] = l[S.top()]; S.pop();        }        S.push(i);    }    printf(\"%lld\\n\", ans);}int main() {    int n = rd();    while (n) {work(n); n = rd();}    return 0;}\n优化二#include&lt;stack&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;#define N 100007typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}stack&lt;int&gt; S;int a[N], l[N];void clearStack(){    while(!S.empty()) S.pop();}inline void work(int n) {    for (int i = 1; i &lt;= n; ++i) {        a[i] = rd(); l[i] = i;    }    ll ans = 0;    clearStack();    S.push(1); l[1] = 1;    for (int i = 2; i &lt;= n; ++i) {        while (!S.empty() &amp;&amp; a[i] &lt;= a[S.top()]) {            ans = max(ans, 1ll * a[S.top()] * (i - l[S.top()]));            l[i] = l[S.top()]; S.pop();        }        S.push(i);    }    while (!S.empty()) {        ans = max(ans, 1ll * a[S.top()] * (n - l[S.top()] + 1));        S.pop();    }    printf(\"%lld\\n\", ans);}int main() {    int n = rd();    while (n) {work(n); n = rd();}    return 0;}\n二洛谷 \n给出项数为  的整数数列  。\n定义函数  代表数列中第  个元素之后第一个大于  的元素的下标，即  。若不存在，则  。\n试求出  。\n#include&lt;stack&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;#define N 3000007typedef long long llinline ll rd() {  ll x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}stack&lt;int&gt; S;ll a[N];int f[N];void clearStack(){    while(!S.empty()) S.pop();}inline void work(int n) {    for (int i = 1; i &lt;= n; ++i) {        a[i] = rd();    }    clearStack(); S.push(n);    for (int i = n - 1; i &gt;= 1; --i) {        while (!S.empty() &amp;&amp; a[i] &gt;= a[S.top()]) S.pop();        if (!S.empty()) f[i] = S.top();        S.push(i);    }    for (int i = 1; i &lt;= n; ++i) {        printf(\"%d \", f[i]);    }}int main() {    work(rd());    return 0;}\n三洛谷 \n#include&lt;stack&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;#define N 250007typedef long long ll;inline ll rd() {  ll x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}stack&lt;ll&gt; S;ll a[N];void clearStack(){    while(!S.empty()) S.pop();}inline void work(ll n) {    for (ll i = 1; i &lt;= n; ++i) {        a[i] = rd(); a[i] = rd();    }    ll ans = n;    clearStack();    S.push(1);    for (ll i = 2; i &lt;= n; ++i) {        while (!S.empty() &amp;&amp; a[i] &lt; a[S.top()]) {            S.pop();        }        if (!S.empty() &amp;&amp; a[S.top()] == a[i]) {ans--; S.pop();}        S.push(i);    }    printf(\"%lld\\n\", ans);}int main() {    work(rd());    return 0;}\n四洛谷 \n 个人正在排队进入一个音乐会。人们等得很无聊，于是他们开始转来转去，想在队伍里寻找自己的熟人。队列中任意两个人  和 ，如果他们是相邻或他们之间没有人比  或  高，那么他们是可以互相看得见的。写一个程序计算出有多少对人可以互相看见\n首先，如果  能看到  ， 一定能看到  。为了避免重复计算，且好写代码（em……）。我们只需要计算每一个人往队伍后面看能看到多少个人，再将答案相加即可。\n对于一个位置  ，所有他可能看见的人满足以下条件：\n\n这些人是按照队伍里的位置，组成的序列是非降的，即如果  和  都可能被  看到，且在队伍中  排在  的前面，那 ​。\n由此可知，单调栈里应该是非降序，即下面的元素要大于等于上面的元素。\n\n如果前一个人已经比  高了，那后面的人，就无法被  看到了。\n\n\n再考虑整个队伍，后面的人弹掉的那些元素，会不会影响前面的人的正确答案。假设两个人在队伍中， 在  的前面， 能看到的是单调栈里面比自己矮的和第一个比自己高的，比  矮的弹掉不会影响  的答案，因为  一定看不到他们。跟  等高的又需要计入  的答案，且还应当保留在单调栈中。故我们在单调栈中存放二元组，记录高度，和该高度的个数，最后塞入单调栈中。\n对于每一次 while 循环，其退出有两种条件：\n\n栈空了\n栈顶元素比当前元素大\n\n如果是 1. 那答案就是循环里算出的答案，如果是 2. 答案则需 +1 因为第一个比当前元素高的，是可以看到的。\n#include&lt;stack&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;#define N 500007typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}stack&lt;pair&lt;int, int&gt; &gt; S;int a[N];ll ans = 0;void clearStack(){    while(!S.empty()) S.pop();}inline void work(int n) {    for (int i = 1; i &lt;= n; ++i) {        a[i] = rd();    }    clearStack();    S.push(make_pair(n, 1));    for (int i = n - 1; i &gt;= 1; --i) {        int cnt = 1;        while (!S.empty() &amp;&amp; a[i] &gt;= a[S.top().first]) {            ans += S.top().second;            if (a[i] == a[S.top().first]) cnt += S.top().second;            S.pop();        }        ans += (!S.empty());        S.push(make_pair(i, cnt));    }    printf(\"%lld\\n\", ans);}int main() {    work(rd());    return 0;}\n五洛谷 \n给一个 ​ 的二维矩阵，求最大矩形面积。\n枚举答案矩形的底边，就可以将题目转换为 题目一 \n#include&lt;stack&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;#define N 1007typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}stack&lt;int&gt; S;int f[N][N], l[N], n, m;char a[N][N];void clearStack(){    while(!S.empty()) S.pop();}inline ll solve(int x) {    ll ans = 0;    clearStack();    S.push(1);    for (int i = 1; i &lt;= m; ++i) l[i] = i;    for (int i = 2; i &lt;= m; ++i) {        while (!S.empty() &amp;&amp; f[x][i] &lt;= f[x][S.top()]) {            ans = max(ans, 1ll * f[x][S.top()] * (i - l[S.top()]));            l[i] = l[S.top()]; S.pop();        }        S.push(i);    }    while (!S.empty()) {        ans = max(ans, 1ll * f[x][S.top()] * (m - l[S.top()] + 1));        S.pop();    }    return ans;}inline void work() {    n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i)        for (int j = 1; j &lt;= m; ++j) {            for (a[i][j] = getchar(); a[i][j] != 'F' &amp;&amp; a[i][j] != 'R'; a[i][j] = getchar());            f[i][j] = (a[i][j] == 'F') ? f[i - 1][j] + 1 : 0;        }    ll ans = 0;    for (int i = 1; i &lt;= n; ++i) {ans = max(ans, solve(i));}    printf(\"%lld\\n\", 3 * ans);}int main() {    work();    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"OpenCV (创建新项目)","url":"/2021/07/26/OPENCV1-0/","content":"开始学习啦~~\n\nStep 1Go to https://github.com/opencv/opencv and download the Latest Release.\nStep 2Add bin folder to the Environment Variables path.（编辑系统环境变量）\nD:\\opencv\\build\\x64\\vc15\\bin\nStep 3Create a New Visual Studio project C++ console.\nSet the platform target to x64.\nStep 4Add Directories by going to Project-Properties-Configuration Properties. （项目 - 属性 -  配置属性）\nVC++目录 - 包含目录 &amp;&amp; 库目录\nAdd build directories D:\\opencv\\build\\include \nAdd Library directories D:\\opencv\\build\\x64\\vc15\\lib \n链接器 - 输入\nAdd linker input opencv_world453d.lib \n不同版本不一样，数字后面有d的与debug有关，没有d的与release有关。\n具体操作可参照 https://www.bilibili.com/video/BV11A411T7rL?t=2\n视频相关资源下载 https://www.murtazahassan.com/courses/opencv-cpp-course/\n添加自己写的头文件项目 -&gt; 属性 -&gt; C/C++/常规/附加包含目录 -&gt; 把.h那一级文件放进去即可\n若属性中找不到 C/C++，应先写一段简单代码，编译运行后属性中就会出现该栏\n无法打开源文件检查自己的管理器，是否为 x64\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (提取直线、轮廓和区域)","url":"/2021/08/09/OPENCV1-10/","content":"提取图元 ~ ~\n\n轮廓Canny算子// Apply Canny algorithmcv::Mat contours;cv::Canny(image,contours,125,350); // 灰度图像，输出轮廓，低阈值，高阈值\n基于 Sobel 算子\n直线霍夫变换HoughLines()\n检测Mat contours;Canny(image, contours, 125, 350);// 用霍夫变换检测直线vector&lt;Vec2f&gt; lines;HoughLines(test, lines,\t\t   1, PI/180,  // 步长\t\t   60); // 最小投票数\n半径步长为 1，表示函数将搜索所有可能的半径\n角度步长为 PI/180，表示函数将搜索所有可能的角度\n注：算法检测的是直线，而不是线段。故，即使点的坐标超出了图像范围，这个函数也能正常运行，因此没必要检查交叉点是否在图像内部。\n画直线vector&lt;Vec2f&gt;::const_iterator it = lines.begin();while(it != lines.end())&#123;    float rho = (*it)[0]; // 距离    float theta = (*it)[1]; // 角度        if(theta &lt; PI/4. || theta &gt; 3.*PI/4.)&#123; // 垂直线（大致）        // 直线与第一行交叉点        Point pt1(rho/cos(theta), 0);        // 直线与最后一行交叉点        Point pt12((rho - result.rows*sin(theta))/cos(theta), result.rows);        // 画白色的线        line(image, pt1, pt2, Scalar(255), 1);    &#125;else&#123; // 水平线（大致）        // 直线与第一列交叉点        Point pt1(0， rho/sin(theta));        // 直线与最后一列交叉点        Point pt12(result.cols, (rho - result.cols*cos(theta))/sin(theta));        // 画白色的线        line(image, pt1, pt2, Scalar(255), 1);    &#125;    ++it;&#125;\n不足之处有些像素只是碰巧排成了直线，霍夫变换可能产生错误\n也可能因为多条参数相近的直线穿过了同一个像素对齐区域，而导致重复检测\n概率霍夫变换HoughLinesP() \n用概率霍夫变换创建 LineFinder 类  #if !defined LINEF#define LINEF#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#define PI 3.1415926class LineFinder &#123;  private:\t  // original image\t  cv::Mat img;\t  // vector containing the end points \t  // of the detected lines\t  std::vector&lt;cv::Vec4i&gt; lines;\t  // accumulator resolution parameters\t  double deltaRho;\t  double deltaTheta;\t  // minimum number of votes that a line \t  // must receive before being considered\t  int minVote;\t  // min length for a line\t  double minLength;\t  // max allowed gap along the line\t  double maxGap;  public:\t  // Default accumulator resolution is 1 pixel by 1 degree\t  // no gap, no mimimum length\t  LineFinder() : deltaRho(1), deltaTheta(PI/180), minVote(10), minLength(0.), maxGap(0.) &#123;&#125;\t  // Set the resolution of the accumulator\t  void setAccResolution(double dRho, double dTheta) &#123;\t\t  deltaRho= dRho;\t\t  deltaTheta= dTheta;\t  &#125;\t  // Set the minimum number of votes\t  void setMinVote(int minv) &#123;\t\t  minVote= minv;\t  &#125;\t  // Set line length and gap\t  void setLineLengthAndGap(double length, double gap) &#123;\t\t  minLength= length;\t\t  maxGap= gap;\t  &#125;\t  // Apply probabilistic Hough Transform\t  std::vector&lt;cv::Vec4i&gt; findLines(cv::Mat&amp; binary) &#123;\t\t  lines.clear();\t\t  cv::HoughLinesP(binary,lines,deltaRho,deltaTheta,minVote, minLength, maxGap);\t\t  return lines;\t  &#125;\t  // Draw the detected lines on an image\t  void drawDetectedLines(cv::Mat &amp;image, cv::Scalar color=cv::Scalar(255,255,255)) &#123;\t\t\t  // Draw the lines\t\t  std::vector&lt;cv::Vec4i&gt;::const_iterator it2= lines.begin();\t\t\t  while (it2!=lines.end()) &#123;\t\t\t\t\t  cv::Point pt1((*it2)[0],(*it2)[1]);        \t\t\t  cv::Point pt2((*it2)[2],(*it2)[3]);\t\t\t  cv::line( image, pt1, pt2, color);\t\t\t\t\t  ++it2;\t\t\t  &#125;\t  &#125;\t  // Eliminates lines that do not have an orientation equals to\t  // the ones specified in the input matrix of orientations\t  // At least the given percentage of pixels on the line must \t  // be within plus or minus delta of the corresponding orientation\t  std::vector&lt;cv::Vec4i&gt; removeLinesOfInconsistentOrientations(\t\t  const cv::Mat &amp;orientations, double percentage, double delta) &#123;\t\t\t  std::vector&lt;cv::Vec4i&gt;::iterator it= lines.begin();\t\t\t\t  // check all lines\t\t\t  while (it!=lines.end()) &#123;\t\t\t\t  // end points\t\t\t\t  int x1= (*it)[0];\t\t\t\t  int y1= (*it)[1];\t\t\t\t  int x2= (*it)[2];\t\t\t\t  int y2= (*it)[3];\t\t   \t\t\t\t  // line orientation + 90o to get the parallel line\t\t\t\t  double ori1= atan2(static_cast&lt;double&gt;(y1-y2),static_cast&lt;double&gt;(x1-x2))+PI/2;\t\t\t\t  if (ori1&gt;PI) ori1= ori1-2*PI;\t\t\t\t  double ori2= atan2(static_cast&lt;double&gt;(y2-y1),static_cast&lt;double&gt;(x2-x1))+PI/2;\t\t\t\t  if (ori2&gt;PI) ori2= ori2-2*PI;\t\t\t\t\t  // for all points on the line\t\t\t\t  cv::LineIterator lit(orientations,cv::Point(x1,y1),cv::Point(x2,y2));\t\t\t\t  int i,count=0;\t\t\t\t  for(i = 0, count=0; i &lt; lit.count; i++, ++lit) &#123; \t\t\t\t\t\t\t  float ori= *(reinterpret_cast&lt;float *&gt;(*lit));\t\t\t\t\t  // is line orientation similar to gradient orientation ?\t\t\t\t\t  if (std::min(fabs(ori-ori1),fabs(ori-ori2))&lt;delta)\t\t\t\t\t\t  count++;\t\t\t\t\t\t  &#125;\t\t\t\t  double consistency= count/static_cast&lt;double&gt;(i);\t\t\t\t  // set to zero lines of inconsistent orientation\t\t\t\t  if (consistency &lt; percentage) &#123; \t\t\t\t\t  (*it)[0]=(*it)[1]=(*it)[2]=(*it)[3]=0;\t\t\t\t  &#125;\t\t\t\t  ++it;\t\t\t  &#125;\t\t\t  return lines;\t  &#125;&#125;;#endif\n点集的直线拟合首先要识别出图像中靠近直线的点。使用 HoughLinesP 检测到的直线。\n将 HoughlinesP 检测到的直线存放在 vector&lt;Vec4i&gt; lines 中，为了提取出靠近这条直线的点集，在黑色图像上画一条白色直线，并且穿过用于检测直线的 Canny 轮廓图\nint n = 0; // 选用直线0// 黑色图像Mat oneline(contours.size(), CV_8U, Scalar(0));// 白色直线line(oneline, Point(lines[n][0], lines[n][1]), Point(lines[n][2], lines[n][3]), Scalar(255), 3);// 轮廓与白色直线进行“与”运算bitwise_and(contours, oneline, oneline);\n 结果是一个包含了与指定直线相关的点的图像（为了提升显示效果，可以进行反转）\n然后把这些集合内点的坐标插入到 vector&lt;Point&gt; points 中\nvector&lt;Point&gt; points;// 迭代遍历像素，得到所有点的位置for(int y = 0; y &lt; oneline.rows; ++y)&#123;    // 行y    uchar* rowPtr = oneline.ptr&lt;uchar&gt;(y);        for(int x = 0; x &lt; oneline.cols; ++x)&#123;        // 列x                // 如果在轮廓上        if(rowPtr[x])&#123;            points.push_back(Point(x, y));        &#125;    &#125;&#125;\n得到点集后，利用这些点集你和出直线。\nVec4f line;fitLine(points, line,         DIST_L2, // 距离类型        0, // L2类型不用这个参数        0.01, 0.01); // 精度\n上述代码把直线方程式作为参数，形式式一个单位方向向量（ Vec4f  的前两个数值）和直线上一个点的坐标（ Vec4f 的后两个数值）。\n直线方程式通常用于某些属性的计算（例如需要精确参数的校准）。下面演示一下其用法\nint x0 = line[2]; // 直线上的一个点int y0 = line[3];int x1 = x0 + 100 * line[0]; // 加上长度为100的向量int y1 = y0 + 100 * line[1];// 绘制line(image, Point(x0, y0), Point(x1, y1), 0.2);\n区域提取连续区域第一步：生成二值图像（可以用直方图反向投影，也可以用运动分析）\n第二步：执行一次简单的阈值操作，然后应用形态学滤波器。\n提取连续区域 就是 提取在二值图像中由一批连通的像素构成的形状。\nvector&lt;vector&lt;Point&gt; &gt; contours;findContours(image, // 二值图像             contours, // 存储轮廓的向量             RETR_EXTERNAL, // 检索外部轮廓             CHAIN_ASPPOX_NONE); // 每个轮廓的全部像素\n画出区域\nMat result(image.size(), CV_8U, Scalar(255));drawContours(result, contours,              -1, // 画全部轮廓 （可以指定要画的轮廓的序号）             0, // 颜色：黑             2); // 宽度\n若事先知道感兴趣物体的大小，就可以将部分区域删除。\nint cmin = 50;int cmax = 1000;vector&lt;vector&lt;Point&gt; &gt; ::iterator itc = contours.begin();while(itc != contours.end())&#123;    if(itc -&gt; size() &lt; cmin || itc -&gt; size() &gt; cmax)        itc = contours.erase(itc);    else        ++itc;&#125;\n计算区域的形状描述子测试边界框、\n// testing the bounding box cv::Rect r0= cv::boundingRect(contours[0]);// draw the rectanglecv::rectangle(result,r0, 0, 2);\n测试覆盖圆\n// testing the enclosing circle float radius;cv::Point2f center;cv::minEnclosingCircle(contours[1],center,radius);// draw the criclecv::circle(result,center,static_cast&lt;int&gt;(radius), 0, 2);\n测试多边形逼近\n// testing the approximate polygonstd::vector&lt;cv::Point&gt; poly;cv::approxPolyDP(contours[2],poly,5,true);// draw the polygoncv::polylines(result, poly, true, 0, 2);\nstd::cout &lt;&lt; &quot;Polygon size: &quot; &lt;&lt; poly.size() &lt;&lt; std::endl; // 几边形\n测试凸包\n// testing the convex hullstd::vector&lt;cv::Point&gt; hull;cv::convexHull(contours[3],hull);// draw the polygoncv::polylines(result, hull, true, 0, 2);\n测试轮廓矩\n// testing the moments// iterate over all contoursitc= contours.begin();while (itc!=contours.end()) &#123;\t// compute all moments\tcv::Moments mom= cv::moments(*itc++);\t// draw mass center\tcv::circle(result,\t\t// position of mass center converted to integer\t\tcv::Point(mom.m10/mom.m00,mom.m01/mom.m00),\t\t2,cv::Scalar(0),2); // draw black dot&#125;\ncv::namedWindow(&quot;Some Shape descriptors&quot;);cv::imshow(&quot;Some Shape descriptors&quot;,result);\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (检测兴趣点)","url":"/2021/08/10/OPENCV1-11/","content":"兴趣点（关键点、特征点），目标识别、图像配准、视觉跟踪、三维重建领域热词之一\n\n检测图像中的角点角点：两条边缘线的接合点，是一种二维特征，可以被精确地检测（即使是亚像素级精度）\nHarris角点：https://blog.csdn.net/qq_41598072/article/details/83651629\nOpenCV 中检测 Harris 角点的基本函数是 cornerHarris\n基本用法// 检测Harris角点Mat cornerStrength;cornerHarris(image, // 输入图像 \t\t\t cornerStrength, // 角点强度的图像\t\t\t 3, // 邻域尺寸\t\t\t 3, // 口径尺寸\t\t\t 0.01); // Harris 参数// 对角点强度阈值化Mat harrisCorners;double threshold = 0.0001;threshold(cornerStrength, harrisCorners, threshold, 255, THRESH_BINARY_INV);\n创建类为了使用方法便于调节，和结果更好，定义一个检测 Harris 角点的类。\n#if !defined HARRISD#define HARRISD#include &lt;vector&gt;#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/features2d.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;class HarrisDetector &#123;  private:\t  // 32-bit float image of corner strength\t  cv::Mat cornerStrength;\t  // 32-bit float image of thresholded corners\t  cv::Mat cornerTh;\t  // image of local maxima (internal)\t  cv::Mat localMax;\t  // size of neighbourhood for derivatives smoothing\t  int neighborhood; \t  // aperture for gradient computation\t  int aperture; \t  // Harris parameter\t  double k;\t  // maximum strength for threshold computation\t  double maxStrength;\t  // calculated threshold (internal)\t  double threshold;\t  // size of neighbourhood for non-max suppression\t  int nonMaxSize; \t  // kernel for non-max suppression\t  cv::Mat kernel;  public:\t  HarrisDetector() : neighborhood(3), aperture(3), k(0.1), maxStrength(0.0), threshold(0.01), nonMaxSize(3) &#123;\t  // 用于非最大值抑制的内核\t\t  setLocalMaxWindowSize(nonMaxSize);\t  &#125;\t  // Create kernel used in non-maxima suppression\t  void setLocalMaxWindowSize(int size) &#123;\t\t  nonMaxSize= size;\t\t  kernel.create(nonMaxSize,nonMaxSize,CV_8U);\t  &#125;      // 计算每个像素的 Harris 值    \t  // Compute Harris corners\t  void detect(const cv::Mat&amp; image) &#123;\t\t\t  // Harris computation\t\t  cv::cornerHarris(image,cornerStrength,\t\t             neighborhood,// neighborhood size\t\t\t\t\t aperture,     // aperture size\t\t\t\t\t k);           // Harris parameter\t\t\t  // internal threshold computation\t\t  cv::minMaxLoc(cornerStrength,0,&amp;maxStrength);\t\t  // local maxima detection\t\t  cv::Mat dilated;  // temporary image\t\t  cv::dilate(cornerStrength,dilated,cv::Mat());\t\t  cv::compare(cornerStrength,dilated,localMax,cv::CMP_EQ);\t  &#125;          // 用指定阈值获取特征点。阈值的可选范围取决于选择的参数，所以阈值被作为质量等级，用最大Harris值的一个比例值表示。\t  // Get the corner map from the computed Harris values\t  cv::Mat getCornerMap(double qualityLevel) &#123;\t\t  cv::Mat cornerMap;\t\t  // thresholding the corner strength\t\t  threshold= qualityLevel*maxStrength;\t\t  cv::threshold(cornerStrength,cornerTh,threshold,255,cv::THRESH_BINARY);\t\t  // convert to 8-bit image\t\t  cornerTh.convertTo(cornerMap,CV_8U);\t\t\t  // non-maxima suppression\t\t  cv::bitwise_and(cornerMap,localMax,cornerMap);\t\t  return cornerMap;\t  &#125;\t  // Get the feature points vector from the computed Harris values\t  void getCorners(std::vector&lt;cv::Point&gt; &amp;points, double qualityLevel) &#123;\t\t  // Get the corner map\t\t  cv::Mat cornerMap= getCornerMap(qualityLevel);\t\t  // Get the corners\t\t  getCorners(points, cornerMap);\t  &#125;\t  // Get the feature points vector from the computed corner map\t  void getCorners(std::vector&lt;cv::Point&gt; &amp;points, const cv::Mat&amp; cornerMap) &#123;\t\t\t  \t\t  // Iterate over the pixels to obtain all feature points\t\t  for( int y = 0; y &lt; cornerMap.rows; y++ ) &#123;    \t\t\t  const uchar* rowPtr = cornerMap.ptr&lt;uchar&gt;(y);    \t\t\t  for( int x = 0; x &lt; cornerMap.cols; x++ ) &#123;\t\t\t\t  // if it is a feature point\t\t\t\t  if (rowPtr[x]) &#123;\t\t\t\t\t  points.push_back(cv::Point(x,y));\t\t\t\t  &#125;\t\t\t  &#125; \t\t  &#125;\t  &#125;\t  // Draw circles at feature point locations on an image\t  void drawOnImage(cv::Mat &amp;image, const std::vector&lt;cv::Point&gt; &amp;points, cv::Scalar color= cv::Scalar(255,255,255), int radius=3, int thickness=1) &#123;\t\t  std::vector&lt;cv::Point&gt;::const_iterator it= points.begin();\t\t  // for all corners\t\t  while (it!=points.end()) &#123;\t\t\t  // draw a circle at each corner location\t\t\t  cv::circle(image,*it,radius,color,thickness);\t\t\t  ++it;\t\t  &#125;\t  &#125;&#125;;#endif\n类的使用基本使用// Create Harris detector instanceHarrisDetector harris;// Compute Harris valuesharris.detect(image);// Detect Harris cornersstd::vector&lt;cv::Point&gt; pts;harris.getCorners(pts,0.02);// Draw Harris cornersharris.drawOnImage(image,pts);\n适合跟踪的特征 GFTT// GFTT:// Read input imageimage= cv::imread(&quot;church01.jpg&quot;,0);// rotate the image (to produce a horizontal image)cv::transpose(image, image);cv::flip(image, image, 0);// Compute good features to trackstd::vector&lt;cv::KeyPoint&gt; keypoints;// GFTT detectorcv::Ptr&lt;cv::GFTTDetector&gt; ptrGFTT = cv::GFTTDetector::create(\t\t500,\t// maximum number of keypoints to be returned\t\t0.01,\t// quality level\t\t10);\t// minimum allowed distance between points\t  // detect the GFTTptrGFTT-&gt;detect(image,keypoints);// for all keypointsstd::vector&lt;cv::KeyPoint&gt;::const_iterator it= keypoints.begin();while (it!=keypoints.end()) &#123;\t// draw a circle at each corner location\tcv::circle(image,it-&gt;pt,3,cv::Scalar(255,255,255),1);\t++it;&#125;// Display the keypointscv::namedWindow(&quot;GFTT&quot;);cv::imshow(&quot;GFTT&quot;,image);\n快速检测特征Fast (加速分割测试获得特征)基本使用// FAST feature:// Read input imageimage= cv::imread(&quot;church01.jpg&quot;,0);// rotate the image (to produce a horizontal image)cv::transpose(image, image);cv::flip(image, image, 0);keypoints.clear();// FAST detectorcv::Ptr&lt;cv::FastFeatureDetector&gt; ptrFAST = cv::FastFeatureDetector::create(40);// detect the keypointsptrFAST-&gt;detect(image,keypoints);// draw the keypoints\tcv::drawKeypoints(image,keypoints,image,cv::Scalar(255,255,255),cv::DrawMatchesFlags::DRAW_OVER_OUTIMG);std::cout &lt;&lt; &quot;Number of keypoints (FAST): &quot; &lt;&lt; keypoints.size() &lt;&lt; std::endl; // Display the keypointscv::namedWindow(&quot;FAST&quot;);cv::imshow(&quot;FAST&quot;,image);\n将图像分割成网格状，对每个小图像进行单独检测。使特征点分布均匀// The final vector of keypointskeypoints.clear();// detect on each gridfor (int i = 0; i &lt; vstep; i++)\tfor (int j = 0; j &lt; hstep; j++) &#123;\t\t// create ROI over current grid\t\timageROI = image(cv::Rect(j*hsize, i*vsize, hsize, vsize));\t\t// detect the keypoints in grid\t\tgridpoints.clear();\t\tptrFAST-&gt;detect(imageROI, gridpoints);\t\tstd::cout &lt;&lt; &quot;Number of FAST in grid &quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;: &quot; &lt;&lt; gridpoints.size() &lt;&lt; std::endl;\t\tif (gridpoints.size() &gt; subtotal) &#123;\t\t\tfor (auto it = gridpoints.begin(); it != gridpoints.begin() + subtotal; ++it) &#123;\t\t\t\tstd::cout &lt;&lt; &quot;  &quot; &lt;&lt; it-&gt;response &lt;&lt; std::endl;\t\t\t&#125;\t\t&#125;        // get the strongest FAST features\t\tauto itEnd(gridpoints.end());\t\tif (gridpoints.size() &gt; subtotal) &#123; // select the strongest features\t\t\tstd::nth_element(gridpoints.begin(), gridpoints.begin() + subtotal, gridpoints.end(), [](cv::KeyPoint&amp; a, cv::KeyPoint&amp; b) &#123;return a.response &gt; b.response; &#125;);\t\t\titEnd = gridpoints.begin() + subtotal;\t\t&#125;\t\t// add them to the global keypoint vector\t\tfor (auto it = gridpoints.begin(); it != itEnd; ++it) &#123;            it-&gt;pt += cv::Point2f(j*hsize, i*vsize); // convert to image coordinates\t\t\tkeypoints.push_back(*it);\t\t\tstd::cout &lt;&lt; &quot;  &quot; &lt;&lt;it-&gt;response &lt;&lt; std::endl;\t\t&#125;\t&#125;// draw the keypointscv::drawKeypoints(image, keypoints, image, cv::Scalar(255, 255, 255), cv::DrawMatchesFlags::DRAW_OVER_OUTIMG);// Display the keypointscv::namedWindow(&quot;FAST Features (grid)&quot;);cv::imshow(&quot;FAST Features (grid)&quot;, image);\n尺度不变特征的检测SURF &amp; SIFThttps://evaqwq.github.io/2021/08/02/OPENCV1-5/\n// SURF:// Read input imageimage = cv::imread(&quot;church01.jpg&quot;, 0);// rotate the image (to produce a horizontal image)cv::transpose(image, image);cv::flip(image, image, 0);keypoints.clear();// Construct the SURF feature detector objectcv::Ptr&lt;cv::xfeatures2d::SurfFeatureDetector&gt; ptrSURF = cv::xfeatures2d::SurfFeatureDetector::create(2000.0);// detect the keypointsptrSURF-&gt;detect(image, keypoints);\t// Detect the SURF featuresptrSURF-&gt;detect(image,keypoints);\tcv::Mat featureImage;\tcv::drawKeypoints(image,keypoints,featureImage,cv::Scalar(255,255,255),cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS);// Display the keypointscv::namedWindow(&quot;SURF&quot;);cv::imshow(&quot;SURF&quot;,featureImage);std::cout &lt;&lt; &quot;Number of SURF keypoints: &quot; &lt;&lt; keypoints.size() &lt;&lt; std::endl; // Read a second input imageimage= cv::imread(&quot;church03.jpg&quot;, cv::IMREAD_GRAYSCALE);\t// rotate the image (to produce a horizontal image)cv::transpose(image, image);cv::flip(image, image, 0);// Detect the SURF featuresptrSURF-&gt;detect(image,keypoints);\t\tcv::drawKeypoints(image,keypoints,featureImage,cv::Scalar(255,255,255),cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS);// Display the keypointscv::namedWindow(&quot;SURF (2)&quot;);cv::imshow(&quot;SURF (2)&quot;,featureImage);\n// SIFT:// Read input imageimage= cv::imread(&quot;church01.jpg&quot;, cv::IMREAD_GRAYSCALE);// rotate the image (to produce a horizontal image)cv::transpose(image, image);cv::flip(image, image, 0);keypoints.clear();// Construct the SIFT feature detector objectcv::Ptr&lt;cv::xfeatures2d::SiftFeatureDetector&gt; ptrSIFT = cv::xfeatures2d::SiftFeatureDetector::create();// detect the keypointsptrSIFT-&gt;detect(image, keypoints);// Detect the SIFT featuresptrSIFT-&gt;detect(image,keypoints);\t\tcv::drawKeypoints(image,keypoints,featureImage,cv::Scalar(255,255,255),cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS);// Display the keypointscv::namedWindow(&quot;SIFT&quot;);cv::imshow(&quot;SIFT&quot;,featureImage);std::cout &lt;&lt; &quot;Number of SIFT keypoints: &quot; &lt;&lt; keypoints.size() &lt;&lt; std::endl; \n多尺度FAST特征的检测BRISK (二元稳健恒定可拓展关键点)代码实现// BRISK:// Read input imageimage= cv::imread(&quot;church01.jpg&quot;,CV_LOAD_IMAGE_GRAYSCALE);// rotate the image (to produce a horizontal image)cv::transpose(image, image);cv::flip(image, image, 0);// Display the keypointscv::namedWindow(&quot;BRISK&quot;);cv::imshow(&quot;BRISK&quot;,featureImage);keypoints.clear();// Construct another BRISK feature detector objectcv::Ptr&lt;cv::BRISK&gt; ptrBRISK = cv::BRISK::create(\t\t60,  // threshold for BRISK points to be accepted\t\t5);  // number of octaves// Detect the BRISK featuresptrBRISK-&gt;detect(image,keypoints);\t\tcv::drawKeypoints(image,keypoints,featureImage,cv::Scalar(255,255,255),cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS);// Display the keypointscv::namedWindow(&quot;BRISK&quot;);cv::imshow(&quot;BRISK&quot;, featureImage);std::cout &lt;&lt; &quot;Number of BRISK keypoints: &quot; &lt;&lt; keypoints.size() &lt;&lt; std::endl; \n原理BRISK 不仅是一个特征点检测器，它还包含了描述每个被检测关键点的邻域的过程。\n为了在不同尺度下检测兴趣点，该算法首先通过两个下采样过程后见一个图像金字塔。\n\n第一个过程从原始图像尺寸开始，然后每一图层（八度）减少一半。第二个过程先将原始图像的尺寸除以1.5得到第一幅图像，然后在这副图像的基础上每一层减少一半，两个过程产生的图层交替在一起。\n然后在该金字塔的所有图像上应用FAST特征检测器，提取关键点的条件与SIFT算法类似。首先，将一个像素与相邻的八个像素之一进行强度值的比较，只有是局部最大值的像素才可能成为关键点。这个条件满足后，比较这个点与上下两层的相邻像素的评分；如果它的评分在尺度上也更高，那么就认为它是一个兴趣点。\n该算法的关键在于，不同图层具有不同的分辨率。为了精确定位每个关键点，算法需要在尺度和空间两个方面进行插值。\n插值基于FAST关键点评分。在空间方面，在3*3的邻域上进行插值；在尺度方面，计算要符合一个一维抛物线，该抛物线在尺度坐标轴上，穿过当前点和上下两层的两个局部关键点，这个关键点在尺度上的位置见前面的图片。\nORB (定向FAST 和 旋转BRIEF)代码实现// ORB:// Read input imageimage= cv::imread(&quot;church01.jpg&quot;,CV_LOAD_IMAGE_GRAYSCALE);// rotate the image (to produce a horizontal image)cv::transpose(image, image);cv::flip(image, image, 0);keypoints.clear();// Construct the BRISK feature detector objectcv::Ptr&lt;cv::ORB&gt; ptrORB = cv::ORB::create(75, // total number of keypoints\t\t\t\t\t\t\t\t\t\t  1.2, // scale factor between layers\t\t                                  8);  // number of layers in pyramid// detect the keypointsptrORB-&gt;detect(image, keypoints);\t\tcv::drawKeypoints(image,keypoints,featureImage,cv::Scalar(255,255,255),cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS);// Display the keypointscv::namedWindow(&quot;ORB&quot;);cv::imshow(&quot;ORB&quot;,featureImage);std::cout &lt;&lt; &quot;Number of ORB keypoints: &quot; &lt;&lt; keypoints.size() &lt;&lt; std::endl; \n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (处理图像的颜色)","url":"/2021/08/11/OPENCV1-12/","content":"COLORFUL ~ ~ ~ ~ ~ \n\n用策略设计模式比较颜色识别图像中具有某种颜色的像素\n代码我们用策略设计模式把算法封装进类\n#if !defined COLORDETECT#define COLORDETECT#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;class ColorDetector &#123;  private:\t  // minimum acceptable distance\t  int maxDist; \t  // target color\t  cv::Vec3b target; \t  // image containing color converted image\t  cv::Mat converted;\t  bool useLab;\t  // image containing resulting binary map\t  cv::Mat result;  public:\t  // empty constructor\t  // default parameter initialization here\t  ColorDetector() : maxDist(100), target(0,0,0), useLab(false) &#123;&#125;\t  // extra constructor for Lab color space example\t  ColorDetector(bool useLab) : maxDist(100), target(0,0,0), useLab(useLab) &#123;&#125;\t  // full constructor\t  ColorDetector(uchar blue, uchar green, uchar red, int mxDist=100, bool useLab=false): maxDist(mxDist), useLab(useLab) &#123; \t\t  // target color\t\t  setTargetColor(blue, green, red);\t  &#125;\t  // Computes the distance from target color.\t  int getDistanceToTargetColor(const cv::Vec3b&amp; color) const &#123;\t\t  return getColorDistance(color, target);\t  &#125;\t  // Computes the city-block distance between two colors.\t  int getColorDistance(const cv::Vec3b&amp; color1, const cv::Vec3b&amp; color2) const &#123;\t\t  return abs(color1[0]-color2[0])+\t\t\t\t\tabs(color1[1]-color2[1])+\t\t\t\t\tabs(color1[2]-color2[2]);\t \t  // Or:\t\t  // return static_cast&lt;int&gt;(cv::norm&lt;int,3&gt;(cv::Vec3i(color[0]-color2[0],color[1]-color2[1],color[2]-color2[2])));\t\t  \t\t  // Or:\t\t  // cv::Vec3b dist;\t\t  // cv::absdiff(color,color2,dist);\t\t  // return cv::sum(dist)[0];\t  &#125;\t  // Processes the image. Returns a 1-channel binary image.\t  cv::Mat process(const cv::Mat &amp;image);\t  cv::Mat operator()(const cv::Mat &amp;image) &#123;\t  \t\t  cv::Mat input;\t\t \t\t  if (useLab) &#123; // Lab conversion\t\t\t  cv::cvtColor(image, input, CV_BGR2Lab);\t\t  &#125;\t\t  else &#123;\t\t\t  input = image;\t\t  &#125;\t\t  cv::Mat output;\t\t  // compute absolute difference with target color\t\t  cv::absdiff(input,cv::Scalar(target),output);\t      // split the channels into 3 images\t      std::vector&lt;cv::Mat&gt; images;\t      cv::split(output,images);\t\t  // add the 3 channels (saturation might occurs here)\t      output= images[0]+images[1]+images[2];\t\t  // apply threshold          cv::threshold(output,  // input image                      output,  // output image                      maxDist, // threshold (must be &lt; 256)                      255,     // max value                 cv::THRESH_BINARY_INV); // thresholding type\t\t      return output;\t  &#125;\t  // Getters and setters\t  // Sets the color distance threshold.\t  // Threshold must be positive, otherwise distance threshold\t  // is set to 0.\t  void setColorDistanceThreshold(int distance) &#123;\t\t  if (distance&lt;0)\t\t\t  distance=0;\t\t  maxDist= distance;\t  &#125;\t  // Gets the color distance threshold\t  int getColorDistanceThreshold() const &#123;\t\t  return maxDist;\t  &#125;\t  // Sets the color to be detected\t  // given in BGR color space\t  void setTargetColor(uchar blue, uchar green, uchar red) &#123;\t\t  // BGR order\t\t  target = cv::Vec3b(blue, green, red);\t\t  if (useLab) &#123;\t\t\t  // Temporary 1-pixel image\t\t\t  cv::Mat tmp(1, 1, CV_8UC3);\t\t\t  tmp.at&lt;cv::Vec3b&gt;(0, 0) = cv::Vec3b(blue, green, red);\t\t\t  // Converting the target to Lab color space \t\t\t  cv::cvtColor(tmp, tmp, CV_BGR2Lab);\t\t\t  target = tmp.at&lt;cv::Vec3b&gt;(0, 0);\t\t  &#125;\t  &#125;\t  // Sets the color to be detected\t  void setTargetColor(cv::Vec3b color) &#123;\t\t  target= color;\t  &#125;\t  // Gets the color to be detected\t  cv::Vec3b getTargetColor() const &#123;\t\t  return target;\t  &#125;&#125;;#endif\n这样就可以通过创建类的实施来部署算法\n// 1. Create image processor objectColorDetector cdetect;// 2. Read input imagecv::Mat image= cv::imread(&quot;boldt.jpg&quot;);if (image.empty())\treturn 0; cv::namedWindow(&quot;Original Image&quot;);cv::imshow(&quot;Original Image&quot;, image);// 3. Set input parameterscdetect.setTargetColor(230,190,130); // here blue sky// 4. Process the image and display the resultcv::namedWindow(&quot;result&quot;);cv::Mat result = cdetect.process(image);cv::imshow(&quot;result&quot;,result);\n实现原理这个算法的核心过程非常简单，只是对每个像素进行循环扫描，把它的颜色和目标颜色做比较\n// get the iteratorscv::Mat_&lt;cv::Vec3b&gt;::const_iterator it= image.begin&lt;cv::Vec3b&gt;();cv::Mat_&lt;cv::Vec3b&gt;::const_iterator itend= image.end&lt;cv::Vec3b&gt;();cv::Mat_&lt;uchar&gt;::iterator itout= result.begin&lt;uchar&gt;();// get the iterators of the converted image  if (useLab) &#123;\tit = converted.begin&lt;cv::Vec3b&gt;();\titend = converted.end&lt;cv::Vec3b&gt;();&#125;// for each pixelfor ( ; it!= itend; ++it, ++itout) &#123;        \t// process each pixel ---------------------\t// compute distance from target color\tif (getDistanceToTargetColor(*it)&lt;maxDist) &#123;\t\t*itout= 255;\t&#125; else &#123;\t\t*itout= 0;\t&#125;    // end of pixel processing ----------------&#125;\n计算与目标色的差距\n// Computes the distance from target color.int getDistanceToTargetColor(const cv::Vec3b&amp; color) const &#123;\treturn getColorDistance(color, target);&#125;// Computes the city-block distance between two colors.int getColorDistance(const cv::Vec3b&amp; color1, const cv::Vec3b&amp; color2) const &#123;\treturn abs(color1[0]-color2[0]) + abs(color1[1]-color2[1]) + abs(color1[2]-color2[2]);&#125;\n用 GrabCut 算法分割图像grabCut 函数的用法非常简单，只需要输入一幅图像，并对一些像素做上 ”属于背景“ 或 ”属于前景“ 的标记即可。根据这个局部标记，算法将计算出整幅图像的 前景/背景分割线。\n一种指定输入图像局部前景/背景标签的方法是定义一个包含前景物体的矩形：\nRect rectangle(5, 70, 260, 120); // 矩形外部的像素会被标记为背景\n调用函数\n// define bounding rectangle cv::Rect rectangle(50,25,210,180);// the models (internally used)cv::Mat bgModel,fgModel; // segmentation resultcv::Mat result; // segmentation (4 possible values)// GrabCut segmentationcv::grabCut(image,    // input image\t\t\tresult,   // segmentation result\t\t\trectangle,// rectangle containing foreground \t\t\tbgModel, fgModel, // models\t\t\t5,        // number of iterations 迭代次数\t\t\tcv::GC_INIT_WITH_RECT); // use rectangle\n\ncv::GC_INIT_WITH_RECT 使用带边框的矩形模型\n\n// Get the pixels marked as likely foregroundcv::compare(result,cv::GC_PR_FGD,result,cv::CMP_EQ);cv::Mat foreground(image.size(), CV_8UC3, cv::Scalar(255, 255, 255));image.copyTo(foreground,result); // bg pixels not copied\n\ncv::GC_BGD 明确属于背景的像素明确属于背景的像素（本例中矩形以外的像素）\ncv::GC_FGD 明确属于前景的像素（本例中无）\ncv::GC_PR_BGD 可能属于背景的像素\ncv::GC_PR_FGD 可能属于前景的像素（本例中矩形之内像素的初始值）\n\n若想要提取全部前景像素，及值为 cv::GC_FGD 或 cv::GC_PR_FGD 的像素，可以检查第一位的值\nresult = result&amp;1;\n这可能是因为这几个常量别定义的值为1和3，而另外两个被定义为0和2.。\n转换颜色表示法RGB颜色空间 红绿蓝组合后可以产生色域很宽的各种颜色，与人类视觉系统对应。当三种颜色强度相同时就会取得灰度。但空间并不是 感知均匀的色彩空间 ，所以计算颜色之间的差距并不是衡量两个颜色相似度的最好方法。\n为了解决这一问题，引入了一些具有 感知均匀特性 的颜色表示法。\nCIE L*a*b 用欧几里得距离衡量两种颜色的相似度。\n在 process 方法中先把输入图像转换成 CIE L*a*b 色彩空间\ncv::Mat ColorDetector::process(const cv::Mat &amp;image) &#123;\t  // re-allocate binary map if necessary\t  // same size as input image, but 1-channel\t  result.create(image.size(),CV_8U);\t  // Converting to Lab color space \t  if (useLab)\t\t  cv::cvtColor(image, converted, CV_BGR2Lab);\t  // get the iterators\t  cv::Mat_&lt;cv::Vec3b&gt;::const_iterator it= image.begin&lt;cv::Vec3b&gt;();\t  cv::Mat_&lt;cv::Vec3b&gt;::const_iterator itend= image.end&lt;cv::Vec3b&gt;();\t  cv::Mat_&lt;uchar&gt;::iterator itout= result.begin&lt;uchar&gt;();\t  // get the iterators of the converted image \t  if (useLab) &#123;\t\t  it = converted.begin&lt;cv::Vec3b&gt;();\t\t  itend = converted.end&lt;cv::Vec3b&gt;();\t  &#125;\t  // for each pixel\t  for ( ; it!= itend; ++it, ++itout) &#123;\t  …………\n转换后的变量包含颜色转换后的图像，被定义为类 ColorDetector 的一个属性\nclass ColorDetector &#123;  private:\t  // image containing color converted image\t  cv::Mat converted;\n输入的目标颜色也需要转换，需要让函数与上面的函数签名一样，即用户提供的颜色仍然是RGB格式的\nvoid setTargetColor(uchar blue, uchar green, uchar red) &#123;\tMat tmp(1, 1, CV_8UC3);    tmp.at&lt;cv::Vec3d&gt;(0, 0) = cv::Vec3d(blue, green, red);         cv::cvtColor(tmp, tmp, CV_BGR2Lab);        target = tmp.at&lt;cv::Vec3d&gt;(0, 0);&#125;\n用色调、饱和度和亮度表示颜色（HSV)颜色空间转换// convert into HSV spacecv::Mat hsv;cv::cvtColor(image, hsv, CV_BGR2HSV);// split the 3 channels into 3 imagesstd::vector&lt;cv::Mat&gt; channels;cv::split(hsv, channels);// channels[0] is the Hue// channels[1] is the Saturation// channels[2] is the Value\n颜色用于检测：肤色检测mask 掩码\nvoid detectHScolor(const cv::Mat&amp; image,\t\t// input image \tdouble minHue, double maxHue,\t// Hue interval \tdouble minSat, double maxSat,\t// saturation interval\tcv::Mat&amp; mask) &#123;\t\t\t\t// output mask\t// convert into HSV space\tcv::Mat hsv;\tcv::cvtColor(image, hsv, CV_BGR2HSV);\t// split the 3 channels into 3 images\tstd::vector&lt;cv::Mat&gt; channels;\tcv::split(hsv, channels);\t// channels[0] is the Hue\t// channels[1] is the Saturation\t// channels[2] is the Value\t// Hue masking\tcv::Mat mask1; // below maxHue\tcv::threshold(channels[0], mask1, maxHue, 255, cv::THRESH_BINARY_INV);\tcv::Mat mask2; // over minHue\tcv::threshold(channels[0], mask2, minHue, 255, cv::THRESH_BINARY);\tcv::Mat hueMask; // hue mask\tif (minHue &lt; maxHue)\t\thueMask = mask1 &amp; mask2;\telse // if interval crosses the zero-degree axis\t\thueMask = mask1 | mask2;\t// Saturation masking\t// below maxSat\tcv::threshold(channels[1], mask1, maxSat, 255, cv::THRESH_BINARY_INV);\t// over minSat\tcv::threshold(channels[1], mask2, minSat, 255, cv::THRESH_BINARY);\tcv::Mat satMask; // saturation mask\tsatMask = mask1 &amp; mask2;\t// combined mask\tmask = hueMask&amp;satMask;&#125;\n该函数的调用\n// detect skin tonecv::Mat mask;detectHScolor(image, \t\t\t  160, 10, // hue from 320 degrees to 20 degrees \t \t   \t  25, 166, // saturation from ~0.1 to 0.65\t\t\t  mask);// show masked imagecv::Mat detected(image.size(), CV_8UC3, cv::Scalar(0, 0, 0));image.copyTo(detected, mask);cv::imshow(&quot;Detection result&quot;,detected);\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (相机标定)","url":"/2021/07/31/OPENCV1-3/","content":"“The moment you doubt whether you can fly, you cease for ever to be able to do it.” —— Peter Pan\n\nPr相机标定相机参数的估计过程称为相机标定。这意味着我们拥有关于相机的所有信息（参数或系数），这些信息用于确定真实世界中的) 3D 点与其在该标定相机捕获的图像中的相应 2D 投影（像素）之间的精确关系。通常这意味着恢复两种参数。\n内部参数: 例如透镜的焦距、光学中心和径向畸变系数。外部参数: 指相机相对于某些世界坐标系的方位(旋转和平移)。\n二维点与三维点的转化\n\\pmb{s}\n\\begin{vmatrix} \n\\pmb{x} \\\\ \\pmb{y} \\\\ \\pmb{1}\n\\end{vmatrix}\n = \n\\begin{vmatrix} \n\\pmb{f} & \\pmb{0} & \\pmb{0} & \\pmb{0} \\\\ \\pmb{0} & \\pmb{f} & \\pmb{0} & \\pmb{0} \\\\ \\pmb{0} & \\pmb{0} & \\pmb{1} & \\pmb{0}\n\\end{vmatrix}\n\n\\begin{vmatrix} \n\\pmb{X} \\\\ \\pmb{Y} \\\\ \\pmb{Z} \\\\ \\pmb{1}\n\\end{vmatrix}四种坐标系\n1、图像像素坐标系：表示场景中三维点在图像平面上的投影，其坐标原点在CCD图像平面的左上角，u轴平行于CCD平面水平向右，v轴垂直于u轴向下，坐标使用（u,v）来表示。注：这里的（u,v）表示的是该像素在数组中的列数和行数\n2、图像物理坐标系：其坐标原点在CCD图像平面的中心，x,y轴分别平行于图像像素坐标系的坐标轴，坐标用(x,y)表示。\n3、相机坐标系：以相机的光心为坐标系原点，X,Y轴平行于图像坐标系的X,Y轴，相机的光轴为Z轴，坐标系满足右手法则。注：这里所指的相机的光心可以简单的理解为相机透镜的几何中心\n4、世界坐标系：也称为绝对坐标系，用于表示场景点的绝对坐标\n世界参考系和相机参考系的转换https://blog.csdn.net/jiangxing11/article/details/106478020\nhttps://blog.csdn.net/qq_15029743/article/details/90215104\n投影方程\n\\pmb{s}\n\\begin{vmatrix} \n\\pmb{x} \\\\ \\pmb{y} \\\\ \\pmb{1}\n\\end{vmatrix}\n = \n\\begin{vmatrix} \n\\pmb{f_x} & \\pmb{0} & \\pmb{u_0} \\\\ \\pmb{0} & \\pmb{f_y} & \\pmb{v_0} \\\\ \\pmb{0} & \\pmb{0} & \\pmb{1}\n\\end{vmatrix}\n\n\\begin{vmatrix} \n\\pmb{r_1} & \\pmb{r_2} & \\pmb{r_3} & \\pmb{t_1} \\\\ \\pmb{r_4} & \\pmb{r_5} & \\pmb{r_6} & \\pmb{t_2} \\\\ \\pmb{r_7} & \\pmb{r_8} & \\pmb{r_9} & \\pmb{t_3}\n\\end{vmatrix}\n\n\\begin{vmatrix} \n\\pmb{X} \\\\ \\pmb{Y} \\\\ \\pmb{Z} \\\\ \\pmb{1}\n\\end{vmatrix}基于OpenCV的相机标定目标标定过程的目标是使用一组已知的三维点 $(X_w, Y_w, A_w)$ 及其对应的图像坐标 $(u, v)$\n找到 3×3矩阵 K , 3×3旋转矩阵 R , 3×1平移向量 T 。当我们得到相机的内部和外部参数值时，相机就被称为标定相机。\n总之，相机标定算法具有以下输入和输出：\n输入：具有已知二维图像坐标和三维世界坐标的点的图像集合。输出：3×3相机内参矩阵，每幅图像的旋转和平移。注意OpenCV中，相机内部矩阵不包含倾斜参数。所以矩阵的形式是：\n\n\\begin{vmatrix} \n\\pmb{f_x} & \\pmb{0} & \\pmb{c_x} \\\\ \\pmb{0} & \\pmb{f_y} & \\pmb{c_y} \\\\ \\pmb{0} & \\pmb{0} & \\pmb{1}\n\\end{vmatrix}方法\n校正：当我们完全控制成像过程时，执行校准的最佳方法是从不同的视角捕获一个物体或已知尺寸模式的多个图像。我们将在这篇文章中学习的基于棋盘的方法属于这一类。我们也可以使用已知尺寸的圆形图案，而不是棋盘格图案。\n几何线索：有时我们在场景中有其他的几何线索，如直线和消失点，可以用来标定。\n基于深度学习的：当我们对成像设置的控制非常小（例如，我们有场景的单个图像）时，仍然可以使用基于深度学习的方法获取相机的校准信息。\n\n步骤\n使用棋盘格模式定义真实世界坐标;\n从不同的角度捕获棋盘的多个图像;\n查找棋盘的2D坐标;\n校准相机\n\n实现OpenCV 推荐使用国际象棋棋盘的图案生成用于标定的三维场景点的集合。\n\n这个图案在每个方块的角点位置创建场景点；由于图案是平面的，可以假设棋盘位于 Z = 0,  X,Y 的坐标轴与网格对其的位置 。这样，标定时就只需从不同的视角拍摄棋盘图案。\n\n检测角点\n可以用OpenCV自带的函数自动检测棋盘图案中的角点。只需要提供一幅图像和棋盘尺寸（水平和垂直方向内部角点的数量），函数会返回图像中所有棋盘角点的位置，若无法找到图案，函数返回false。\n//输出图像角点的向量vector&lt;Point2f&gt; imageCorners;//棋盘内部角点的数量Size boardSize(7, 5);//获得棋盘角点bool foound = findChessboardCorners(image, boardSize, omageCorners);//image 棋盘图案\n棋盘内部角点数，如图\n\n画角点\n画出角点并用线条连接起来，连接次序即在想两种存储的次序。\ndrawChessboardCorners(image, boardSize, imageCorners, found);\n\n指定三维点\n自由选择单位，如厘米或英寸等。\n为了方便起见我们将方块的边长定位单位，这样可令点的坐标如 （0，0，0）（6，4，0） 这样便于表示。\n（假设棋盘纵深坐标为 z = 0 ）\n为了得到更多的点，需要从不同的视角对同一个标定图案拍摄更多的照片。\nOpenCV的标定函数假定由标定图案确定坐标系，并计算相机相对于坐标系的旋转量和平移量。\n把标定过程封装在 CameraCailbrator 中，\nclass CameraCailbrator&#123;    //每个向量的元素也是一个向量 表示一个视角的点集    //输入点 世界坐标系（每个正方形为一个单位）    vector&lt;vector&lt;Point3f&gt; &gt; objectPoints;    //点在图像中的位置（以像素为单位）    vector&lt;vector&lt;Point2f&gt; &gt; imagePoints;    //输出矩阵    Mat cameraMatrix;    Mat distCoeffs;    //指定标定方式的标志    int fllag;&#125;\n\n类库\n#ifndef CAMERACALIBRATOR_H#define CAMERACALIBRATOR_H#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;opencv2/core.hpp&gt;#include &quot;opencv2/imgproc.hpp&quot;#include &quot;opencv2/calib3d.hpp&quot;#include &lt;opencv2/highgui.hpp&gt;class CameraCalibrator &#123;    // 输入点：      // 世界坐标系中的点     //（每个正方形为一个单位）     std::vector&lt;std::vector&lt;cv::Point3f&gt; &gt; objectPoints;    // 点在图像中的位置（以像素为单位）     std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; imagePoints;    // 输出矩阵     cv::Mat cameraMatrix;    cv::Mat distCoeffs;    // 指定标定方式的标志    int flag;    // used in image undistortion     cv::Mat map1,map2;     bool mustInitUndistort;  public:    CameraCalibrator() : flag(0), mustInitUndistort(true) &#123;&#125;    // Open the chessboard images and extract corner points    int addChessboardPoints(const std::vector&lt;std::string&gt;&amp; filelist, cv::Size &amp; boardSize, std::string windowName=&quot;&quot;);    // Add scene points and corresponding image points    void addPoints(const std::vector&lt;cv::Point2f&gt;&amp; imageCorners, const std::vector&lt;cv::Point3f&gt;&amp; objectCorners);    // Calibrate the camera    double calibrate(const cv::Size imageSize);    // Set the calibration flag    void setCalibrationFlag(bool radial8CoeffEnabled=false, bool tangentialParamEnabled=false);    // Remove distortion in an image (after calibration)    cv::Mat remap(const cv::Mat &amp;image, cv::Size &amp;outputSize = cv::Size(-1, -1));    // Getters    cv::Mat getCameraMatrix() &#123; return cameraMatrix; &#125;    cv::Mat getDistCoeffs()   &#123; return distCoeffs; &#125;&#125;;#endif // CAMERACALIBRATOR_H\n\n这里采用增加标定点的方法\nint CameraCailbrator::addChessboardPoints(const vector&lt;string&gt; &amp; filelist, Size &amp; boardSize)&#123; //文件名列表 标定面板大小        //棋盘上的角点    vector&lt;Point2f&gt; imageCorners;    vector&lt;Point3f&gt; objectCorners;        //场景中的三维点 在棋盘坐标系中，初始化期盼中的角点 角点的三维坐标(i, j, 0)    for(int i = 0; i &lt; boardSize.height; ++i)&#123;        for(int j = 0; j &lt; boardSize.width; ++j)&#123;            objectCorners.push_back(Point3f(i, j, 0.0f));        &#125;    &#125;        //图像中的二维点    Mat image; //存储棋盘图像    int successes = 0;    //处理所有视角    for(int i = 0; i &lt; filelist.size(); ++i)&#123;        image = imread(filelist[i], 0);                bool found = findChessboardCorners(image, boardSize, imageCorners);                //取得角点上的亚像素级精度        if(found)&#123;            cornerSubPix(image, imageCorners, Size(5, 5), Size(-1, -1), TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 30, 0.1));            //棋盘完好            if(imageCorners.size() == boardSize.area())&#123;                //加入同一视角得到的图像和场景点                addPoints(imageCorners, objectCorners);                successes++;            &#125;        &#125;    &#125;    return successes; &#125;\n处理完足够数量的棋盘图像（一般10~20个）后，就可以开始计算标定参数了\n//标定相机 返回重投影误差double CameraCalibrator::calibrate(Size &amp;imageSize)&#123;    //输出旋转量和平移量     vector&lt;Mat&gt; rvecs, tvecs;        //开始标定    return calibrateCamera(objectPoints, // 三维点                           imagePoints,  // 图像点                           imageSize,    // 图像尺寸                           cameraMatrix, // 输出相机矩阵                           distCoffes,   // 输出畸变矩阵                           rvecs, tvecs, // Rs，Ts                           flag);        // 设置选项&#125;\n重投影误差\n函数 calibrateCamera 在得到标定结果之前进行了优化，以便找到合适的内部参数和外部参数，使图像点的预定位置（根据三维点的投影计算得到）和实际位置（图像中的位置）之间的距离达到最小。每个点在标定过程中都会产生这个距离，它们的累加和就是重投影误差。\n畸变模型\n径向畸变：超广角镜头产生的典型畸变\n// 去除图像中的畸变（标定后）Mat CameraCalibrator::remap(const Mat &amp;image)&#123;    Mat undistorted;        if(mustInitUndistort)&#123; // 每个标定过程只调用一次                initUndistortRectifyMap(cameraMatrix, // 计算得到的相机矩阵                                distCoeffs,   // 计算得到的畸变矩阵                                Mat(),        // 可选矫正项（无）                                Mat(),        // 生成无畸变的相机矩阵                                image.size(), // 无畸变图像的尺寸                                CV_32FC1,     // 输出图片的类型                                map1, map2);  // x和y映射功能                mustInitUndistort = false;    &#125;    // 应用映射功能    remap(image, undistorted, map1, map2, INTER_LINEAR); // 插值类型        return undistorted;&#125;\n实现原理回到本文最前面的投影方程。\n方程中连续使用了两个矩阵，把三维空间的点转换到二维空间。\n第一个矩阵，相机的内部参数，是一个3*3的矩阵。是函数 calibrateCamera 输出的矩阵之一。此外还有一个 calibrationMatrixValues 函数，它根据标定矩阵，显示地返回内部参数值。\n第二个矩阵，外部参数，内容是输入的点，以相机为坐标系中心。它由一个旋转向量（3*3）和一个平移向量（3*1）组成。旋转向量 $r_1, r_2, … r_9$ ，平移向量 $t_1, t_2, t_3$ 。\n参考https://blog.csdn.net/LuohenYJ/article/details/104697062\nhttps://blog.csdn.net/jiangxing11/article/details/106478020\nhttps://blog.csdn.net/qq_15029743/article/details/90215104\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (相机姿态还原)","url":"/2021/08/02/OPENCV1-4/","content":"在已知物体三维结构的情况下，如何计算出相机的姿态。\n\n三维姿态solvePnP官方解释：\nhttp://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#solvepnp\nbool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec,bool useExtrinsicGuess=false, int flags=ITERATIVE )\n注意，OpenCV 中还提供了 SolvePnPRansac 函数。它使用 RANSAC 算法求解 PnP 问题。这个函数能识别出错误的物体点/图像点对，并将其标记为异常数据。\nRANSAC（随机抽样一致性）\n用于匹配图像的算法\nhttps://zhuanlan.zhihu.com/p/45532306\nhttps://blog.csdn.net/weixin_42990464/article/details/119254747\ncvPOSIT官方解释：\nhttp://www.opencv.org.cn/index.php/Cv%E7%85%A7%E7%9B%B8%E6%9C%BA%E5%AE%9A%E6%A0%87%E5%92%8C%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA#POSIT\nvoid cvPOSIT( CvPOSITObject* posit_object, CvPoint2D32f* image_points, double focal_length, CvTermCriteria criteria, CvMatr32f rotation_matrix,  CvVect32f translation_vector )\n两种函数的同与异同：\n\n输入都是 3D 点集和对应的 2D 点集，其中 cvPOSIT 的 3D 点包含在 posit_object 结构中\n输出包括旋转矩阵和位移向量\n\n异：\n\nsolvePnP 调用的是 cvFindExtrinsicCameraParams2 通过已知的内参进行未知外参求解，是一个精确解；而 cvPOSIT 是用仿射投影模型近似透视投影模型下，不断迭代计算出来的估计值(在物体深度变化相对于物体到摄像机的距离比较大的时候,这种算法可能不收敛)\nsolvePnP 输出的 rvec 是旋转向量，可以通过 Rodrigues 转换成旋转矩阵，有需要可以再转到欧拉角\n\n实现公园里的长椅\n用标定的相机进行拍照 并 标注8个点\n测量长椅的物理尺寸\n椅座：242.5cm53.5cm\\9cm\n靠背：242.5cm24cm\\9cm\n两者相距 12cm\n\n推导八个点的三维坐标设椅座与靠背的交叉线的左侧顶点作为坐标系原点\nvector&lt;Point3f&gt; objectPoints;objectPoints.push_back(Point3f(0, 45, 0));objectPoints.push_back(Point3f(242.5, 45, 0));objectPoints.push_back(Point3f(242.5, 21, 0));objectPoints.push_back(Point3f(0, 32, 0));objectPoints.push_back(Point3f(0, 9, -9));objectPoints.push_back(Point3f(242.5, 9, -9));objectPoints.push_back(Point3f(242.5, 9, 44.5));objectPoints.push_back(Point3f(0, 9, 44.5));\n在二维成像平面中，写出这些点的坐标vector&lt;Point2f&gt; imagePoints;objectPoints.push_back(Point2f(136,113));objectPoints.push_back(Point2f(379,114));objectPoints.push_back(Point2f(379,150));objectPoints.push_back(Point2f(138,135));objectPoints.push_back(Point2f(143,146));objectPoints.push_back(Point2f(381,166));objectPoints.push_back(Point2f(345,194));objectPoints.push_back(Point2f(103,161));\n调用 solvePnP 函数，计算拍照时相机与这些点之间的相对位置此函数实际上是通过旋转和平移，把物体坐标转换到以相机为中心的坐标系上（焦点为坐标原点）\n注意，该函数得到的旋转量是一个三维容器。表示物体绕着一个单位向量（旋转轴）转了某个角度。（轴 + 角度，罗德里格旋转公式 ）。在 OpenCV 中，旋转角度对应着输出的旋转向量的值，该向量与旋转轴一致，所以，投影公式中使用 Rodrigues 函数来获取旋转三维矩阵。\nMat rvec, tvec;solvePnP(objectPoints, imagePoints, // 对应的三维点和二维点         cameraMatrix, cameraDistCoeffs, // 标定（相机内参 和 相机畸变）         rvec, tvec); // 输出// 转换成三维旋转矩阵Mat rotation;Rodrigues(rvec, rotation);\n检验使用 cv::viz 模块可以显示三维信 息\ncv::viz:: ...\n使用样例\ncv::viz::Viz3d visualizer(&quot;Viz window&quot;); // 创建窗口visualizer.setBackgroundColor(cv::viz::Color::white()); // 白色背景// 创建一个虚拟相机cv::viz::WCameraPosition cam(cMatrix, // 内部参数矩阵 类型为Matx33d（Matx&lt;double, 3, 3&gt;                            image, // 平面上显示的图像                            30.0, // 缩放因子                            cv::viz::Color::black());// 在环境中添加虚拟相机visualizer.showWidget(&quot;Camera&quot;, cam);// 用长方形表示虚拟的长椅cv::viz::Wcube plane1(Point3f(0.0, 45.0, 0.0),                     Point3f(242.5, 21.0, -9.0),                     true, // 显示线条框架                     cv::viz::Color::blue());cv::viz::Wcube plane2(Point3f(0.0, 9.0, -9.0),                     Point3f(242.5, 0.0, 44.5),                     true, // 显示线条框架                     cv::viz::Color::blue());// 把虚拟物体加入到环境中visualizer.showWidget(&quot;top&quot;, plane1);visualizer.showWidget(&quot;bottom&quot;, plane2);// 虚拟长椅也放在坐标原点，然后用cv::solvePnP函数计算出以相机为中心的位置，并把长椅移动到该位置。这个过程在setWidgetPose方法中完成。这里只是根据估算值进行了旋转和平移Mat rotation;// 将rotation转换成3*3的旋转矩阵Rodrigues(rvec, rotation);// 移动长椅Affine3d pose(rotation, tvec);visualizer.setWidgetPose(&quot;top&quot;, pose);visualizer.setWidgetPose(&quot;bottom&quot;, pose);// 循环显示while(waitKey(100) == -1 &amp;&amp; !visualizer.wasStopped())&#123;        visualizer.spinOnce(1, // 暂停1s                       true); // 重绘&#125;// 关闭可视化窗口 或 在OpenCV图像窗口上输入任意键就可以结束循环。在循环内部移动物体（用setWidgetPose），即可产生动画。\n相机姿态更新https://blog.csdn.net/aptx704610875/article/details/48915149\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (用标定相机实现三维重建)","url":"/2021/08/02/OPENCV1-5/","content":"  利用不同视角下图像点之间的关系，计算出三维信息。\n\n学些啥？\n利用不同视角下图像点之间的关系，计算出三维信息\n\n新的数学实体 —— 本质矩阵\n\n三角剖分概念\n\n\n\n实现匹配两个视图的特征点可利用 SIFT检测器 或 描述子\nSIFT &amp; SURFSURF（加速稳健特征） 算法是 SIFT（尺度不变特征转换） 算法的加速版\nSURF 特征检测属于 opencv_contrib 库，在编译时包含了附加模块才能使用。\n// 创建SURF特征检测器对象Ptr&lt;xfeatures2d::SurfFeatureDetector&gt; ptrSURF = xfeatures2d::SurfFeatureDetector::create((2000.0));// 检测关键点ptrSURF -&gt; detect(image, keypoints);\nSIFT\n// 创建SIFT特征检测器对象Ptr&lt;xfeatures2d::SiftFeatureDetector&gt; ptrSIFT = xfeatures2d::SiftFeatureDetector::create((2000.0));// 检测关键点ptrSIFT -&gt; detect(image, keypoints);\n画关键点\ndrawKeypoints(image,                                  // 原始图像              keypoints,                              // 关键点的向量              featureImage,                           // 结果图像              Scalar(255, 255, 255),                  // 点的颜色              DrawMatchesFlags::DRAW_RICH_KEYPOINTS); // 显示相关的因子尺度\n包含被检测特征的结果图像\n\n用不同的尺度对同一物体拍摄一张照片，特征检测的结果图像\n\n DrawMatchesFlags::DRAW_RICH_KEYPOINTS 标志得到了关键点的圆，并且圆的尺寸与每个特征计算得到的尺度成正比。为了使特征具有旋转不变性，SURF还让每个特征关联了一个方向，由每个圆的辐射线表示。\n特征描述子// 定义关键点的容器vector&lt;KeyPoint&gt; keypoints1;vector&lt;KeyPoint&gt; keypoints2;// 定义特征检测器Ptr&lt;Feature2D&gt; ptrFeature2D = xfeatures2d::SURF::create(2000.0);// 检测关键点ptrFeature2D -&gt; detect(image1, keypoints1);ptrFeature2D -&gt; detect(image2, keypoints2);// 提取描述子Mat descriptors1;Mat descriptors2;ptrFeature2D -&gt; compute(image1, keypoints1, descriptors1);ptrFeature2D -&gt; compute(image2, keypoints2, descriptors2);// 构造匹配器BFMatcher matcher(NORM_L2);// 匹配两幅图像的描述子vector&lt;DMatch&gt; matches;matcher.match(descriptors1, descriptors2, matches);\nFeature2D 类有一个很实用的函数，可在检测兴趣点的同时计算它们的描述子，调用方法如下\nptrFeature2D -&gt; detectAndCompute(image, noArray(), keypoints, descriptors);\n二值描述子ORB\nORB 的用法与 SURF 、SIFT 没有什么区别\n// 定义关键点的容器 和 描述子vector&lt;KeyPoint&gt; keypoints1;vector&lt;KeyPoint&gt; keypoints2;Mat descriptors1;Mat descriptors2;// 定义特征检测器 / 描述子Ptr&lt;Feature2D&gt; feature = ORB::create(60);// 检测 并 描述 关键点feature -&gt; detectAndCompute(image1, noArray(), keypoints1, descriptors1);feature -&gt; detectAndCompute(image2, noArray(), keypoints2, descriptors2);// 构造匹配器BFMatcher matcher(NORM_HAMMING); // 二值描述子一律用HAMMING规范// 匹配两幅图像的描述子vector&lt;DMatch&gt; matches;matcher.match(descriptors1, descriptors2, matches);\n找出本质矩阵https://www.cnblogs.com/yuanlibin/p/9462180.html\nMat inliers;Mat essential findEssentialMat(points1, points2,                              Matrix, // 内部参数                              RANSAC,                              0.9, 1.0, // RANSAC方法                              inliers); // 提取到的内殿\n还原相机的相对姿态// 根据本质矩阵还原相机的相对姿态Mat rotation, trnslation;recoverPose(essential, // 本质矩阵            points1, points2, // 匹配的关键点            cameraMatrix, // 内部矩阵            rotation, translation, // 计算的移动值            inliers); // 内点匹配项\n计算三角剖分vector&lt;Vec3d&gt; points3D;triangulate(projection1, projection2, points1u, points2u, points3D);\n\n完整代码// 定义关键点的容器 和 描述子vector&lt;KeyPoint&gt; keypoints1;vector&lt;KeyPoint&gt; keypoints2;Mat descriptors1;Mat descriptors2;// 定义SIFT特征检测器Ptr&lt;Feature2D&gt; ptrFeature2D = xfeatures2d::SIFT::create(500);// 检测 并 描述 关键点feature -&gt; detectAndCompute(image1, noArray(), keypoints1, descriptors1);feature -&gt; detectAndCompute(image2, noArray(), keypoints2, descriptors2);// 构造匹配器BFMatcher matcher(NORM_L2, true); // 交叉检查标志 true// 匹配两幅图像的描述子vector&lt;DMatch&gt; matches;matcher.match(descriptors1, descriptors2, matches);// 将关键点转换成 Point2f 类型vector&lt;Point2f&gt; points1, points2;for(vector&lt;DMatch&gt;::const_iterator it = matches.begin(); it!= matches.end(); ++it)&#123;    // 获取 左 右 侧关键点的位置    float x = keypoints1[it -&gt; queryIdx].pt.x;    float y = keypoints1[it -&gt; queryIdx].pt.y;    points1.push_back(Point2f(x, y));        float x = keypoints2[it -&gt; queryIdx].pt.x;    float y = keypoints2[it -&gt; queryIdx].pt.y;    points2.push_back(Point2f(x, y));&#125;// 找出image1，image2之间的本质矩阵Mat inliers;Mat essential findEssentialMat(points1, points2,                              Matrix, // 内部参数                              RANSAC,                              0.9, 1.0, // RANSAC方法                              inliers); // 提取到的内殿// 根据本质矩阵还原相机的相对姿态Mat rotation, trnslation;recoverPose(essential, // 本质矩阵            points1, points2, // 匹配的关键点            cameraMatrix, // 内部矩阵            rotation, translation, // 计算的移动值            inliers); // 内点匹配项// 根据旋转量R和平移量T构建投影矩阵Mat projection2(3, 4, CV_64F); // 3*4rotation.copyTo(projection2(Rect(0, 0, 3, 3)));translation.copyTo(projection2.colRange(3, 4));// 构建通用投影矩阵Mat projection1(3, 4, CV_64F, 0);Mat diag(Mat::eye(3, 3, CV_64F));diag.copyTo(projection1(Rect(0, 0, 3, 3)));// 用于存储内点vector&lt;Vec2d&gt; inlierPts1;vector&lt;Vec2d&gt; inlierPts2;// 创建输入内点的容器，用于三角剖分int j(0);for(int i = 0; i &lt; inliers.rows; ++i)&#123;    if(inliers.at&lt;uchar&gt;(i))&#123;    \tinlierPts1.push_back(Vec2d(points1[i].x, points1[i].y));        inlierPts2.push_back(Vec2d(points2[i].x, points2[i].y));    &#125;&#125;// 矫正并标准化图像点vector&lt;Vec2d&gt; points1u;undistortPoints(inlierPts1, points1u, cameraMatrix, cameraDistCoeffs);vector&lt;Vec2d&gt; points2u;undistortPoints(inlierPts2, points2u, cameraMatrix, cameraDistCoeffs);// 三角剖分vector&lt;Vec3d&gt; points3D;triangulate(projection1, projection2, points1u, points2u,)\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (处理视频序列)","url":"/2021/08/04/OPENCV1-7/","content":"Video ~ ~\n\n读取int main()&#123;\tVideoCapture capture(&quot;bike.avi&quot;);\tif(!capture.isOpen()) return 1;\t\tdouble rate = capture.get(CV_CAP_PROP_FPS);\t\tbool stop(false);\tMat frame;\tnamedWindow(&quot;Extracted Frame&quot;);\t\tint delay = 1000/rate;\t\twhile(!stop)&#123;\t\t\t\tif(!capture.read(frame)) break;\t\t\t\timshow(&quot;Extracted Frame&quot;, frame);\t\t\t\tif(waitKey(delay) &gt; 0) stop = true; \t&#125;\t\tcapture.release();\treturn 0;&#125; \n详细见 https://evaqwq.github.io/2021/07/28/OPENCV1-1/\n处理视频帧#include &quot;videoprocessor.h&quot;void draw(const cv::Mat&amp; img, cv::Mat&amp; out) &#123;\timg.copyTo(out);\tcv::circle(out, cv::Point(100,100),5,cv::Scalar(255,0,0),2);&#125;// processing functionvoid canny(cv::Mat&amp; img, cv::Mat&amp; out) &#123;   // Convert to gray   if (img.channels()==3)      cv::cvtColor(img,out,cv::COLOR_BGR2GRAY);   // Compute Canny edges   cv::Canny(out,out,100,200);   // Invert the image   cv::threshold(out,out,128,255,cv::THRESH_BINARY_INV);&#125;int main()&#123;\t// Open the video file\tcv::VideoCapture capture(&quot;bike.avi&quot;);//\tcv::VideoCapture capture(&quot;http://www.laganiere.name/bike.avi&quot;);\t// check if video successfully opened\tif (!capture.isOpened())\t\treturn 1;\t// Get the frame rate\tdouble rate= capture.get(cv::CAP_PROP_FPS);\tstd::cout &lt;&lt; &quot;Frame rate: &quot; &lt;&lt; rate &lt;&lt; &quot;fps&quot; &lt;&lt; std::endl;\tbool stop(false);\tcv::Mat frame; // current video frame\tcv::namedWindow(&quot;Extracted Frame&quot;);\t// Delay between each frame\t// corresponds to video frame rate\tint delay= 1000/rate;\tlong long i=0;\tstd::string b=&quot;bike&quot;;\tstd::string ext=&quot;.bmp&quot;;\t// for all frames in video\twhile (!stop) &#123;\t\t// read next frame if any\t\tif (!capture.read(frame))\t\t\tbreak;\t\tcv::imshow(&quot;Extracted Frame&quot;,frame);\t\tstd::string name(b);        std::ostringstream ss; ss &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::setw(3) &lt;&lt; i; name+= ss.str(); i++;\t\tname+=ext;\t\tstd::cout &lt;&lt; name &lt;&lt;std::endl;\t\t\t\tcv::Mat test;\t\t//      cv::resize(frame, test, cv::Size(), 0.2,0.2);\t\t//\t\tcv::imwrite(name, frame);        //\t\tcv::imwrite(name, test);\t\t// introduce a delay\t\t// or press key to stop\t\tif (cv::waitKey(delay)&gt;=0)\t\t\t\tstop= true;\t&#125;\t// Close the video file\tcapture.release();\tcv::waitKey();\t// Now using the VideoProcessor class\t// Create instance\tVideoProcessor processor;\t// Open video file\tprocessor.setInput(&quot;bike.avi&quot;);\t// Declare a window to display the video\tprocessor.displayInput(&quot;Input Video&quot;);\tprocessor.displayOutput(&quot;Output Video&quot;);\t// Play the video at the original frame rate\tprocessor.setDelay(1000./processor.getFrameRate());\t// Set the frame processor callback function\tprocessor.setFrameProcessor(canny);\t// output a video\tprocessor.setOutput(&quot;bikeCanny.avi&quot;,-1,15);\t// stop the process at this frame\tprocessor.stopAtFrameNo(51);\t// Start the process\tprocessor.run();\tcv::waitKey();\t\treturn 0;&#125;\nVideoProcessor.h\n// The frame processor interfaceclass FrameProcessor &#123;  public:\t// processing method\tvirtual void process(cv:: Mat &amp;input, cv:: Mat &amp;output)= 0;&#125;;class VideoProcessor &#123;  private:\t  // the OpenCV video capture object\t  cv::VideoCapture capture;\t  // the callback function to be called \t  // for the processing of each frame\t  void (*process)(cv::Mat&amp;, cv::Mat&amp;);\t  // the pointer to the class implementing \t  // the FrameProcessor interface\t  FrameProcessor *frameProcessor;\t  // a bool to determine if the \t  // process callback will be called\t  bool callIt;\t  // Input display window name\t  std::string windowNameInput;\t  // Output display window name\t  std::string windowNameOutput;\t  // delay between each frame processing\t  int delay;\t  // number of processed frames \t  long fnumber;\t  // stop at this frame number\t  long frameToStop;\t  // to stop the processing\t  bool stop;\t  // vector of image filename to be used as input\t  std::vector&lt;std::string&gt; images; \t  // image vector iterator\t  std::vector&lt;std::string&gt;::const_iterator itImg;\t  // the OpenCV video writer object\t  cv::VideoWriter writer;\t  // output filename\t  std::string outputFile;\t  // current index for output images\t  int currentIndex;\t  // number of digits in output image filename\t  int digits;\t  // extension of output images\t  std::string extension;\t  // to get the next frame \t  // could be: video file; camera; vector of images\t  bool readNextFrame(cv::Mat&amp; frame);\t  // to write the output frame \t  // could be: video file or images\t  void writeNextFrame(cv::Mat&amp; frame);  public:\t  // Constructor setting the default values\t  VideoProcessor() : callIt(false), delay(-1), \t\t  fnumber(0), stop(false), digits(0), frameToStop(-1), \t      process(0), frameProcessor(0) &#123;&#125;\t  // set the name of the video file\t  bool setInput(std::string filename)\t  // set the camera ID\t  bool setInput(int id)\t  // set the vector of input images\t  bool setInput(const std::vector&lt;std::string&gt;&amp; imgs)\t  // set the output video file\t  // by default the same parameters than input video will be used\t  bool setOutput(const std::string &amp;filename, int codec=0, double framerate=0.0, bool isColor=true);\t  // set the output as a series of image files\t  // extension must be &quot;.jpg&quot;, &quot;.bmp&quot; ...\t  bool setOutput(const std::string &amp;filename, // filename prefix\t\t  const std::string &amp;ext, // image file extension \t\t  int numberOfDigits=3,   // number of digits\t\t  int startIndex=0) // start index\t  // set the callback function that will be called for each frame\t  void setFrameProcessor(void (*frameProcessingCallback)(cv::Mat&amp;, cv::Mat&amp;));\t  // set the instance of the class that implements the FrameProcessor interface\t  void setFrameProcessor(FrameProcessor* frameProcessorPtr);\t  // stop streaming at this frame number\t  void stopAtFrameNo(long frame);\t  // process callback to be called\t  void callProcess();\t  // do not call process callback\t  void dontCallProcess();\t  // to display the input frames\t  void displayInput(std::string wn);\t  // to display the processed frames\t  void displayOutput(std::string wn);\t  // do not display the processed frames\t  void dontDisplay();\t  // set a delay between each frame\t  // 0 means wait at each frame\t  // negative means no delay\t  void setDelay(int d);\t  // a count is kept of the processed frames\t  long getNumberOfProcessedFrames();\t  // return the size of the video frame\t  cv::Size getFrameSize();\t  // return the frame number of the next frame\t  long getFrameNumber();\t  // return the position in ms\t  double getPositionMS();\t  // return the frame rate\t  double getFrameRate();\t  // return the number of frames in video\t  long getTotalFrameCount();\t  // get the codec of input video\t  int getCodec(char codec[4]);\t  \t  // go to this frame number\t  bool setFrameNumber(long pos);\t  // go to this position\t  bool setPositionMS(double pos);\t  // go to this position expressed in fraction of total film length\t  bool setRelativePosition(double pos);\t  // Stop the processing\t  void stopIt();\t  // Is the process stopped?\t  bool isStopped();\t  // Is a capture device opened?\t  bool isOpened();\t  \t  // to grab (and process) the frames of the sequence\t  void run();&#125;;\n提取前景物BGFGSegmentor.h\nclass BGFGSegmentor : public FrameProcessor &#123;\t\tcv::Mat gray;\t\t\t// current gray-level image\tcv::Mat background;\t\t// accumulated background\tcv::Mat backImage;\t\t// current background image\tcv::Mat foreground;\t\t// foreground image\tdouble learningRate;    // learning rate in background accumulation\tint threshold;\t\t\t// threshold for foreground extraction  public:\tBGFGSegmentor() : threshold(10), learningRate(0.01) &#123;&#125;\t// Set the threshold used to declare a foreground\tvoid setThreshold(int t) &#123;\t\tthreshold= t;\t&#125;\t// Set the learning rate\tvoid setLearningRate(double r) &#123;\t\tlearningRate= r;\t&#125;\t// processing method\tvoid process(cv:: Mat &amp;frame, cv:: Mat &amp;output) &#123;\t\t// convert to gray-level image\t\tcv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY); \t\t// initialize background to 1st frame\t\tif (background.empty())\t\t\tgray.convertTo(background, CV_32F);\t\t\t\t// convert background to 8U\t\tbackground.convertTo(backImage,CV_8U);\t\t// compute difference between current image and background\t\tcv::absdiff(backImage,gray,foreground);\t\t// apply threshold to foreground image\t\tcv::threshold(foreground,output,threshold,255,cv::THRESH_BINARY_INV);\t\t// accumulate background\t\tcv::accumulateWeighted(gray, background, \t\t\t                   // alpha*gray + (1-alpha)*background\t\t\t                   learningRate,  // alpha \t\t\t\t\t\t\t   output);       // mask\t&#125;&#125;;#endif\nint main()&#123;\t// Open the video file    cv::VideoCapture capture(&quot;bike.avi&quot;);\t// check if video successfully opened\tif (!capture.isOpened())\t\treturn 0;\t// current video frame\tcv::Mat frame; \t// foreground binary image\tcv::Mat foreground;\t// background image\tcv::Mat background;\tcv::namedWindow(&quot;Extracted Foreground&quot;);\t// The Mixture of Gaussian object\t// used with all default parameters\tcv::Ptr&lt;cv::BackgroundSubtractor&gt; ptrMOG = cv::bgsegm::createBackgroundSubtractorMOG();\t\tbool stop(false);\t// for all frames in video\twhile (!stop) &#123;\t\t// read next frame if any\t\tif (!capture.read(frame))\t\t\tbreak;\t\t// update the background\t\t// and return the foreground\t\tptrMOG-&gt;apply(frame,foreground,0.01);\t\t// Complement the image\t\tcv::threshold(foreground,foreground,128,255,cv::THRESH_BINARY_INV);\t\t// show foreground and background\t\tcv::imshow(&quot;Extracted Foreground&quot;,foreground);\t\t// introduce a delay\t\t// or press key to stop\t\tif (cv::waitKey(10)&gt;=0)\t\t\t\tstop= true;\t&#125;\tcv::waitKey();\t// Create video procesor instance\tVideoProcessor processor;\t// Create background/foreground segmentor \tBGFGSegmentor segmentor;\tsegmentor.setThreshold(25);\t// Open video file\tprocessor.setInput(&quot;bike.avi&quot;);\t// set frame processor\tprocessor.setFrameProcessor(&amp;segmentor);\t// Declare a window to display the video\tprocessor.displayOutput(&quot;Extracted Foreground&quot;);\t// Play the video at the original frame rate\tprocessor.setDelay(1000./processor.getFrameRate());\t// Start the process\tprocessor.run();\tcv::waitKey();&#125; \n将得到一些二值前景图像\n\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (跟踪运动目标)","url":"/2021/08/04/OPENCV1-8/","content":"Tracking ~ ~\n\n学这有啥用嘞对于手持摄像机拍摄的视频，可以用这种方法消除抖动或减小抖动幅度，时视频更加平稳\n运功估值还可用于视频编码，用以压缩视频，便于传输和存储\n跟踪特征点在最初的帧中检测特征点，在下一帧中跟踪这些特征点\nclass FeatureTracker : public FrameProcessor &#123;\t\tcv::Mat gray;\t\t\t// current gray-level image\tcv::Mat gray_prev;\t\t// previous gray-level image\tstd::vector&lt;cv::Point2f&gt; points[2]; // tracked features from 0-&gt;1\tstd::vector&lt;cv::Point2f&gt; initial;   // initial position of tracked points\tstd::vector&lt;cv::Point2f&gt; features;  // detected features\tint max_count;\t  // maximum number of features to detect\tdouble qlevel;    // quality level for feature detection\tdouble minDist;   // minimum distance between two feature points\tstd::vector&lt;uchar&gt; status; // status of tracked features    std::vector&lt;float&gt; err;    // error in tracking  public:\tFeatureTracker() : max_count(500), qlevel(0.01), minDist(10.) &#123;&#125;\t\t// processing method\tvoid process(cv:: Mat &amp;frame, cv:: Mat &amp;output) &#123;\t\t// convert to gray-level image\t\tcv::cvtColor(frame, gray, CV_BGR2GRAY); \t\tframe.copyTo(output);\t\t// 1. if new feature points must be added\t\tif(addNewPoints())\t\t&#123;\t\t\t// detect feature points\t\t\tdetectFeaturePoints();\t\t\t// add the detected features to the currently tracked features\t\t\tpoints[0].insert(points[0].end(),features.begin(),features.end());\t\t\tinitial.insert(initial.end(),features.begin(),features.end());\t\t&#125;\t\t\t\t// for first image of the sequence\t\tif(gray_prev.empty())           gray.copyTo(gray_prev);            \t\t// 2. track features\t\tcv::calcOpticalFlowPyrLK(gray_prev, gray, // 2 consecutive images\t\t\tpoints[0], // input point position in first image            points[1], // output point postion in the second image                status,    // tracking success                err);      // tracking error            // 3. loop over the tracked points to reject the undesirables            int k=0;            for( int i= 0; i &lt; points[1].size(); i++ ) &#123;                // do we keep this point?                if (acceptTrackedPoint(i)) &#123;                    // keep this point in vector                    initial[k]= initial[i];                    points[1][k++] = points[1][i];                &#125;            &#125;\t\t// eliminate unsuccesful points        points[1].resize(k);\t\tinitial.resize(k);        // 4. handle the accepted tracked points\t\thandleTrackedPoints(frame, output);        // 5. current points and image become previous ones\t\tstd::swap(points[1], points[0]);        cv::swap(gray_prev, gray);\t&#125;\t// feature point detection\tvoid detectFeaturePoints() &#123;\t\t\t\t\t// detect the features\t\tcv::goodFeaturesToTrack(gray, // the image \t\t\tfeatures,   // the output detected features\t\t\tmax_count,  // the maximum number of features \t\t\tqlevel,     // quality level\t\t\tminDist);   // min distance between two features\t&#125;\t// determine if new points should be added\tbool addNewPoints() &#123;\t\t// if too few points\t\treturn points[0].size()&lt;=10;\t&#125;\t// determine which tracked point should be accepted\t// here we keep only moving points\tbool acceptTrackedPoint(int i) &#123;\t\treturn status[i] &amp;&amp; // status is false if unable to track point i\t\t\t// if point has moved\t\t\t(abs(points[0][i].x-points[1][i].x)+\t\t\t(abs(points[0][i].y-points[1][i].y))&gt;2);\t&#125;\t// handle the currently tracked points\tvoid handleTrackedPoints(cv:: Mat &amp;frame, cv:: Mat &amp;output) &#123;\t\t// for all tracked points\t\tfor(int i= 0; i &lt; points[1].size(); i++ ) &#123;\t\t\t// draw line and circle\t\t    cv::line(output, initial[i], points[1][i], cv::Scalar(255,255,255));\t\t\tcv::circle(output, points[1][i], 3, cv::Scalar(255,255,255),-1);\t\t&#125;\t&#125;&#125;;#endif\n开始跟踪！！\nint main()&#123;\t// Create video procesor instance\tVideoProcessor processor;\t// Create feature tracker instance\tFeatureTracker tracker;\t// Open video file\tprocessor.setInput(&quot;bike.avi&quot;);\t// set frame processor\tprocessor.setFrameProcessor(&amp;tracker);\t// Declare a window to display the video\tprocessor.displayOutput(&quot;Tracked Features&quot;);\t// Play the video at the original frame rate\tprocessor.setDelay(1000./processor.getFrameRate());\tprocessor.stopAtFrameNo(90);\t// Start the process\tprocessor.run();\tcv::waitKey();&#125;\n\n估算光流// Drawing optical flow vectors on an imagevoid drawOpticalFlow(const cv::Mat&amp; oflow,    // the optical flow \t                 cv::Mat&amp; flowImage,      // the produced image\t                 int stride,  // the stride for displaying the vectors\t                 float scale, // multiplying factor for the vectors\t                 const cv::Scalar&amp; color) // the color of the vectors&#123;\t// create the image if required\tif (flowImage.size() != oflow.size()) &#123;\t\tflowImage.create(oflow.size(), CV_8UC3);\t\tflowImage = cv::Vec3i(255,255,255);\t&#125;\t// for all vectors using stride as a step\tfor (int y = 0; y &lt; oflow.rows; y += stride)\t\tfor (int x = 0; x &lt; oflow.cols; x += stride) &#123;\t\t\t// gets the vector\t\t\t\tcv::Point2f vector = oflow.at&lt; cv::Point2f&gt;(y, x);\t\t\t// draw the line\t\t\t\tcv::line(flowImage, cv::Point(x, y), \t\t\t\t     cv::Point(static_cast&lt;int&gt;(x + scale*vector.x + 0.5), \t\t\t\t\t\t       static_cast&lt;int&gt;(y + scale*vector.y + 0.5)), color);\t\t\t// draw the arrow tip\t\t\t\tcv::circle(flowImage, cv::Point(static_cast&lt;int&gt;(x + scale*vector.x + 0.5),\t\t\t\t                            static_cast&lt;int&gt;(y + scale*vector.y + 0.5)), 1, color, -1);\t\t&#125;&#125;int main()&#123;\t// pick 2 frames of the sequence\tcv::Mat frame1= cv::imread(&quot;goose/goose230.bmp&quot;, 0);\tcv::Mat frame2= cv::imread(&quot;goose/goose237.bmp&quot;, 0);\t// Combined display\tcv::Mat combined(frame1.rows, frame1.cols + frame2.cols, CV_8U);\tframe1.copyTo(combined.colRange(0, frame1.cols));\tframe2.copyTo(combined.colRange(frame1.cols, frame1.cols+frame2.cols));\tcv::imshow(&quot;Frames&quot;, combined);\t// Create the optical flow algorithm\tcv::Ptr&lt;cv::DualTVL1OpticalFlow&gt; tvl1 = cv::createOptFlow_DualTVL1();\tstd::cout &lt;&lt; &quot;regularization coeeficient: &quot; &lt;&lt; tvl1-&gt;getLambda() &lt;&lt; std::endl; // the smaller the soomther\tstd::cout &lt;&lt; &quot;Number of scales: &quot; &lt;&lt; tvl1-&gt;getScalesNumber() &lt;&lt; std::endl; // number of scales\tstd::cout &lt;&lt; &quot;Scale step: &quot; &lt;&lt; tvl1-&gt;getScaleStep() &lt;&lt; std::endl; // size between scales\tstd::cout &lt;&lt; &quot;Number of warpings: &quot; &lt;&lt; tvl1-&gt;getWarpingsNumber() &lt;&lt; std::endl; // size between scales\tstd::cout &lt;&lt; &quot;Stopping criteria: &quot; &lt;&lt; tvl1-&gt;getEpsilon() &lt;&lt; &quot; and &quot; &lt;&lt; tvl1-&gt;getOuterIterations() &lt;&lt; std::endl; // size between scales\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// compute the optical flow between 2 frames\tcv::Mat oflow; // image of 2D flow vectors\t// compute optical flow between frame1 and frame2\ttvl1-&gt;calc(frame1, frame2, oflow);\t// Draw the optical flow image\tcv::Mat flowImage;\tdrawOpticalFlow(oflow,     // input flow vectors \t\tflowImage, // image to be generated\t\t8,         // display vectors every 8 pixels\t\t2,         // multiply size of vectors by 2\t\tcv::Scalar(0, 0, 0)); // vector color\tcv::imshow(&quot;Optical Flow&quot;, flowImage);\t// compute a smoother optical flow between 2 frames\ttvl1-&gt;setLambda(0.075);\ttvl1-&gt;calc(frame1, frame2, oflow);\t// Draw the optical flow image\tcv::Mat flowImage2;\tdrawOpticalFlow(oflow,     // input flow vectors \t\tflowImage2, // image to be generated\t\t8,         // display vectors every 8 pixels\t\t2,         // multiply size of vectors by 2\t\tcv::Scalar(0, 0, 0)); // vector color\tcv::imshow(&quot;Smoother Optical Flow&quot;, flowImage2);\tcv::waitKey();&#125;\n\n\n跟踪视频中的物体visualTracker.h\n#if !defined FTRACKER#define FTRACKER#include &lt;string&gt;#include &lt;vector&gt;#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/features2d.hpp&gt;#include &lt;opencv2/tracking/tracker.hpp&gt;#include &quot;videoprocessor.h&quot;class VisualTracker : public FrameProcessor &#123;\t\tcv::Ptr&lt;cv::Tracker&gt; tracker;\tcv::Rect2d box;\tbool reset;  public:\t// constructor specifying the tracker to be used\tVisualTracker(cv::Ptr&lt;cv::Tracker&gt; tracker) : \t\t             reset(true), tracker(tracker) &#123;&#125;\t// set the bounding box to initiate tracking\tvoid setBoundingBox(const cv::Rect2d&amp; bb) &#123;\t\tbox = bb;\t\treset = true;\t&#125;\t\t// callback processing method\tvoid process(cv:: Mat &amp;frame, cv:: Mat &amp;output) &#123;\t\tif (reset) &#123; // new tracking session\t\t\treset = false;\t\t\ttracker-&gt;init(frame, box);\t\t&#125; else &#123; // update the target&#x27;s position\t\t\t\t\ttracker-&gt;update(frame, box);\t\t&#125;\t\t// draw bounding box on current frame\t\tframe.copyTo(output);\t\tcv::rectangle(output, box, cv::Scalar(255, 255, 255), 2);\t&#125;&#125;;#endif\nint main()&#123;\t// Create video procesor instance\tVideoProcessor processor;\t\t// generate the filename\tstd::vector&lt;std::string&gt; imgs;\tstd::string prefix = &quot;goose/goose&quot;;\tstd::string ext = &quot;.bmp&quot;;\t// Add the image names to be used for tracking\tfor (long i = 130; i &lt; 317; i++) &#123;\t\tstd::string name(prefix);\t\tstd::ostringstream ss; ss &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::setw(3) &lt;&lt; i; name += ss.str();\t\tname += ext;\t\tstd::cout &lt;&lt; name &lt;&lt; std::endl;\t\timgs.push_back(name);\t&#125;\t// Create feature tracker instance\tcv::Ptr&lt;cv::TrackerMedianFlow&gt; ptr= cv::TrackerMedianFlow::createTracker();\tVisualTracker tracker(ptr);\t// VisualTracker tracker(cv::TrackerKCF::createTracker());\t// Open video file\tprocessor.setInput(imgs);\t// set frame processor\tprocessor.setFrameProcessor(&amp;tracker);\t// Declare a window to display the video\tprocessor.displayOutput(&quot;Tracked object&quot;);\t// Define the frame rate for display\tprocessor.setDelay(50);\t// Specify the original target position\tcv::Rect bb(290, 100, 65, 40);\ttracker.setBoundingBox(bb);\t// Start the tracking\tprocessor.run();\tcv::waitKey();\t// Illustration of the Median Tracker principle\tcv::Mat image1 = cv::imread(&quot;goose/goose130.bmp&quot;, cv::ImreadModes::IMREAD_GRAYSCALE);\t// define a regular grid of points\tstd::vector&lt;cv::Point2f&gt; grid;\tfor (int i = 0; i &lt; 10; i++) &#123;\t\tfor (int j = 0; j &lt; 10; j++) &#123;\t\t\tcv::Point2f p(bb.x+i*bb.width/10.,bb.y+j*bb.height/10);\t\t\tgrid.push_back(p);\t\t&#125;\t&#125;\t// track in next image\tcv::Mat image2 = cv::imread(&quot;goose/goose131.bmp&quot;, cv::ImreadModes::IMREAD_GRAYSCALE);\tstd::vector&lt;cv::Point2f&gt; newPoints;\tstd::vector&lt;uchar&gt; status; // status of tracked features\tstd::vector&lt;float&gt; err;    // error in tracking\t// track the points\tcv::calcOpticalFlowPyrLK(image1, image2, // 2 consecutive images\t\tgrid,      // input point position in first image\t\tnewPoints, // output point postion in the second image\t\tstatus,    // tracking success\t\terr);      // tracking error\t// Draw the points\tfor (cv::Point2f p : grid) &#123;\t\tcv::circle(image1, p, 1, cv::Scalar(255, 255, 255), -1);\t&#125;\tcv::imshow(&quot;Initial points&quot;, image1);\tfor (cv::Point2f p : newPoints) &#123;\t\tcv::circle(image2, p, 1, cv::Scalar(255, 255, 255), -1);\t&#125;\tcv::imshow(&quot;Tracked points&quot;, image2);\tcv::waitKey();&#125;\n\n\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (用形态学运算变换图像)","url":"/2021/08/05/OPENCV1-9/","content":"数学形态学！？！？！\n\nrecommendation: https://blog.csdn.net/keen_zuxwang/article/details/72768092?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162806274916780264097167%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162806274916780264097167&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-72768092.first_rank_v2_pc_rank_v29&amp;utm_term=morphologyex&amp;spm=1018.2226.3001.4187\nmooc视频（较为系统的介绍）：https://www.icourse163.org/learn/HDU-1461554161?tid=1464982447#/learn/content?type=detail&amp;id=1243646733&amp;cid=1267148615&amp;replay=true\n基本概念\n\n形态学滤波器通常用于二值图像。且在形态学中，我们习惯用高像素值（白）表示前景物体，低像素值（黑）表示背景物体，因此对图像做了反向处理。（反向处理后的图像称为原二值图像的 补码 ）\n\n形态学滤波器 —— 腐蚀和膨胀滤波器的作用范围是由结构元素定义的像素集。在某个像素上应用结构元素时，结构元素的锚点与该像素对齐，所有与结构元素相交的像素就包含在当前集合中。腐蚀 就是把当前像素替换成所定义像素集合中的最小像素值，膨胀 就是把当前像素替换成所定义像素集合中的最大像素值。\nint main()&#123;\t// Read input image\tcv::Mat image= cv::imread(&quot;binary.bmp&quot;);\tif (!image.data)\t\treturn 0;     // Display the image\tcv::namedWindow(&quot;Image&quot;);\tcv::imshow(&quot;Image&quot;,image);\t// Erode the image\t// with the default 3x3 structuring element (SE)\tcv::Mat eroded; // the destination image\tcv::erode(image,eroded,cv::Mat());    // Display the eroded image\tcv::namedWindow(&quot;Eroded Image&quot;);\tcv::imshow(&quot;Eroded Image&quot;,eroded);\t// Dilate the image\tcv::Mat dilated; // the destination image\tcv::dilate(image,dilated,cv::Mat());    // Display the dilated image\tcv::namedWindow(&quot;Dilated Image&quot;);\tcv::imshow(&quot;Dilated Image&quot;,dilated);\t    return 0;&#125;\nOpenCV 默认使用 3*3 正方形结构元素，将第三个元素指定为空矩阵。也可自定义正方形大小。\n// Erode the image with a larger SE// create a 7x7 mat with containing all 1scv::Mat element(7,7,CV_8U,cv::Scalar(1));// erode the image with that SEcv::erode(image,eroded,element);// Display the eroded imagecv::namedWindow(&quot;Eroded Image (7x7)&quot;);cv::imshow(&quot;Eroded Image (7x7)&quot;,eroded);\n除了改变结构元素的大小，还可以改变应用一个结构元素的次数。\n// Erode the image 3 times.cv::erode(image,eroded,cv::Mat(),cv::Point(-1,-1),3);// Display the eroded imagecv::namedWindow(&quot;Eroded Image (3 times)&quot;);cv::imshow(&quot;Eroded Image (3 times)&quot;,eroded);\nPoint(-1, -1) 表示原点是矩阵的中心点（默认），也可以定义在结构元素上的其他位置。\n形态学滤波器 —— 开启和闭合图像闭合 ：对图像先膨胀后腐蚀\n// Close the imagecv::Mat element5(5,5,CV_8U,cv::Scalar(1));cv::Mat closed;cv::morphologyEx(image,closed,    // input and output images                 cv::MORPH_CLOSE, // operator code\t             element5);       // structuring element// Display the closed imagecv::namedWindow(&quot;Closed Image&quot;);cv::imshow(&quot;Closed Image&quot;,closed);// explicit closing// 1. dilate original imagecv::Mat result;cv::dilate(image, result, element5);// 2. in-place erosion of the dilated imagecv::erode(result, result, element5);// Display the closed imagecv::namedWindow(&quot;Closed Image (2)&quot;);cv::imshow(&quot;Closed Image (2)&quot;, result);\n5*5 的结构元素\n开启 ：先腐蚀后膨胀\n// Open the imagecv::Mat opened;cv::morphologyEx(image,opened,cv::MORPH_OPEN,element5);// Display the opened imagecv::namedWindow(&quot;Opened Image&quot;);cv::imshow(&quot;Opened Image&quot;,opened);// explicit openningcv::Mat result;// 1. in-place erosion of the dilated imagecv::erode(result, result, element5);// 2. dilate original imagecv::dilate(image, result, element5);// Display the opened imagecv::namedWindow(&quot;Opened Image (2)&quot;);cv::imshow(&quot;Opened Image (2)&quot;, result);\n注：开启和闭合运算是 幂等 的，所以重复开启或者闭合是没有作用的。\n应用形态学运算 —— 灰度图像形态学梯度运算 可以提取出图像边缘。\n// Read input image (gray-level)image = cv::imread(&quot;boldt.jpg&quot;,0);if (!image.data)\treturn 0;// Get the gradient image using a 3x3 structuring elementcv::morphologyEx(image, result, cv::MORPH_GRADIENT, cv::Mat());// Display the morphological edge imagecv::namedWindow(&quot;Edge Image&quot;);cv::imshow(&quot;Edge Image&quot;, 255 - result); // 反色处理，便于观察// Apply threshold to obtain a binary imageint threshold(80);cv::threshold(result, result, threshold, 255, cv::THRESH_BINARY);// Display the close/opened imagecv::namedWindow(&quot;Thresholded Edge Image&quot;);cv::imshow(&quot;Thresholded Edge Image&quot;, result);// Get the gradient image using a 3x3 structuring elementcv::morphologyEx(image, result, cv::MORPH_GRADIENT, cv::Mat());\n顶帽变换 可以从图像中提取出局部的小型前景物体\nimage = cv::imread(&quot;book.jpg&quot;, 0);if (!image.data)\treturn 0;// rotate the image for easier displaycv::transpose(image, image);cv::flip(image, image, 0);// Apply the black top-hat transform using a 7x7 structuring elementcv::Mat element7(7, 7, CV_8U, cv::Scalar(1));cv::morphologyEx(image, result, cv::MORPH_BLACKHAT, element7);// Display the top-hat imagecv::namedWindow(&quot;7x7 Black Top-hat Image&quot;);cv::imshow(&quot;7x7 Black Top-hat Image&quot;, 255-result);// Apply threshold to obtain a binary imagethreshold= 25;cv::threshold(result, result,\tthreshold, 255, cv::THRESH_BINARY);// Display the morphological edge imagecv::namedWindow(&quot;Thresholded Black Top-hat&quot;);cv::imshow(&quot;Thresholded Black Top-hat&quot;, 255 - result);// Apply the black top-hat transform using a 7x7 structuring elementcv::morphologyEx(image, result, cv::MORPH_CLOSE, element7);// Display the top-hat imagecv::namedWindow(&quot;7x7 Closed Image&quot;);cv::imshow(&quot;7x7 Closed Image&quot;, 255 - result);\n分水岭算法 —— 图像分割封装 WatershedSegmenter 类\n#if !defined WATERSHS#define WATERSHS#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;class WatershedSegmenter &#123;  private:\t  cv::Mat markers;  public:\t  void setMarkers(const cv::Mat&amp; markerImage) &#123;\t\t// Convert to image of ints\t\tmarkerImage.convertTo(markers,CV_32S);\t  &#125;\t  cv::Mat process(const cv::Mat &amp;image) &#123;\t\t// Apply watershed\t\tcv::watershed(image,markers);\t\treturn markers;\t  &#125;\t  // Return result in the form of an image\t  cv::Mat getSegmentation() &#123;\t\t  \t\tcv::Mat tmp;\t\t// all segment with label higher than 255\t\t// will be assigned value 255\t\tmarkers.convertTo(tmp,CV_8U);\t\treturn tmp;\t  &#125;\t  // Return watershed in the form of an image\t  cv::Mat getWatersheds() &#123;\t\t\tcv::Mat tmp;\t\tmarkers.convertTo(tmp,CV_8U,255,255);\t\treturn tmp;\t  &#125;&#125;;#endif\n步骤读取\n// Read input imagecv::Mat image= cv::imread(&quot;group.jpg&quot;);if (!image.data)\treturn 0; // Display the imagecv::namedWindow(&quot;Original Image&quot;);cv::imshow(&quot;Original Image&quot;,image);\n获得二值图像\n// Get the binary mapcv::Mat binary;binary= cv::imread(&quot;binary.bmp&quot;,0);// Display the binary imagecv::namedWindow(&quot;Binary Image&quot;);cv::imshow(&quot;Binary Image&quot;,binary);\n做深度腐蚀运算，只保留明显属于前景物体的像素\n// Eliminate noise and smaller objectscv::Mat fg;cv::erode(binary,fg,cv::Mat(),cv::Point(-1,-1),4);// Display the foreground imagecv::namedWindow(&quot;Foreground Image&quot;);cv::imshow(&quot;Foreground Image&quot;,fg);\n做大幅度膨胀，来选中一些背景像素\n// Identify image pixels without objectscv::Mat bg;cv::dilate(binary,bg,cv::Mat(),cv::Point(-1,-1),4);cv::threshold(bg,bg,1,128,cv::THRESH_BINARY_INV);// Display the background imagecv::namedWindow(&quot;Background Image&quot;);cv::imshow(&quot;Background Image&quot;,bg);\n合并这两幅图，得到标记图像\n// Show markers imagecv::Mat markers(binary.size(),CV_8U,cv::Scalar(0));markers= fg+bg;cv::namedWindow(&quot;Markers&quot;);cv::imshow(&quot;Markers&quot;,markers);\n创建分水岭分割类对象 并 进行分割\n// Create watershed segmentation objectWatershedSegmenter segmenter;// Set markers and processsegmenter.setMarkers(markers);segmenter.process(image);// Display segmentation resultcv::namedWindow(&quot;Segmentation&quot;);cv::imshow(&quot;Segmentation&quot;,segmenter.getSegmentation());\n以图像的方式返回分水岭\n// Display watershedscv::namedWindow(&quot;Watersheds&quot;);cv::imshow(&quot;Watersheds&quot;,segmenter.getWatersheds());\n另一种方法用户可以交互式地在场景中地物体和背景上绘制区域，以标注物体。\n如这幅图，在边缘位置（背景）与 中心位置（前景）分别标记\n\n// Open another imageimage= cv::imread(&quot;tower.jpg&quot;);// Identify background pixelscv::Mat imageMask(image.size(),CV_8U,cv::Scalar(0));cv::rectangle(imageMask,cv::Point(5,5),cv::Point(image.cols-5,image.rows-5),cv::Scalar(255),3);// Identify foreground pixels (in the middle of the image)cv::rectangle(imageMask,cv::Point(image.cols/2-10,image.rows/2-10),\t\t\t\t\t\t    cv::Point(image.cols/2+10,image.rows/2+10),cv::Scalar(1),10);// Set markers and processsegmenter.setMarkers(imageMask);segmenter.process(image);// Display the image with markerscv::rectangle(image,cv::Point(5,5),cv::Point(image.cols-5,image.rows-5),cv::Scalar(255,255,255),3);cv::rectangle(image,cv::Point(image.cols/2-10,image.rows/2-10),\t\t\t  cv::Point(image.cols/2+10,image.rows/2+10),cv::Scalar(1,1,1),10);cv::namedWindow(&quot;Image with marker&quot;);cv::imshow(&quot;Image with marker&quot;,image);// Display watershedscv::namedWindow(&quot;Watershed&quot;);cv::imshow(&quot;Watershed&quot;,segmenter.getWatersheds());\nMSER算法 —— 提取特征区域MSER 最大稳定外部区域\nint main()&#123;\t// Read input image\tcv::Mat image= cv::imread(&quot;building.jpg&quot;,0);\tif (!image.data)\t\treturn 0;     // Display the image\tcv::namedWindow(&quot;Image&quot;);\tcv::imshow(&quot;Image&quot;,image);\t\t// basic MSER detector\tcv::Ptr&lt;cv::MSER&gt; ptrMSER= cv::MSER::create(5,     // delta value for local minima detection\t\t                                        200,   // min acceptable area \t\t\t\t                                2000); // max acceptable area    // vector of point sets\tstd::vector&lt;std::vector&lt;cv::Point&gt; &gt; points;\t// vector of rectangles\tstd::vector&lt;cv::Rect&gt; rects;\t// detect MSER features\tptrMSER-&gt;detectRegions(image, points, rects);\tstd::cout &lt;&lt; points.size() &lt;&lt; &quot; MSERs detected&quot; &lt;&lt; std::endl;\n检测结果放在两个容器里。第一个是区域地容器，每个区域用组成它的像素点表示；第二个是矩形的容器，每个矩形包围一个区域。为了呈现效果，创建一个空白图像，在图像上用不同的颜色显示检测到的区域。\n// create white imagecv::Mat output(image.size(),CV_8UC3);output= cv::Scalar(255,255,255);// OpenCV random number generatorcv::RNG rng;// Display the MSERs in color areas// for each detected feature// reverse order to display the larger MSER first   for (std::vector&lt;std::vector&lt;cv::Point&gt; &gt;::reverse_iterator it= points.rbegin();\t\t   it!= points.rend(); ++it) &#123;\t// generate a random color\tcv::Vec3b c(rng.uniform(0,254),\t\t        rng.uniform(0,254),\t\t\t\trng.uniform(0,254));\tstd::cout &lt;&lt; &quot;MSER size= &quot; &lt;&lt; it-&gt;size() &lt;&lt; std::endl;\t// for each point in MSER set\tfor (std::vector&lt;cv::Point&gt;::iterator itPts= it-&gt;begin();\t\t                                  itPts!= it-&gt;end(); ++itPts) &#123;\t\t//do not overwrite MSER pixels\t\tif (output.at&lt;cv::Vec3b&gt;(*itPts)[0]==255) &#123;\t\t\toutput.at&lt;cv::Vec3b&gt;(*itPts)= c;\t\t&#125;\t&#125;&#125;cv::namedWindow(&quot;MSER point sets&quot;);cv::imshow(&quot;MSER point sets&quot;,output);cv::imwrite(&quot;mser.bmp&quot;, output);\n// Extract and display the rectangular MSERs\tstd::vector&lt;cv::Rect&gt;::iterator itr = rects.begin();\tstd::vector&lt;std::vector&lt;cv::Point&gt; &gt;::iterator itp = points.begin();\tfor (; itr != rects.end(); ++itr, ++itp) &#123;\t\t// ratio test\t\tif (static_cast&lt;double&gt;(itp-&gt;size())/itr-&gt;area() &gt; 0.6)\t\t\tcv::rectangle(image, *itr, cv::Scalar(255), 2);\t&#125;\t// Display the resulting image\tcv::namedWindow(&quot;Rectangular MSERs&quot;);\tcv::imshow(&quot;Rectangular MSERs&quot;, image);\n依据检测到的区域不能太细长（将封闭矩形旋转，计算高宽比），用封闭椭圆表示\n\t// Reload the input image\timage = cv::imread(&quot;building.jpg&quot;, 0);\tif (!image.data)\t\treturn 0;\t// Extract and display the elliptic MSERs\tfor (std::vector&lt;std::vector&lt;cv::Point&gt; &gt;::iterator it = points.begin();\t                                                    it != points.end(); ++it) &#123;\t\t// for each point in MSER set\t\tfor (std::vector&lt;cv::Point&gt;::iterator itPts = it-&gt;begin();\t\t                                      itPts != it-&gt;end(); ++itPts) &#123;\t\t\t// Extract bouding rectangles\t\t\tcv::RotatedRect rr = cv::minAreaRect(*it);            // check ellipse elongation\t\t\tif (rr.size.height / rr.size.height &gt; 0.6 || rr.size.height / rr.size.height &lt; 1.6)\t\t\t\tcv::ellipse(image, rr, cv::Scalar(255), 2);\t\t&#125;\t&#125;\t// Display the image\tcv::namedWindow(&quot;MSER ellipses&quot;);\tcv::imshow(&quot;MSER ellipses&quot;, image);\tcv::waitKey();&#125;\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (一些关于相机的知识)","url":"/2021/08/13/OPENCV2-0/","content":"开启学习 OpenCV 的新征程啦 ~ ~\n\n\n\n数字化坐标值称为采样，数字化幅度值称为量化\n\n\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (梳理)","url":"/2021/08/11/OPENCV1/","content":"一篇整理博客的博客\n\n在这里推荐一篇博客 ：https://qianmo.blog.csdn.net/article/details/19925819\n这篇博客中对 OpenCV 的各个模块和功能有个简单的介绍\n\n处理图像的颜色https://evaqwq.github.io/2021/08/11/OPENCV1-12/\n\n用形态学运算变换图像腐蚀、膨胀、开启、闭合、分水岭、MSERhttps://evaqwq.github.io/2021/08/05/OPENCV1-9/\n\n提取直线、轮廓 和 区域Canny、霍夫变换、直线拟合、提取连续区域、形状描述子https://evaqwq.github.io/2021/08/09/OPENCV1-10/\n\n检测兴趣点检测角点、快速检测特征、尺度不变特征的检测、多尺度FAST特征的检测https://evaqwq.github.io/2021/08/10/OPENCV1-11\n\n三维重建相机标定https://evaqwq.github.io/2021/07/31/OPENCV1-3/\n相机姿态还原https://evaqwq.github.io/2021/08/02/OPENCV1-4/\n用标定相机三维重建https://evaqwq.github.io/2021/08/02/OPENCV1-5/\n计算立体图像深度https://evaqwq.github.io/2021/08/04/OPENCV1-6/\n\n处理视频序列读取、处理、写入、提取前景物体https://evaqwq.github.io/2021/08/04/OPENCV1-7/\n\n跟踪运动目标跟踪特征点、估算光流、跟踪物体https://evaqwq.github.io/2021/08/04/OPENCV1-8/\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (几何变换)","url":"/2021/08/13/OPENCV2-1/","content":"一张图，一下午，一群人，还是不完全懂！\n\n齐次坐标由于无穷远直线的介入，我们通常的  上的坐标  已经不足以表示射影平面的所有点了，因此我们要对坐标进行改进。\n我们就把这个新改进的坐标  叫做 齐次坐标。\n之所以叫做齐次坐标，因为它还有一个很重要的原因就是 ​ 和 ​ 表示的是同一个点（因为两个坐标确定的直线相同）。换句话说，对于通常点（非无穷远点）而言，我也可以用非齐次坐标 ​ 与之对应。\n仿射变换平移变换\n\\begin{cases}\nx ^ {'} = x\\ +\\ T_x\\\\\ny ^ {'} = y\\ +\\ T_y\\\\\n\\end{cases}\\ \\Rightarrow\\ \n\\begin{bmatrix}\nx^{'} & y^{'} & 1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nx & y & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 1\n\\\\\n0 & 1 & 0\n\\\\\nT_x & T_y & 1  \n\\end{bmatrix}比例放缩\n\\begin{cases}\nx ^ {'} = x S_x\n\\\\\ny ^ {'} = y S_y\n\\\\\n\\end{cases}\n\\ \n\\Rightarrow\n\\ \n\\begin{bmatrix}\nx^{'} & y^{'} & 1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nx & y & 1\n\\end{bmatrix}\n\n\\begin{bmatrix}\nS_x & 0 & 1\n\\\\\n0 & S_y & 0\n\\\\\n0 & 0 & 1  \n\\end{bmatrix}旋转\n\n\\begin{bmatrix}\nx^{'} & y^{'} & 1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nx & y & 1\n\\end{bmatrix}\n\n\\begin{bmatrix}\ncos{\\theta} & sin{\\theta} & 0\n\\\\\n-sin{\\theta} & cos{\\theta} & 0\n\\\\\n0 & 0 & 1  \n\\end{bmatrix}剪切变换\n\\begin{bmatrix}\nx^{'} & y^{'} & 1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nx & y & 1\n\\end{bmatrix}\n\n\\begin{bmatrix}\n1 & b & 0\n\\\\\nd & 1 & 0\n\\\\\n0 & 0 & 1  \n\\end{bmatrix}投影变换放射变换：保长度与角度\n投影变换：无上述性质\n\n接着，让我们来进入正题吧！\n二维图像的几何运算矩阵\n 都比较好理解\n ​ 这个部分，是 ，，​，相当于沿 ， 方向平移\n因为没有学过 射影几何 对于  还不知道应该如何理解比较好\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (从头开始写代码)","url":"/2021/08/16/OPENCV2-2/","content":"不忘初心，方得始终，念念不忘，必有回响 —— 《杭高语录》\n\n头文件#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;oprencv2/highgui.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;\nOpenCV库 分为多个模块：\nopencv_core 模块包含库的核心功能；\nopencv_imgproc 模块包含主要的图像处理函数；\nopencv_highgui 模块提供了读写图像和视频的函数以及一些用户交互函数。\n图片基操首先，需要确认调试属性为 Debug x64\n装载、显示\n#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main() &#123;\t\tstring path = &quot;D:/Summer Holiday Practice/opencv learning/Resources/OpenCVBook/puppy.bmp&quot;;\tMat image = imread(path);\tif (image.empty()) &#123;\t\tcout &lt;&lt; &quot;Read Fail ! ! !&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\tcout &lt;&lt; &quot;This image is &quot; &lt;&lt; image.rows &lt;&lt; &quot; x &quot; &lt;&lt; image.cols &lt;&lt; endl;\tnamedWindow(&quot;Original Image&quot;);\timshow(&quot;Original Image&quot;, image);\twaitKey(0);\treturn 0;&#125;\n\n水平翻转、垂直翻转#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main() &#123;\t\tstring path = &quot;D:/Summer Holiday Practice/opencv learning/Resources/OpenCVBook/puppy.bmp&quot;;\tMat image = imread(path);\tif (image.empty()) &#123;\t\tcout &lt;&lt; &quot;Read Fail ! ! !&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\tnamedWindow(&quot;Original Image&quot;);\timshow(&quot;Original Image&quot;, image);\tMat result1, result2;\tflip(image, result1, 1);\tflip(image, result2, 0);\tnamedWindow(&quot;Result 1&quot;);\tnamedWindow(&quot;Result 2&quot;);\timshow(&quot;Result 1&quot;, result1);\timshow(&quot;Result 2&quot;, result2);\twaitKey(0);\treturn 0;&#125;\n\n存储我的结果保存在 C:\\Users\\15595\\source\\repos\\Practice (Practice 是工程的名字)\n#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main() &#123;\t\tstring path = &quot;D:/Summer Holiday Practice/opencv learning/Resources/OpenCVBook/puppy.bmp&quot;;\tMat image = imread(path);\tif (image.empty()) &#123;\t\tcout &lt;&lt; &quot;Read Fail ! ! !&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\tnamedWindow(&quot;Original Image&quot;);\timshow(&quot;Original Image&quot;, image);\tMat result1;\tflip(image, result1, 1);\tnamedWindow(&quot;Result 1&quot;);\timwrite(&quot;Result.jpg&quot;, result1);\timshow(&quot;Result 1&quot;, result1);\twaitKey(0);\treturn 0;&#125;\nimwrite 函数要写明写入的格式，.jpg .tiff…\n\n转换成灰度图#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main() &#123;\t\tstring path = &quot;D:/Summer Holiday Practice/opencv learning/Resources/OpenCVBook/puppy.bmp&quot;;\tMat image = imread(path);\tif (image.empty()) &#123;\t\tcout &lt;&lt; &quot;Read Fail ! ! !&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\tcout &lt;&lt; &quot;0&quot; &lt;&lt; endl;\tMat grayImg;\tcvtColor(image, grayImg, COLOR_BGR2GRAY);\tnamedWindow(&quot;Original&quot;);\tnamedWindow(&quot;Gray&quot;);\timshow(&quot;Original&quot;, image);\timshow(&quot;Gray&quot;, grayImg);\twaitKey(0);\treturn 0;&#125;\n\n绘制基本形状#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main() &#123;\t\tstring path = &quot;D:/Summer Holiday Practice/opencv learning/Resources/OpenCVBook/puppy.bmp&quot;;\tMat image = imread(path);\tif (image.empty()) &#123;\t\tcout &lt;&lt; &quot;Read Fail ! ! !&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\tcircle(image, Point(155, 110), 65, 0, 3);\tputText(image, &quot;This is a dog.&quot;, Point(40, 200), FONT_HERSHEY_PLAIN, 2.0, 255, 2);\tnamedWindow(&quot;Original&quot;);\timshow(&quot;Original&quot;, image);\twaitKey(0);\treturn 0;&#125;\n\n复制浅复制和计数引用：图像赋值，图像指向同一个内存块。\n深复制：copyTo / convertTo\n定义感兴趣区域（给图片加一个logo吧！）\n #include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main() &#123;\tstring path = &quot;D:/Summer Holiday Practice/opencv learning/Resources/OpenCVBook/puppy.bmp&quot;;\tMat image = imread(path);\tif (image.empty()) &#123;\t\tcout &lt;&lt; &quot;Read Fail ! ! !&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\tMat logo = cv::imread(&quot;D:/Summer Holiday Practice/opencv learning/Resources/OpenCVBook/smalllogo.png&quot;);\tMat imageROI(image, Rect(image.cols - logo.cols, image.rows - logo.rows, logo.cols, logo.rows));\tlogo.copyTo(imageROI);\tnamedWindow(&quot;Original&quot;);\timshow(&quot;Original&quot;, image);\twaitKey(0);\treturn 0;&#125;\n\n使用图像掩码（刚刚的logo黑一片，丑丑）\n#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main() &#123;\tstring path = &quot;D:/Summer Holiday Practice/opencv learning/Resources/OpenCVBook/puppy.bmp&quot;;\tMat image = imread(path);\tif (image.empty()) &#123;\t\tcout &lt;&lt; &quot;Read Fail ! ! !&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\tMat logo = cv::imread(&quot;D:/Summer Holiday Practice/opencv learning/Resources/OpenCVBook/smalllogo.png&quot;);\tMat imageROI = image(cv::Rect(image.cols - logo.cols, image.rows - logo.rows,logo.cols, logo.rows));\tMat mask(logo);\tlogo.copyTo(imageROI, mask);\tnamedWindow(&quot;Original&quot;);\timshow(&quot;Original&quot;, image);\twaitKey(0);\treturn 0;&#125;\n\n原理掩码试一个8位图像，如果掩码中某个位置的值不为0，在这个位置上的操作就会起作用，如果掩码中某些像素的值为0，那么对图像中相应位置的操作将不起作用。\n在上面的代码中，在调用 copyTo 时，使用掩码，可以只复制标志中白色的部分。\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (Edition.4.换Edition3. & contrib库)","url":"/2021/08/23/OPENCV2-3/","content":"论有大佬引路的重要性！！！\n\n推两篇blog\ncontrib: https://blog.csdn.net/weijifen000/article/details/93377143\nEdition Change: https://blog.csdn.net/qq_27278957/article/details/108224325\ndebug x64 模式下需要的 .lib\nopencv_aruco3415d.lib\nopencv_bgsegm3415d.lib\nopencv_bioinspired3415d.lib\nopencv_xphoto3415d.lib\nopencv_xobjdetect3415d.lib\nopencv_ximgproc3415d.lib\nopencv_xfeatures2d3415d.lib\nopencv_videostab3415d.lib\nopencv_videoio3415d.lib\nopencv_video3415d.lib\nopencv_tracking3415d.lib\nopencv_text3415d.lib\nopencv_surface_matching3415d.lib\nopencv_superres3415d.lib\nopencv_structured_light3415d.lib\nopencv_stitching3415d.lib\nopencv_stereo3415d.lib\nopencv_shape3415d.lib\nopencv_saliency3415d.lib\nopencv_rgbd3415d.lib\nopencv_reg3415d.lib\nopencv_plot3415d.lib\nopencv_photo3415d.lib\nopencv_phase_unwrapping3415d.lib\nopencv_optflow3415d.lib\nopencv_objdetect3415d.lib\nopencv_ml3415d.lib\nopencv_line_descriptor3415d.lib\nopencv_imgproc3415d.lib\nopencv_imgcodecs3415d.lib\nopencv_img_hash3415d.lib\nopencv_highgui3415d.lib\nopencv_hfs3415d.lib\nopencv_fuzzy3415d.lib\nopencv_flann3415d.lib\nopencv_features2d3415d.lib\nopencv_face3415d.lib\nopencv_dpm3415d.lib\nopencv_dnn3415d.lib\nopencv_dnn_objdetect3415d.lib\nopencv_datasets3415d.lib\nopencv_core3415d.lib\nopencv_ccalib3415d.lib\nopencv_calib3d3415d.lib\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (代码目录)","url":"/2021/08/03/OPENCVcodesToc/","content":"搬！\n\nChapter01\nChapter02s\nChapter03\nChapter04\nChapter05\nChapter06\nChapter07\nChapter08\nChapter09\nChapter10\nChapter11\nChapter12\nChapter13\nChapter14\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (背景单一小球视频跟踪)","url":"/2021/07/29/OpenCVProject1/","content":"小作业—视频跟踪\n\n  我们录制了一段视频，视频内容如下：\n一个红色（可能是橙色……）的小球，从地上滚过去\n视频特征：1. 背景单一 2. 要捕捉的对象与背景具有明显的颜色差别\n学长的初步代码终于能跑起来了！！！\n#include &quot;opencv2/opencv.hpp&quot;#include &quot;opencv2/video/background_segm.hpp&quot;#include&lt;iostream&gt;using namespace std;using namespace cv;void main() &#123;\t\tVideoCapture video(&quot;D:/Summer Holiday Practice/opencv learning/Resources/tast.mp4&quot;);\t\tint frameNum = 1;\t\tMat frame, mask, thresholdImage, output;\t\tif (!video.isOpened())\t\t\tcout &lt;&lt; &quot;fail to open!&quot; &lt;&lt; endl;\t\t//cout&lt;&lt;video.isOpened();\t\tdouble totalFrameNumber = video.get(CAP_PROP_FRAME_COUNT);\t\tvideo &gt;&gt; frame;\t\tPtr&lt;BackgroundSubtractorMOG2&gt; bgsubtractor = createBackgroundSubtractorMOG2();\t\tbgsubtractor-&gt;setVarThreshold(20);\t\twhile (true) &#123;\t\t\tif (totalFrameNumber == frameNum)\t\t\t\tbreak;\t\t\tvideo &gt;&gt; frame;\t\t\t++frameNum;\t\t\t//bgSubtractor(frame, mask, 0.001);\t\t\tbgsubtractor-&gt;apply(frame, mask, 0.01);\t\t\timshow(&quot;mask&quot;, mask);\t\t\twaitKey(10);\t\t&#125;&#125;\n学长的最终代码\n学长不愧是学长，太巨了！！！！\n#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;iostream&gt;#include&lt;opencv2/core.hpp&gt;\tusing namespace std;using namespace cv;/// &lt;summary&gt;/// Project 1/// 使用HSV空间检测颜色、找到轮廓所在位置、取轮廓的位置然后创建一个圆/// &lt;/summary&gt;Mat img;vector&lt;vector&lt;int&gt;&gt; newPoints;vector&lt;vector&lt;int&gt;&gt; myColors&#123; &#123;0,87,54,15,205,245&#125;,//橙色（hmin smin vmin hmax smax vmax）\t\t\t\t\t\t\t\t&#123;0,0,0,0,0,0&#125; &#125;;//绿色（hmin smin vmin hmax smax vmax）vector&lt;Scalar&gt; myColorValues&#123; &#123;255,0,255&#125;,//蓝色\t\t\t\t\t\t\t\t&#123;0,255,0&#125; &#125;;//绿色//! 获取轮廓Point getContours(Mat imgDil) &#123;//imgDil是传入的扩张边缘的图像用来查找轮廓，img是要在其上绘制轮廓的图像\tvector&lt;vector&lt;Point&gt;&gt; contours;//轮廓检测到的轮廓。每个轮廓线存储为一个点的向量\tvector&lt;Vec4i&gt; hierarchy;//包含关于映像拓扑的信息  typedef Vec&lt;int, 4&gt; Vec4i;具有4个整数值\t//在二值图像中查找轮廓。该函数利用该算法从二值图像中提取轮廓\tfindContours(imgDil, contours, hierarchy, RETR_LIST, CHAIN_APPROX_SIMPLE);\t//drawContours(img, contours, -1, Scalar(255, 0, 255), 2);//img：要绘制轮廓在什么图片上，contours：要绘制的轮廓，-1定义要绘制的轮廓号（-1表示所有轮廓），Saclar表示轮廓颜色，2表示厚度\t\tvector&lt;vector&lt;Point&gt;&gt; conPoly(contours.size());//conploy的数量应小于contours\tvector&lt;Rect&gt; boundRect(contours.size());\tPoint myPoint(0, 0);\t//过滤器：通过轮廓面积来过滤噪声\tfor (int i = 0; i &lt; contours.size(); i++) &#123;//遍历检测到的轮廓\t\tint area = contourArea(contours[i]);\t\t\t\t//cout &lt;&lt; area &lt;&lt; endl;\t\tstring objectType;\t\tif (area &gt; 1000) &#123;//轮廓面积＞1000才绘制\t\t\t//计算轮廓周长或凹坑长度。该函数计算了曲线长度和封闭的周长。\t\t\tfloat peri = arcLength(contours[i], true);//计算封闭轮廓周长\t\t\tapproxPolyDP(contours[i], conPoly[i], 0.02 * peri, true);//以指定的精度近似多边形曲线。第二个参数conPloy[i]存储近似的结果，是输出。\t\t\tboundRect[i] = boundingRect(conPoly[i]);//计算边界矩形\t\t\tmyPoint.x = boundRect[i].x;\t\t\tmyPoint.y = boundRect[i].y + boundRect[i].height / 2;\t\t\tif (conPoly[i].size() &gt; 4)\t\t\t\tputText(img, &quot;Small Ball&quot;, Point(boundRect[i].x, boundRect[i].y - 10), FONT_HERSHEY_PLAIN ,3 , Scalar(0, 255, 0), 6);\t\t\t/*绘制边界矩形*/\t\t\trectangle(img, boundRect[i].tl(), boundRect[i].br(), Scalar(0, 255, 0), 5);//tl()：topleft矩形左上角坐标 br()：bottom right矩形右下角坐标\t\t\tdrawContours(img, conPoly, i, Scalar(255, 0, 0), 2);\t\t&#125;\t&#125;\treturn myPoint;&#125;vector&lt;vector&lt;int&gt;&gt; findColor(Mat img) &#123;\tMat imgHSV;\tcvtColor(img, imgHSV, COLOR_BGR2HSV);//转换图像到HSV空间，在其中查找颜色更加容易\tfor (int i = 0; i &lt; myColors.size(); i++)\t&#123;\t\tScalar lower(myColors[i][0], myColors[i][1], myColors[i][2]);\t\tScalar upper(myColors[i][3], myColors[i][4], myColors[i][5]);\t\tMat mask;\t\tinRange(imgHSV, lower, upper, mask);//定义颜色下限和上限，因为由于照明和不同的阴影，颜色的值将不完全相同，会是一个值的范围\t\t//imshow(to_string(i), mask);\t\tPoint myPoint=getContours(mask);\t\tif (myPoint.x != 0 &amp;&amp; myPoint.y != 0) &#123;//没检测到东西的时候就不加入新点\t\t\tnewPoints.push_back(&#123; myPoint.x,myPoint.y,i &#125;);//i为颜色索引\t\t&#125;\t&#125;\treturn newPoints;\t&#125;void drawOnCanvas(vector&lt;vector&lt;int&gt;&gt; newPoints, vector&lt;Scalar&gt; myColorValues) &#123;\tfor (int i = 1; i &lt; newPoints.size(); i++) &#123;\t\tline(img, Point(newPoints[i - 1][0], newPoints[i - 1][1]), Point(newPoints[i][0], newPoints[i][1]), Scalar(0, 255, 255), 10);\t&#125;&#125;void main() &#123;\tVideoCapture cap(&quot;Resources/task.mp4&quot;);//相机id=0\tchar c;\tbool stop = false;\tnamedWindow(&quot;Image&quot;, WINDOW_FREERATIO);\twhile (c = waitKey(1))\t&#123;\t\tif (c == 27)\t\t\tbreak;\t\tif (c == &#x27;p&#x27;)\t\t&#123;\t\t\tstop = !stop;\t\t&#125;\t\tif (!stop)\t\t&#123;\t\t\tcap &gt;&gt; img;\t\t\tnewPoints = findColor(img);\t\t\tdrawOnCanvas(newPoints, myColorValues);\t\t\timshow(&quot;Image&quot;, img);\t\t&#125;\t&#125;&#125;\n我首先更改了视频读取的路径\nD:/Summer Holiday Practice/opencv learning/Resources/task2.mp4\n编译运行后，视频闪退了！？？！\n随后，调整了调试属性。平台从 x64活动 调整为 x64\n在我的电脑上最终代码如下\n#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;iostream&gt;#include&lt;opencv2/core.hpp&gt;\tusing namespace std;using namespace cv;/// &lt;summary&gt;/// Project 1/// 使用HSV空间检测颜色、找到轮廓所在位置、取轮廓的位置然后创建一个圆/// &lt;/summary&gt;Mat img;vector&lt;vector&lt;int&gt;&gt; newPoints;vector&lt;vector&lt;int&gt;&gt; myColors&#123; &#123;0,87,54,15,205,245&#125;,//橙色（hmin smin vmin hmax smax vmax）\t\t\t\t\t\t\t\t&#123;0,0,0,0,0,0&#125; &#125;;//绿色（hmin smin vmin hmax smax vmax）vector&lt;Scalar&gt; myColorValues&#123; &#123;255,0,255&#125;,//蓝色\t\t\t\t\t\t\t\t&#123;0,255,0&#125; &#125;;//绿色//! 获取轮廓Point getContours(Mat imgDil) &#123;//imgDil是传入的扩张边缘的图像用来查找轮廓，img是要在其上绘制轮廓的图像\tvector&lt;vector&lt;Point&gt;&gt; contours;//轮廓检测到的轮廓。每个轮廓线存储为一个点的向量\tvector&lt;Vec4i&gt; hierarchy;//包含关于映像拓扑的信息  typedef Vec&lt;int, 4&gt; Vec4i;具有4个整数值\t//在二值图像中查找轮廓。该函数利用该算法从二值图像中提取轮廓\tfindContours(imgDil, contours, hierarchy, RETR_LIST, CHAIN_APPROX_SIMPLE);\t//drawContours(img, contours, -1, Scalar(255, 0, 255), 2);//img：要绘制轮廓在什么图片上，contours：要绘制的轮廓，-1定义要绘制的轮廓号（-1表示所有轮廓），Saclar表示轮廓颜色，2表示厚度\tvector&lt;vector&lt;Point&gt;&gt; conPoly(contours.size());//conploy的数量应小于contours\tvector&lt;Rect&gt; boundRect(contours.size());\tPoint myPoint(0, 0);\t//过滤器：通过轮廓面积来过滤噪声\tfor (int i = 0; i &lt; contours.size(); i++) &#123;//遍历检测到的轮廓\t\tdouble area = contourArea(contours[i]);\t\t//cout &lt;&lt; area &lt;&lt; endl;\t\tstring objectType;\t\tif (area &gt; 1000) &#123;//轮廓面积＞1000才绘制\t\t\t//计算轮廓周长或凹坑长度。该函数计算了曲线长度和封闭的周长。\t\t\tdouble peri = arcLength(contours[i], true);//计算封闭轮廓周长\t\t\tapproxPolyDP(contours[i], conPoly[i], 0.02 * peri, true);//以指定的精度近似多边形曲线。第二个参数conPloy[i]存储近似的结果，是输出。\t\t\tboundRect[i] = boundingRect(conPoly[i]);//计算边界矩形\t\t\tmyPoint.x = boundRect[i].x;\t\t\tmyPoint.y = boundRect[i].y + boundRect[i].height / 2;\t\t\tif (conPoly[i].size() &gt; 4)\t\t\t\tputText(img, &quot;Small Ball&quot;, Point(boundRect[i].x, boundRect[i].y - 10), FONT_HERSHEY_PLAIN, 3, Scalar(0, 255, 0), 6);\t\t\t/*绘制边界矩形*/\t\t\trectangle(img, boundRect[i].tl(), boundRect[i].br(), Scalar(0, 255, 0), 5);//tl()：topleft矩形左上角坐标 br()：bottom right矩形右下角坐标\t\t\tdrawContours(img, conPoly, i, Scalar(255, 0, 0), 2);\t\t&#125;\t&#125;\treturn myPoint;&#125;vector&lt;vector&lt;int&gt;&gt; findColor(Mat img) &#123;\tMat imgHSV;\tcvtColor(img, imgHSV, COLOR_BGR2HSV);//转换图像到HSV空间，在其中查找颜色更加容易\tfor (int i = 0; i &lt; myColors.size(); i++)\t&#123;\t\tScalar lower(myColors[i][0], myColors[i][1], myColors[i][2]);\t\tScalar upper(myColors[i][3], myColors[i][4], myColors[i][5]);\t\tMat mask;\t\tinRange(imgHSV, lower, upper, mask);//定义颜色下限和上限，因为由于照明和不同的阴影，颜色的值将不完全相同，会是一个值的范围\t\t//imshow(to_string(i), mask);\t\tPoint myPoint = getContours(mask);\t\tif (myPoint.x != 0 &amp;&amp; myPoint.y != 0) &#123;//没检测到东西的时候就不加入新点\t\t\tnewPoints.push_back(&#123; myPoint.x,myPoint.y,i &#125;);//i为颜色索引\t\t&#125;\t&#125;\treturn newPoints;&#125;void drawOnCanvas(vector&lt;vector&lt;int&gt;&gt; newPoints, vector&lt;Scalar&gt; myColorValues) &#123;\tfor (int i = 1; i &lt; newPoints.size(); i++) &#123;\t\tline(img, Point(newPoints[i - 1][0], newPoints[i - 1][1]), Point(newPoints[i][0], newPoints[i][1]), Scalar(0, 255, 255), 10);\t&#125;&#125;int main() &#123;\tVideoCapture cap(&quot;D:/Summer Holiday Practice/opencv learning/Resources/tast.mp4&quot;);//相机id=0\tif (!cap.isOpened()) &#123;\t\tcout &lt;&lt; &quot;fail to open!&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\tchar c;\tbool stop = false;\tnamedWindow(&quot;Image&quot;, WINDOW_FREERATIO);\twhile (c = waitKey(1))\t&#123;\t\tif (c == 27)\t\t\tbreak;\t\tif (c == &#x27;p&#x27;)\t\t&#123;\t\t\tstop = !stop;\t\t&#125;\t\tif (!stop)\t\t&#123;\t\t\tcap &gt;&gt; img;\t\t\tnewPoints = findColor(img);\t\t\tdrawOnCanvas(newPoints, myColorValues);\t\t\timshow(&quot;Image&quot;, img);\t\t&#125;\t&#125;\treturn 0;&#125;\n\n\n代码跑起来了，就来认真学习一下学长的 “高级” 代码呐~\n解剖代码ing~\n全局变量Mat img;vector&lt;vector&lt;int&gt;&gt; newPoints;//HSV颜色空间vector&lt;vector&lt;int&gt;&gt; myColors&#123; &#123;0,87,54,15,205,245&#125;,//橙色（hmin smin vmin hmax smax vmax）\t\t\t\t\t\t\t\t&#123;0,0,0,0,0,0&#125; &#125;;//绿色（hmin smin vmin hmax smax vmax）//RGB颜色空间vector&lt;Scalar&gt; myColorValues&#123; &#123;255,0,255&#125;,//蓝色\t\t\t\t\t\t\t\t&#123;0,255,0&#125; &#125;;//绿色\n绘制void drawOnCanvas(vector&lt;vector&lt;int&gt;&gt; newPoints, vector&lt;Scalar&gt; myColorValues) &#123;\tfor (int i = 1; i &lt; newPoints.size(); i++) &#123;\t\tline(img, Point(newPoints[i - 1][0], newPoints[i - 1][1]), Point(newPoints[i][0], newPoints[i][1]), Scalar(0, 255, 255), 10);\t&#125;&#125;//把 newPoints[i- 1] 和 newPoints[i] 连起来\nline\nvoid line(Mat&amp; img, Point pt1, Point pt2, const Scalar&amp; color, int thickness=1, int lineType=8, int shift=0)//img 要绘制线段的图像//pt1 线段的起点//pt2 线段的终点//color 线段的颜色 Scalar对象定义//thickness 线条的宽度//lineType 线段的类型 8(默认)/4/CV_AA(高斯滤波)//shift 坐标点小数点位数\n颜色过滤 &amp; 寻找对象vector&lt;vector&lt;int&gt;&gt; findColor(Mat img) &#123;\tMat imgHSV;\tcvtColor(img, imgHSV, COLOR_BGR2HSV);//转换图像到HSV空间，在其中查找颜色更加容易\tfor (int i = 0; i &lt; myColors.size(); i++)\t&#123;\t\tScalar lower(myColors[i][0], myColors[i][1], myColors[i][2]);\t\tScalar upper(myColors[i][3], myColors[i][4], myColors[i][5]);\t\tMat mask;\t\tinRange(imgHSV, lower, upper, mask);//定义颜色下限和上限，因为由于照明和不同的阴影，颜色的值将不完全相同，会是一个值的范围\t\t//imshow(to_string(i), mask);\t\tPoint myPoint = getContours(mask);\t\tif (myPoint.x != 0 &amp;&amp; myPoint.y != 0) &#123;//没检测到东西的时候就不加入新点\t\t\tnewPoints.push_back(&#123; myPoint.x,myPoint.y,i &#125;);//i为颜色索引\t\t&#125;\t&#125;\treturn newPoints;//返回检测到物体轮廓的点集&#125;\nScalar\ntypedef struct Scalar&#123;    double val[4];&#125;Scalar;\n将各个通道的值构成一个整体\n\n越看代码越觉得眼熟，欢迎回到前面的博客（bilibili教程代码——project1）\n（我说怎么写代码写这么多注释……\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (学长走路背景)","url":"/2021/08/06/OpenCVProject2/","content":"小作业——继续跟踪\n\n这次的背景有一只学长路过\n\n所以不能用动态检测，只能用颜色检测啦！！！\n（ps. 动态检测是啥，其实我也没了解很多，我以为大家都在用颜色检测，后来才知道学长学姐上一个小作业是用动态检测的，所以问学长要了动态检测的代码\n#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/video/background_segm.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;const int Train = 50;int main()&#123;\tPtr&lt;BackgroundSubtractorMOG2&gt; mog = createBackgroundSubtractorMOG2(100, 25, false); // 背景消去 \t//bgsubtractor-&gt;setVarThreshold(20);\tMat foreGround;\tMat backGround;\tint trainCounter = 0;\tbool dynamicDetect = true;\tnamedWindow(&quot;src&quot;, WINDOW_FREERATIO);\tnamedWindow(&quot;foreground&quot;, WINDOW_FREERATIO);\tVideoCapture cap(&quot;Resources/task3.mp4&quot;); \tif (!cap.isOpened())\t&#123;\t\tcout &lt;&lt; &quot;Fail to open!&quot;&lt;&lt; endl;\t\treturn -1;\t&#125;\tMat src;\tMat kernel = getStructuringElement(MORPH_RECT, Size(3, 3)); // 开操作去噪声 \tbool stop = false;\twhile (!stop)\t&#123;\t\tcap &gt;&gt; src;\t\tif (src.empty())\t\t\tbreak;\t\tif (dynamicDetect)\t\t&#123;\t\t\tmog-&gt;apply(src, foreGround, 0.005);\t\t\tmorphologyEx(foreGround, foreGround, MORPH_OPEN, kernel);\t\t\t//图像处理过程\t\t\tmedianBlur(foreGround, foreGround, 3);\t\t\tdilate(foreGround, foreGround, Mat(), Point(-1, -1), 3);\t\t\terode(foreGround, foreGround, Mat(), Point(-1, -1), 6);\t\t\tdilate(foreGround, foreGround, Mat(), Point(-1, -1), 3);\t\t\timshow(&quot;foreground&quot;, foreGround);\t\t\tif (trainCounter &lt; Train)//训练期间所得结果为不准确结果，不应作为后续\t\t\t&#123;\t\t\t\tMat findc;\t\t\t\tforeGround.copyTo(findc);\t\t\t\tvector&lt;vector&lt;Point&gt;&gt; contours;\t\t\t\tfindContours(findc, contours, RETR_EXTERNAL, CHAIN_APPROX_NONE);        //寻找轮廓\t\t\t\t//targets.clear();\t\t\t\tconst int maxArea = 200;\t\t\t\tsize_t s = contours.size();\t\t\t\tfor (size_t i = 0; i &lt; s; i++)\t\t\t\t&#123;\t\t\t\t\tdouble area = abs(contourArea(contours[i]));\t\t\t\t\tif (area &gt; maxArea)\t\t\t\t\t&#123;\t\t\t\t\t\tRect mr = boundingRect(Mat(contours[i]));\t\t\t\t\t\trectangle(src, mr, Scalar(0, 0, 255), 2, 8, 0);\t\t\t\t\t\t//targets.push_back(mr);\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\t//string text;\t\t\t\t\t\t\t\t\tchar text[50];\t\t\t\tsprintf_s(text, &quot;background training -%d- ...&quot;, trainCounter);\t\t\t\tputText(src, text, Point(50, 50), 3, 1, Scalar(0, 255, 255), 2, 8, false);\t\t\t\t//delete[] text;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//detects.clear();\t\t\t\tMat findc;\t\t\t\tforeGround.copyTo(findc);\t\t\t\tvector&lt;vector&lt;Point&gt;&gt; contours;\t\t\t\tcv::findContours(findc, contours, RETR_EXTERNAL, CHAIN_APPROX_NONE);\t\t\t\tconst int maxArea = 200;\t\t\t\tsize_t s = contours.size();\t\t\t\tRNG rng;\t\t\t\t\tfor (size_t i = 0; i &lt; s; i++)\t\t\t\t\t&#123;\t\t\t\t\t\tdouble area = abs(contourArea(contours[i]));\t\t\t\t\t\tif (area &gt; maxArea)\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tScalar sca_color = Scalar(rng.uniform(0, 256), rng.uniform(0, 256), rng.uniform(0, 256));\t\t\t\t\t\t\tRect mr = boundingRect(Mat(contours[i]));\t\t\t\t\t\t\trectangle(src, mr, sca_color, 2, 8, 0);\t\t\t\t\t\t\t//可以对动态目标进行相应操作\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t&#125;\t\t\ttrainCounter++;\t\t&#125;\t\timshow(&quot;src&quot;, src);\t\tif (waitKey(30) == 27) //Esc键退出    \t\t&#123;\t\t\tstop = true;\t\t&#125;\t&#125;\treturn 0;&#125;\n另附相关资料\nhttps://blog.csdn.net/m0_37901643/article/details/72841289\n%完了动态检测，还是学习一波颜色检测吧 ~ ~\n冲冲冲！！！\nCode（根据之前颜色检测的代码来魔改\n首先 需要用 colorPicker 检测出需要检测的颜色的 HSV 三个分量的最大最小值。\n然后就可以改代码了\n#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;iostream&gt;#include&lt;opencv2/core.hpp&gt;\tusing namespace std;using namespace cv;Mat img;vector&lt;vector&lt;int&gt;&gt; newPoints;vector&lt;vector&lt;int&gt;&gt; myColors&#123; &#123;0,142,120,179,255,255&#125;, // 橙色（hmin smin vmin hmax smax vmax）\t\t\t\t\t\t\t\t&#123;0,0,0,0,0,0&#125; &#125;; // 绿色（hmin smin vmin hmax smax vmax）vector&lt;Scalar&gt; myColorValues&#123; &#123;255,0,255&#125;, // 蓝色\t\t\t\t\t\t\t\t&#123;0,255,0&#125; &#125;; // 绿色//! 获取轮廓Point getContours(Mat imgDil) &#123; // imgDil是传入的扩张边缘的图像用来查找轮廓，img是要在其上绘制轮廓的图像\tvector&lt;vector&lt;Point&gt;&gt; contours; // 轮廓检测到的轮廓。每个轮廓线存储为一个点的向量\tvector&lt;Vec4i&gt; hierarchy; // 包含关于映像拓扑的信息  typedef Vec&lt;int, 4&gt; Vec4i;具有4个整数值\t//在二值图像中查找轮廓。该函数利用该算法从二值图像中提取轮廓\tfindContours(imgDil, contours, hierarchy, RETR_LIST, CHAIN_APPROX_SIMPLE);\t//drawContours(img, contours, -1, Scalar(255, 0, 255), 2); // img：要绘制轮廓在什么图片上，contours：要绘制的轮廓，-1定义要绘制的轮廓号（-1表示所有轮廓），Saclar表示轮廓颜色，2表示厚度\tvector&lt;vector&lt;Point&gt;&gt; conPoly(contours.size()); // conploy的数量应小于contours\tvector&lt;Rect&gt; boundRect(contours.size());\tPoint myPoint(0, 0);\t//过滤器：通过轮廓面积来过滤噪声\tfor (int i = 0; i &lt; contours.size(); i++) &#123; // 遍历检测到的轮廓\t\tdouble area = contourArea(contours[i]);\t\t// cout &lt;&lt; area &lt;&lt; endl;\t\tstring objectType;\t\tif (area &gt; 10) &#123; // 轮廓面积＞10才绘制\t\t\t// 计算轮廓周长或凹坑长度。该函数计算了曲线长度和封闭的周长。\t\t\tdouble peri = arcLength(contours[i], true); // 计算封闭轮廓周长\t\t\tapproxPolyDP(contours[i], conPoly[i], 0.02 * peri, true); // 以指定的精度近似多边形曲线。第二个参数conPloy[i]存储近似的结果，是输出。\t\t\tboundRect[i] = boundingRect(conPoly[i]); // 计算边界矩形\t\t\tmyPoint.x = boundRect[i].x;\t\t\tmyPoint.y = boundRect[i].y + boundRect[i].height / 2;\t\t\tif (conPoly[i].size() &gt; 4)\t\t\t\tputText(img, &quot;Small Ball&quot;, Point(boundRect[i].x, boundRect[i].y - 10), FONT_HERSHEY_PLAIN, 3, Scalar(0, 255, 0), 6);\t\t\t/*绘制边界矩形*/\t\t\trectangle(img, boundRect[i].tl(), boundRect[i].br(), Scalar(0, 255, 0), 5); // tl()：topleft矩形左上角坐标 br()：bottom right矩形右下角坐标\t\t\tdrawContours(img, conPoly, i, Scalar(255, 0, 0), 2);\t\t&#125;\t&#125;\treturn myPoint;&#125;vector&lt;vector&lt;int&gt;&gt; findColor(Mat img) &#123;\tMat imgHSV;\tcvtColor(img, imgHSV, COLOR_BGR2HSV); // 转换图像到HSV空间，在其中查找颜色更加容易\tfor (int i = 0; i &lt; myColors.size(); i++)\t&#123;\t\tScalar lower(myColors[i][0], myColors[i][1], myColors[i][2]);\t\tScalar upper(myColors[i][3], myColors[i][4], myColors[i][5]);\t\tMat mask;\t\tinRange(imgHSV, lower, upper, mask); // 定义颜色下限和上限，因为由于照明和不同的阴影，颜色的值将不完全相同，会是一个值的范围\t\t// imshow(to_string(i), mask);\t\tPoint myPoint = getContours(mask);\t\tif (myPoint.x != 0 &amp;&amp; myPoint.y != 0) &#123; // 没检测到东西的时候就不加入新点\t\t\tnewPoints.push_back(&#123; myPoint.x,myPoint.y,i &#125;); // i为颜色索引\t\t&#125;\t&#125;\treturn newPoints;&#125;void drawOnCanvas(vector&lt;vector&lt;int&gt;&gt; newPoints, vector&lt;Scalar&gt; myColorValues) &#123;\tfor (int i = 1; i &lt; newPoints.size(); i++) &#123;\t\tline(img, Point(newPoints[i - 1][0], newPoints[i - 1][1]), Point(newPoints[i][0], newPoints[i][1]), Scalar(0, 255, 255), 10);\t&#125;&#125;int main() &#123;\tVideoCapture cap(&quot;D:/Summer Holiday Practice/opencv learning/Resources/TrackBall2.mp4&quot;);\tif (!cap.isOpened()) &#123;\t\tcout &lt;&lt; &quot;fail to open!&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\tchar c;\tbool stop = false;\tnamedWindow(&quot;Image&quot;, WINDOW_FREERATIO);\twhile (c = waitKey(1))\t&#123;\t\tif (c == 27)\t\t\tbreak;\t\tif (c == &#x27;p&#x27;)\t\t&#123;\t\t\tstop = !stop;\t\t&#125;\t\tif (!stop)\t\t&#123;\t\t\tcap &gt;&gt; img;\t\t\tnewPoints = findColor(img);\t\t\tdrawOnCanvas(newPoints, myColorValues);\t\t\timshow(&quot;Image&quot;, img);\t\t&#125;\t&#125;\treturn 0;&#125;\n追踪效果如图：\n\n学了点儿啥呢主要还是在 colorPicker 的使用上\nMat imgHSV, mask;int hmin = 0, smin = 0, vmin = 0;int hmax = 179, smax = 255, vmax = 255;void main() &#123;\tnamedWindow(&quot;Trackbars&quot;, (640, 200));\tcreateTrackbar(&quot;Hue Min&quot;, &quot;Trackbars&quot;, &amp;hmin, 179);\tcreateTrackbar(&quot;Hue Max&quot;, &quot;Trackbars&quot;, &amp;hmax, 179);\tcreateTrackbar(&quot;Sat Min&quot;, &quot;Trackbars&quot;, &amp;smin, 255);\tcreateTrackbar(&quot;Sat Max&quot;, &quot;Trackbars&quot;, &amp;smax, 255);\tcreateTrackbar(&quot;Val Min&quot;, &quot;Trackbars&quot;, &amp;vmin, 255);\tcreateTrackbar(&quot;Val Max&quot;, &quot;Trackbars&quot;, &amp;vmax, 255);\twhile (true) &#123;\t\tstring path = &quot;D:/Summer Holiday Practice/opencv learning/Resources/ball2.png&quot;;\t\tMat img = imread(path);\t\t/*//  转换单通道\t\tif (img.channels() == 4) &#123;\t\t\tcv::cvtColor(img, imgHSV, COLOR_BGRA2GRAY);\t\t&#125;\t\telse if (img.channels() == 3) &#123;\t\t\tcv::cvtColor(img, imgHSV, COLOR_BGR2GRAY);\t\t&#125;\t\telse if (img.channels() == 2) &#123;\t\t\tcv::cvtColor(img, imgHSV, COLOR_BGR5652GRAY);\t\t&#125;\t\telse if (img.channels() == 1) &#123;// 单通道的图片直接就不需要处理\t\t\timgHSV = img;\t\t&#125;\t\telse &#123; // 负数,说明图有问题 直接返回\t\t\treturn;\t\t&#125;*/\t\tcvtColor(img, imgHSV, COLOR_BGR2HSV);\t\tScalar lower(hmin, smin, vmin);\t\tScalar upper(hmax, smax, vmax);\t\tinRange(imgHSV, lower, upper, mask);\t\tcout &lt;&lt; hmin &lt;&lt; &#x27;,&#x27; &lt;&lt; smin &lt;&lt; &#x27;,&#x27; &lt;&lt; vmin &lt;&lt; &#x27;,&#x27; &lt;&lt; hmax &lt;&lt; &#x27;,&#x27; &lt;&lt; smax &lt;&lt; &#x27;,&#x27; &lt;&lt; vmax &lt;&lt; endl;\t\tnamedWindow(&quot;Image&quot;, WINDOW_NORMAL);\t\tnamedWindow(&quot;Image mask&quot;, WINDOW_NORMAL);\t\timshow(&quot;Image&quot;, img);\t\timshow(&quot;Image mask&quot;, mask);\t\twaitKey(1);\t&#125;&#125;\nPath一是路径书写上，我总是会遇到无法正常打开图片或者视频的情况，且大部分情况下，都与路径书写有关，也试过把相对路径改成绝对路径。\n经过实践后，只能说，答案如下， D:/Summer Holiday Practice/opencv learning/Resources/ball2.png \ncvtColor之前 cvtColor 一直报错，后来去找资料，资料上说 cvtColor 不能处理灰度图，上面代码中注释掉的那一段，是在判断图片的通道数，并进行转换。\n虽然我并不是因为这个原因，但这也是值得注意的一个地方吧。\n最终结果视频\n(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer1\"),\"autoplay\":true,\"hotkey\":true,\"preload\":\"metadata\",\"video\":{\"url\":\"/img/projectTracking2.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() \n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"PAT Autumn 2021","url":"/2021/09/25/PAT2021Autumn/","content":"刚Co老师打游戏，他说：“不试试，真的不知道自己其实还是挺厉害的。”\n确实，不试试，真的不知道也许以后还是有机会的吧。\n\n前情大概就是为了检验跟Co老师学习了几天的学习成果，和Co老师一起去传媒考了PAT。Co老师是 Top Level ，我是 Advanced Level 。Co老师满分了，但我只有63分。（虽然好像Co老师甲级也拿不到满分，因为第一题太坑了）但Co老师给我的两个目标还真就勉勉强强达到了：\n\n做出两道题\n及格\n\n\n题目Arrays and Linked Lists20分的题目，我只拿了13分。后来发现读错了题意……这题有一个坑点，后面会具体提到。\n题意对于数组  ，有  个元素，起始地址为  。每次一个询问 ，询问的是数组中下标为  的元素（即 ）的地址。题目会给几组数组，且分别给定每个数组的起始地址。\n例如，题目给了两个数组  和  。如果  （因为数组下标从  开始，所以是小于号），则返回  ；如果  且  ，则返回  ；如果  ，则输出Illegal Access。\n对于每次询问需要输出地址。且在最后打印有多少个数组被声明。\n扫盲！！！被声明！！！！\n需要注意的是，如果我们询问的区间包含了第  个数组，那么它和它前面所有的数组都是被声明过的。我考试的时候以为是询问涉及到了几个数组，最后就输出几。（这都有13分……）\n还有一个坑点，就是如果每次访问都是非法的，最后输出的不是  ，而是  。\n注意到这些坑点，这道题也没那么难了。\n代码#include &lt;bits/stdc++.h&gt;#define N 1000007using namespace std;inline int rd() {    int x = 0;    bool f = 0;    char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}int a[N], bl[N], sum, ans = 1;int main() {    int n = rd();    int m = rd();    for (int i = 1; i &lt;= n; ++i) {        int ad = rd();        int len = rd();        for (int j = 0; j &lt; len; ++j, ++sum) {            a[sum] = ad + j * 4; bl[sum] = i;         }    }    for (int i = 1; i &lt;= m; ++i) {        int x = rd();        if (x &gt;= sum) {puts(\"Illegal Access\"); continue;}        printf(\"%d\\n\", a[x]);        ans = max(ans, bl[x]);    }    printf(\"%d\\n\", ans);    return 0;}\nStack of Hats题意一摞帽子，帽子各有大小，从下到上给出各帽子的大小。一群人，编号从  到  ，每一个人需要按体重分配一顶帽子。\n输出帽子从上到下所配对的人的编号。\n思路我也不知道这题在考什么……瞎做。就排序，疯狂排序。\n开两个结构体数组，一个是帽子的，一个是人的。结构体里三个值，id 代表编号。帽子的编号最初代表上下关系，因为最后输出需要按帽子从上到下的顺序，把最下面的帽子编号为 ，最上面的编号为  ，后面存储了与它相对应的人的编号。number 代表排序后所在的位置。 value 对于帽子来说就是大小，对于人来说就是体重。\n先把两个结构体数组都按 value 值排序，记录 number ，对于帽子数组，还需再按 id 排序过。然后将帽子与人进行匹配，将人的 id 存储到帽子数组的 id 。最后按相应的顺序进行输出。\n代码#include &lt;bits/stdc++.h&gt;#define N 10007using namespace std;int n, k, num = 0;struct node{\tint number;\tint id;\tint value;}hat[N], person[N];inline int rd(){\tchar c = getchar();\tint x = 0;\twhile(!isdigit(c)) c = getchar();\twhile(isdigit(c)){\t\tx = x * 10 + c - '0';\t\tc = getchar();\t}\treturn x;}bool cmp1(node a, node b){\treturn a.value &gt; b.value;}bool cmp2(node a, node b){\treturn a.id &lt; b.id;}int main(){\tn = rd();\tfor(int i = 1; i &lt;= n; ++i){\t\that[i].id = i;\t\that[i].value = rd();\t}\tsort(hat + 1, hat + n + 1, cmp1);\tfor(int i = 1; i &lt;= n; ++i) hat[i].number = i;\tsort(hat + 1, hat + n + 1, cmp2);\tfor(int i = 1; i &lt;= n; ++i){\t\tperson[i].id = i;\t\tperson[i].value = rd();\t}\tsort(person + 1, person + n + 1, cmp1);\tfor(int i = 1; i &lt;= n; ++i) person[i].number = i;\tfor(int i = n; i &gt; 0; --i){\t\tfor(int j = 1; j &lt;= n; ++j){\t\t\tif(person[j].number == hat[i].number){\t\t\t\that[i].id = person[j].id;\t\t\t\tbreak;\t\t\t}\t\t}\t}\tprintf(\"%d\",hat[n].id);\tfor(int i = n - 1; i &gt; 0; --i){\t\tprintf(\" %d\", hat[i].id);\t}\treturn 0;}\nPlayground Exploration题意一个无向图有  个点， 条边。每次选择与当前点相连的点中编号最小的点进行移动，且每个点只能访问一次。问从哪个点开始移动，可到达的点数最多。输出这个点和可到达的点数。\n思路本来是想用邻接表存图的，但如果用邻接表我不知道怎么排序选择编号最小的点移动。 也不大，所以就用邻接矩阵了。\n因为每个点只能走一次，故用 vis 数组打标记。mxlen 存储最后的答案。枚举起点，dfs 计算路径长度。\n代码#include &lt;bits/stdc++.h&gt;#define N 107using namespace std;int n, m, mxlen, ans, vis[N], mx;int a[N][N];int rd(){\tchar c = getchar();\tint x = 0;\twhile(!isdigit(c)) c = getchar();\twhile(isdigit(c)){\t\tx = x * 10 + c - '0';\t\tc = getchar();\t}\treturn x;}int dfs(int x, int len){    if(mx &lt; len) mx = len;\tvis[x] = 1;\tfor(int i = 1; i &lt;= n; ++i){        if(!vis[i] &amp;&amp; a[x][i] == 1) dfs(i, len + 1);    }    return mx;}int main(){\tn = rd(); m = rd();\tfor(int i = 1; i &lt;= m; ++i){\t\tint u = rd(), v = rd();\t\ta[u][v] = 1;        a[v][u] = 1;\t}\tfor(int i = 1; i &lt;= n; ++i){        for(int j = 1; j &lt;= n; ++j) vis[j] = 0;        mx = 0;\t\tint t = dfs(i, 1);\t\tif(t &gt; mxlen){\t\t\tmxlen = t;\t\t\tans = i;\t\t}\t}\tprintf(\"%d %d\", ans, mxlen);\treturn 0;}\nSorted Cartesian Tree题意每个结点有两个值。 key 和 priority 。要求建一棵树满足以下条件：\n\n对于 priority 来说，这棵树是一个小顶堆。\n对于 key 来说，中序遍历得到的序列是增序。\n\n最后输出这一棵树的层次遍历，第一行是对应的 key 第二行是对应的 priority 。\n思路这就是我0分的题…… \n考试的时候连题目都没看懂…… 大概就是排序什么的，但没看懂是个什么顺序，考完试Co老师说这是顶级的第一题。\n首先根据要求 1，对于这棵树和这棵树的每一个子树来说，priority 最小的点一定是根。再根据要求 2，我们可以根据根的值，确定剩下的点在根的左子树上还是右子树上，这就是 divide 函数的作用。\n层次遍历其实就是 bfs 可以借助一个队列完成。\n温馨小提示：访问 vector 里面的东西可以用 [] 。\n代码#include &lt;bits/stdc++.h&gt;#define N 37using namespace std;inline int rd(){\t\tint x = 0;\tbool f = 0;\tchar c = getchar();\tfor(; !isdigit(c); c = getchar()) f |= (c == '-');\tfor(; isdigit(c); c = getchar()) x = x * 10 + c - '0';\treturn f ? -x : x;}struct node{\tint k, p;}a[N];int ls[N], rs[N];int divide(vector&lt;int&gt; s){\tif(s.empty()) return -1;\tint root = s[0];\tfor(auto i : s) \t\tif(a[i].p &lt; a[root].p) root = i;\tvector&lt;int&gt; l, r;\tfor(auto i : s)\t\tif(i == root) continue;\t\telse a[i].k &lt; a[root].k ? l.push_back(i): r.push_back(i);\tls[root] = divide(l);\trs[root] = divide(r);\treturn root;}vector&lt;int&gt; id;int main(){\tint n = rd();\tvector&lt;int&gt; s;\tfor(int i = 1; i &lt;= n; ++i){\t\ta[i].k = rd(); a[i].p = rd();\t\ts.push_back(i);\t}\tint Root = divide(s);\tqueue&lt;int&gt; q;\tq.push(Root);\twhile(!q.empty()){\t\tint t = q.front();\t\tq.pop();\t\tif(ls[t] != -1) q.push(ls[t]);\t\tif(rs[t] != -1) q.push(rs[t]);\t\tid.push_back(t);\t}\tprintf(\"%d\", a[id[0]].k);\tfor(int i = 1; i &lt; n; ++i) printf(\" %d\", a[id[i]].k);\tprintf(\"\\n%d\", a[id[0]].p);\tfor(int i = 1; i &lt; n; ++i) printf(\" %d\", a[id[i]].p);\treturn 0;}\n彩蛋因为Co老师比我早出考场大概两个小时，所以有时间去拍拍浙传，而我就只配盗图了。\n\n\n\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"Segment Tree","url":"/2022/02/17/Segment%20Tree/","content":"aba aba aba\n\n线段树啥是线段树嘞？\n咱先字面了解一下，线段树就是每个结点是一个线段的树，线段的本质可以理解为序列的区间。最常见的是数列序列。哦对，线段树是一棵二叉树。\n线段树有啥好嘞？ \n线段树一共有三个长处。\n\n线段树的树高是  级别。\n对于原始序列的任意一个子区间，都可以在线段树上找到数量在  级别且互不相交的区间的并。不超过  个节点：因为每一层最多选两个节点。\n总的节点个数为  \n\n模板题一洛谷 \n给一个数组，有以下操作\n\n给  和  ， \n给  和  ，询问  \n\n分解代码树的节点\nstruct node{  int ls, rs; //左右儿子编号  ll sum; //该节点代表的区间的区间和}c[N &lt;&lt; 1];\n更新当前节点区间和\ninline void pushup(int rt) {    c[rt].sum = c[c[rt].ls].sum + c[c[rt].rs].sum;}\n建树\ninline int newn(){    return ++tot; //从节点池里拿出来一个编号为 ++tot 的点（从 1 开始}void build(int &amp;rt, int l, int r){ //因为需要修改 rt 的真实值，所以传引用    if (rt == 0) rt = newn(); //rt == 0 说明当前需要从节点池里拿一个使用    if (l == r) {c[rt].sum = a[l]; return;} //叶子节点    build(c[rt].ls, l, mid); //建左树    build(c[rt].rs, mid + 1, r); //建右树    pushup(rt); //更新}\n解决操作一\nvoid upd(int rt, int l, int r, int x, int y) {    if (l == r) {c[rt].sum += y; return;} //因为我们只会往包含 x 的区间走，所以只需要判断 l == r，不需要 l == x &amp;&amp; r == x    if (x &lt;= mid) upd(c[rt].ls, l, mid, x, y); //x 在左边    else upd(c[rt].rs, mid + 1, r, x, y); //x 在右边    pushup(rt); //更新}\n解决操作二\nll query(int rt, int l, int r, int L, int R) {    if (L &lt;= l &amp;&amp; r &lt;= R) return c[rt].sum; //当前节点的区间被完全包含在询问区间里，所以当前区间的贡献就是当前区间的区间和    ll ans = 0; //记录当前节点的贡献    if (L &lt;= mid) ans += query(c[rt].ls, l, mid, L, R); //左儿子的贡献    if (R &gt; mid) ans += query(c[rt].rs, mid + 1, r, L, R); //右儿子的贡献    return ans;}\n完整的树#include&lt;bits/stdc++.h&gt;using namespace std;#define N 500007#define mid ((l + r) &gt;&gt; 1)typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}struct node{  int ls, rs;  ll sum;}c[N &lt;&lt; 1];int tot, rot, a[N];inline int newn(){    return ++tot;}inline void pushup(int rt) {    c[rt].sum = c[c[rt].ls].sum + c[c[rt].rs].sum;}void build(int &amp;rt, int l, int r){    if (rt == 0) rt = newn();    if (l == r) {c[rt].sum = a[l]; return;}    build(c[rt].ls, l, mid);    build(c[rt].rs, mid + 1, r);    pushup(rt);}void upd(int rt, int l, int r, int x, int y) {    if (l == r) {c[rt].sum += y; return;}    if (x &lt;= mid) upd(c[rt].ls, l, mid, x, y);    else upd(c[rt].rs, mid + 1, r, x, y);    pushup(rt);}ll query(int rt, int l, int r, int L, int R) {    if (L &lt;= l &amp;&amp; r &lt;= R) return c[rt].sum;    ll ans = 0;    if (L &lt;= mid) ans += query(c[rt].ls, l, mid, L, R);    if (R &gt; mid) ans += query(c[rt].rs, mid + 1, r, L, R);    return ans;}int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) a[i] = rd();    build(rot, 1, n);    for (int i = 1; i &lt;= m; ++i) {        int t = rd();        if (t == 1) {            int x = rd(), y = rd();            upd(rot, 1, n, x, y);        }        else {            int l = rd(), r = rd();            printf(\"%lld\\n\", query(rot, 1, n, l, r));        }    }    return 0;}\n位移线段树总结点数为  \n构造void pushup(int rt) {    SegTree[rt].val = SegTree[rt &lt;&lt; 1].val + SegTree[rt &lt;&lt; 1 | 1].val;}void build(int l, int r, int rt) {    if (l == r) {        SegTree[rt].val = a[l];        return;    }    //SegTree[rt].lazy = 0;    int m = (l + r) / 2;    build(l, m, rt &lt;&lt; 1);    build(m + 1, r, rt &lt;&lt; 1 | 1);    pushup(rt);}\n单点更新void update(int pos, int val, int l, int r, int rt) {    if (l == r) {        c[rt].val += val;        return;    }    int mid = (l + r) &gt;&gt; 1;    if (pos &lt;= mid) update(pos, val, l, m, rt &lt;&lt; 1);    else update(pos, val, m + 1, r, rt &lt;&lt; 1 | 1);    pushup(rt);}\n区间更新ll query(int rt, int l, int r, int L, int R) {    if (L &lt;= l &amp;&amp; r &lt;= R) return c[rt].sum;    ll ans = 0;    int mid = (l + r) &gt;&gt; 1;    //pushdown(rt, m - l + 1, r - m);    if (L &lt;= mid) ans += query(c[rt].ls, l, mid, L, R);    if (R &gt; mid) ans += query(c[rt].rs, mid + 1, r, L, R);    return ans;}\n延迟标记struct node {  int val, lazy;  };\n区间更新2void update(int rt, int l, int r, int L, int R, int val) {    if (L &lt;= l &amp;&amp; r &lt;= R) {        SegTree[rt].val += val * (r - l + 1);        SegTree[rt].lazy += val;        return;    }    int mid = (l + r) &gt;&gt; 1;    pushdown(rt, m - l + 1, r - m);    if (L &lt;= mid) update(c[rt].ls, l, mid, L, R, val);    if (R &gt; mid) update(c[rt].rs, mid + 1, r, L, R, val);    pushup(rt);}\nvoid pushdown(int rt, int ln, int rn) {//ln 左二子区间长度 rn 右儿子区间长度    if (SegTree[rt].lazy) {        SegTree[rt &lt;&lt; 1].lazy += SegTree[rt].lazy;        SegTree[rt &lt;&lt; 1 | 1].lazy += SegTree[rt].lazy;        SegTree[rt &lt;&lt; 1].val += SegTree[rt].lazy * ln;        SegTree[rt &lt;&lt; 1 | 1].val += SegTree[rt].lazy * rn;                SegTree[rt].lazy = 0;    }}\n延迟标记完整版struct node{  int ls, rs;  ll lazy, sum;}c[N &lt;&lt; 1];int totnode, rot, a[N], p;inline int newn(){    return ++totnode;}inline void pushup(int rt) {    c[rt].sum = (c[c[rt].ls].sum + c[c[rt].rs].sum) % p;}void build(int &amp;rt, int l, int r){    if (rt == 0) rt = newn();    if (l == r) {c[rt].sum = a[ran[l]]; return;}    int mid = (l + r) &gt;&gt; 1;    build(c[rt].ls, l, mid);    build(c[rt].rs, mid + 1, r);    pushup(rt);}void pushdown(int rt, int ln, int rn) {//ln 左二子区间长度 rn 右儿子区间长度    if (c[rt].lazy) {        c[c[rt].ls].lazy = (c[c[rt].ls].lazy + c[rt].lazy) % p;        c[c[rt].rs].lazy = (c[c[rt].rs].lazy + c[rt].lazy) % p;        c[c[rt].ls].sum = (c[c[rt].ls].sum + c[rt].lazy * ln % p) % p;        c[c[rt].rs].sum = (c[c[rt].rs].sum + c[rt].lazy * rn % p) % p;                c[rt].lazy = 0;    }}void update(int rt, int l, int r, int L, int R, int val) {    if (L &lt;= l &amp;&amp; r &lt;= R) {        c[rt].sum = (c[rt].sum + val * (r - l + 1)) % p;        c[rt].lazy = (c[rt].lazy  + val) % p;        return;    }    int mid = (l + r) &gt;&gt; 1;    pushdown(rt, mid - l + 1, r - mid);    if (L &lt;= mid) update(c[rt].ls, l, mid, L, R, val);    if (R &gt; mid) update(c[rt].rs, mid + 1, r, L, R, val);    pushup(rt);}inline ll query(int rt, int l, int r, int L, int R) {    if (L &lt;= l &amp;&amp; r &lt;= R) return c[rt].sum;    ll ans = 0;    int mid = (l + r) &gt;&gt; 1;    pushdown(rt, mid - l + 1, r - mid);    if (L &lt;= mid) ans = (ans + query(c[rt].ls, l, mid, L, R)) % p;    if (R &gt; mid) ans = (ans + query(c[rt].rs, mid + 1, r, L, R)) % p;    return ans;}","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"Shortest Path","url":"/2022/03/15/Shortest%20Path/","content":"继续跑图~\n\nDijstra的缺点不支持负权边, 单源\nFloyd支持负权边、多源、可求最长路\n        几百\n任意两个点之间\nint n = rd(), m = rd();for (int i = 1; i &lt;= n; ++i) {    e[i].u = rd(); e[i].v = rd();}for (int k = 1; k &lt;= n; ++k) { //枚举中间过渡点    for (int i = 1; i &lt;= n; ++i) {        for (int j = 1; j &lt;= n; ++j) {            if (dis[i][j] &gt; dis[i][k] + dis[k][j])                dis[i][j] = dis[i][k] + dis[k][j];        }    }}\nBellman-Ford        几千\n遍历所有的边\nfor (int k = 1; k &lt;= n - 1; ++k) {//    for (int i = 1; i &lt;= m; ++i) {//第i条边 起点：u[i] 终点：v[i]        if (dis[v[i]] &gt; dis[u[i]] + w[i])            dis[v[i]] = dis[u[i]] + w[i];    }}\n因为任意两个点之间的最短路，最多有  条边，所以只需要松弛  次\n检测负环for (int k = 1; k &lt;= n - 1; ++k) {//    for (int i = 1; i &lt;= m; ++i) {//第i条边 起点：u[i] 终点：v[i]        if (dis[v[i]] &gt; dis[u[i]] + w[i])            dis[v[i]] = dis[u[i]] + w[i];    }}int f = 0;for (int i = 1; i &lt;= m; ++i) {    if (dis[v[i]] &gt; dis[u[i]] + w[i]) f = 1;}if (f) cout &lt;&lt; \"There is a negative circle\" &lt;&lt; endl;\nSPFA Bellman-Ford的队列优化        是一个常数，在稀疏图中  \nqueue&lt;int&gt; q;int start = rd();q.push(start);dis[start] = 0;vis[start] = 1;while (!q.empty()) {    int x = q.front();    q.pop(); vis[x] = 0;    for (int i = hd[x]; i; i = next[i]) {        int y = v[i];        if (dis[y] &gt; dis[x] + w[i]) {            dis[y] &gt; dis[x] + w[i];            if (!vis[y]) {vis[y] = 1; q.push(y);}        }    }}\n几种最短路算法比较Dijkstra ：效率高；不能处理负边权\nFLoyd ：效率低；能处理负权边，可求最长路，好写\nBellman-Ford ：效率中等；能处理负权边\n字符串与数字的映射map&lt;string, int&gt; ml;string s;for (int i = 1; i &lt;= n; ++i) {cin &gt;&gt; s; ml[s] = i;}int m; cin &gt;&gt; m;while (m--) {    cin &gt;&gt; s; temp1 = ml[s];    cin &gt;&gt; num;    cin &gt;&gt; s; temp2 = ml[s];    dis[temp1][temp2] = num;}\n垃圾作业第一题 六度分离问任意两个点是否都能找到一个长度不大于 ​ 的路径\n这是一个多源最短路问题\n#include&lt;bits/stdc++.h&gt;#define N 107#define M 207using namespace std;inline int rd() {    bool f = 0;    int x = 0;    char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}int n, m, dis[N][N];void work() {    memset(dis, 0x3f, sizeof(dis));    for (int i = 1; i &lt;= n; ++i) {        dis[i][i] = 0;    }    for (int i = 1; i &lt;= m; ++i) {        int u = rd() + 1, v = rd() + 1;        dis[u][v] = 1; dis[v][u] = 1;    }    for (int k = 1; k &lt;= n; ++k) {        for (int i = 1; i &lt;= n; ++i) {            for (int j = 1; j &lt;= n; ++j) {                if (dis[i][j] &gt; dis[i][k] + dis[k][j])                    dis[i][j] = dis[i][k] + dis[k][j];            }        }    }    for (int i = 1; i &lt;= n; ++i) {        for (int j = 1; j &lt;= n; ++j) {            if (dis[i][j] &gt; 7) {puts(\"No\"); return;}        }    }    puts(\"Yes\");}int main() {    while (cin &gt;&gt; n &gt;&gt; m) work();    return 0;}\n第二题 我要去Colin家玩儿我要去colin家玩儿，我有好多个开始车站可以选择， 但我要去的地方只有colin家——沧州，我最少花费多少呢？\n我疯狂 wa 还有 TLE ，colin 知道了他说：你蠢不蠢，不会以我家为起点吗？\n我：哦哦哦\n#include&lt;bits/stdc++.h&gt;#define N 1007#define M 20007#define ll long longusing namespace std;inline int rd() {    bool f = 0;    int x = 0;    char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}struct edge{    int v, w, nxt;}e[M];int tot, vis[N], hd[N], dis[N];void add(int u, int v, int w) {    e[++tot].v = v; e[tot].w = w;    e[tot].nxt = hd[u];    hd[u] = tot;}queue&lt;int&gt; q;int n, m, s;void spfa(int x) {    for (int i = 1; i &lt;= n; ++i) {        dis[i] = 999999999; vis[i] = 0;    }    q.push(x); dis[x] = 0; vis[s] = 1;    while(!q.empty()) {        int t = q.front();        q.pop(); vis[t] = 0;        for (int i = hd[t]; i; i = e[i].nxt) {            int y = e[i].v;            if (dis[y] &gt; dis[t] + e[i].w) {                dis[y] = dis[t] + e[i].w;                if (!vis[y]) {vis[y] = 1; q.push(y);}            }        }    }}void work() {    tot = 0;    for (int i = 1; i &lt;= n; ++i) hd[i] = 0;    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd(), w = rd();        add(v, u, w);    }    int a = rd(), ans = 999999999;    spfa(s);    for (int i = 1; i &lt;= a; ++i) {        int t = rd();        ans = min(ans, dis[t]);    }    if (ans == 999999999) puts(\"-1\");    else cout &lt;&lt; ans &lt;&lt; endl;}int main() {    while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; s) work();    return 0;}\n第三题 骗钱行为问存不存在一种货币，它通过其他货币汇率转换后，自己的价值会变高。这就是著名的套利 (Arbitrage) 。\n#include&lt;bits/stdc++.h&gt;using namespace std;#define N 37#define M 2007typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}int n, m, vis[N], hd[N], tot;double dis[N][N];map&lt;string, int&gt; ml;string s;queue&lt;int&gt; q;struct edge{    int v, nxt;    double w;}e[M];void add(int u, int v, int w) {    e[++tot].v = v; e[tot].w = w;    e[tot].nxt = hd[u];    hd[u] = tot;}void work() {    tot = 0;    for (int i = 1; i &lt;= n; ++i) {        for (int j = 1; j &lt;= n; ++j) {            if (i == j) {                dis[i][i] = 1; vis[i] = 0; hd[i] = 0;                cin &gt;&gt; s; ml[s] = i;            }else dis[i][j] = 0;        }    }    m = rd();    for (int i = 1; i &lt;= m; ++i) {        int temp1, temp2;        double num;        cin &gt;&gt; s; temp1 = ml[s];        cin &gt;&gt; num;        cin &gt;&gt; s; temp2 = ml[s];        dis[temp1][temp2] = num;        add(temp1, temp2, num);    }    for (int k = 1; k &lt;= n; ++k) { //枚举中间过渡点        for (int i = 1; i &lt;= n; ++i) {            for (int j = 1; j &lt;= n; ++j) {                if (dis[i][j] &lt; dis[i][k] * dis[k][j])                    dis[i][j] = dis[i][k] * dis[k][j];            }        }    }    for (int i = 1; i &lt;= n; ++i)        if (dis[i][i] &gt; 1) {            puts(\"Yes\"); return;        }    puts(\"No\");}int main() {    int i = 1;    while(cin &gt;&gt; n &amp;&amp; n != 0) {printf(\"Case %d: \", i++); work();}    return 0}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"Analysis (The world is a chess board)","url":"/2021/08/18/Speech-Analysis1/","content":"The world is a chess board\nThe world is a chess board, on which we play the game that’s never supposed to be fair, but still excites us with these numerous possibilities. When I was 16, my dad recommended that I should sign up for a chess club and learn how to play. So I went. My level was only good enough to play against a bunch of ten-year-olds. What’s even more humiliating was that I actually had a hard time playing against them. So reasonably I became skeptical of the game and thought that it was unfair. You know on the chess board, there is a king, a queen, rocks, bishops, knights and pawns. Different pieces with different status and importance, possessing different capabilities. They stand in the strictly drawn little squares and line up accordingly to their value. And let’s face it. It’s the same in real life. Some of us matter, while some of us don’t, at least not that much. Among the very first lines of the Declaration of Independence, this one goes: we hold these truth to be self-evident that all men are created equal. What a beautiful line! But how can we convince ourselves that we are born equal while our ancestors didn’t die equal. I hate to say this but we do inherit most of the social capitals that get to decide what kind role we start with when we come to this world. However, the game still gets played for a reason. The board of 64 little squares is magically enough to create a stage for wonderful things to happen. In just first four moves, there are 318 million different ways to play. And in a game between two equal players, there would be around 50 moves in total. Just think about how many moves we take in lifetime. I will say countless. No one is able to predict what’s going to happen next, which i think is the true beauty of our world. That just paints a sliver lining like a little soldier, like you and me. Because with a little but sufficient ability to check mate and win the game by planning out my tactics and encountering coincidences along the way, I may somehow work my way up until the last rank and become a queen at the end of the game. The world is not fair but it doesn’t make it any less worthy of living, so go play with what you have carefully but boldly at the same time to unleash the unknown possibilities of life, or change the game.\n\n","categories":["HDU's Learning"],"tags":["English speech"]},{"title":"Speech_Information cocoon","url":"/2021/08/08/Speech-InformationCocoon/","content":"被咕咕了的作业……\n\nHello, sir or madam, today I’d like to begin with a story. \nIt’s a sunny day. A group of busy butterflies were bathing in the warm sun shine. During the break, they discovered a silkworm chrysalis who hid up in his cocoon and didn’t want to go outside. They flew towards him. A butterfly said, “Hey! Can you hear the sound of my fluffing wings.” Hum…Hum… “Today, I dance with some many flowers to the songs composed by birds. Get outside! I can play with you.” “No”, he shouts. He murmurs to himself, “I don’t care about what all of you say, I’m fine staying within my own cocoon.” One day, their land is flooding. A butterfly thought, maybe he didn’t know what’s going on, I should tell him. She flew to the cocoon, “Hey, boy! The land is flooding. Come on! You should break up your cocoon and flew away.” “Can’t you see how bright my cocoon is? You must be kidding. I’m not going out. Leave me, you bad butterfly.” \nToday, we live in a world of prosperity but still threatened by so many new problems. One is called “Information cocoon”. Just like in that story, some people like that silkworm chrysalis, refuse to get out of their room and push down their cellphone to immerse themselves in the marvelous nature and to build band with people vis-a-vis. Being stuck in the information cocoon, they only care about what they care, being indifferent to the outer world. With the development of tech, many websites can target people’s interest and wrap people with the information they push. The cocoon becomes more and more tough and strong. Please, put down your phones for a while. Look at that picture — Birds singing, wind blowing, sun shining and people wandering while chatting. Isn’t it a lovely picture? Thank you.\n","categories":["HDU's Learning"],"tags":["English speech"]},{"title":"Speech_Re-gifted","url":"/2021/08/08/Speech-Re-gifted/","content":"Practice makes perfect ~ ~\n\nToday, I’d like to begin with two pictures. One is a delicate purple gift  in the shape of an egg standing on a shelf, with the foreground saying “re-gifted”. The other is the very gift lying on the ground in pieces who shows her inner world, a music box singing bitterly. \n(Yes, it’s two pictures in this movie. To me, the movie not only presents how misery the gift’s fate is, but also acts as a timeless reminder that we should not ignore the need of others and be indifferent to the beauty inside others.)\nIn 2017, I went to an orphanage and spent a whole week with children there. In seven days I built a strong band between a girl and me. She was abandoned when she was born (due to the illness). At the first day, she seldom spoke even a word, and refused any of our help but always smiled. She was just like that gift to me, beautiful — her loveliness but fragile — her silentness. One of the adults said she was once adopted but was abandoned again due to her rejection to everything. I didn’t know how to help her. I chose to be her side silently. Just let her know I was there. (And whenever I had chances to speak with her, I would) And then I began to share with her many things in my life and asked her something similar and her emotions in those cases. Day by day, she was not that kind of autistic. I’m very happy to know that she liked playing flute and encouraged her to perform in front of many people.\n(Many years have passed, she still isn’t adopted just like what she once told me that she doesn’t want to be adopted because she will lose friends here.)\nEvery human is a gift from god. Every human living in the world has the need to be listened and cared, no matter how ugly or beautiful he is, no matter whether he is healthy or not. Inside a tough egg shell, it’s a music box voting for himself. To avoid more adorable souls break into pieces, we should find out their inner beauty and let it shine in front of you and in front of me. Thank you.\n","categories":["HDU's Learning"],"tags":["English speech"]},{"title":"Speech_subwayMusician","url":"/2021/07/31/Speech-subwayMusician/","content":"是演讲集训了~\n\nAt a subway station in Washington D.C., a few people stop their feet to enjoy even to listen to the music composed by the world’s top musicians during the morning rush hour. The story is kind of ridiculous but it really happens in our daily life. People get up, rush out the door and throw themselves into busy work without a second thought. People nowadays do lack of eyes to discover beauty, do lack of ears to listen to nature and do lack of heart to enjoy life itself.\nA few days ago, one of my classmates texted me telling me how anxious she was. Being a freshman learning computer science and technology, she not only become a night owl, but also need to get up early in the morning. She learns very hard but the outcome made her doubt the value of herself and the beauty of her life. I took her to a park nearby. After that she changed her attitude towards life, being delighted and hopeful.\nThe world never lack of beauty and hope. But people shut their ears, totally immerse in busy work even the work brings bitter and complain why life is so tough. People have no time stopping their feet even a little while. However there are still a group of people who devote themselves to slow down the life pace like the musician in Washington D.C..\nThe world is so beautiful. It integrates all kinds of people. Some rush forward to make the world a better place, others try to slow down their pace to make spiritual world a more peaceful place.\nDon’t stop for too long. Don’t go too fast. Open your heart, feeling the beautiful world around you. thank you.\n","categories":["HDU's Learning"],"tags":["English speech"]},{"title":"Speech video","url":"/2021/08/12/Speech-video/","content":"亚运英语之星演讲视频！\n\n(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer2\"),\"hotkey\":true,\"preload\":\"metadata\",\"video\":{\"url\":\"/img/English/qyy.MOV\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() \n","categories":["HDU's Learning"],"tags":["English speech"]},{"title":"Summary","url":"/2023/01/16/Summary/","content":"跬步千里\n\n开个博客记录平时训练做题反复犯的错误，以提醒自己：\n\nrd()函数，有的时候要读一个字符，有的时候只读一个字符，要注意尽量份两个函数写   \n注意看数据范围，开 ll \n函数内变量初始值随机，需要初始化 \nint 乘 int 有的时候会爆，记得 1ll * int * int \n\n牛客寒假1总结做题速度还是比较慢，代码习惯不太好，经常粗心。因为粗心不仅罚时多，而且最后还有一道题没过。感觉有的题目只有一个大概的思路，没法想下去。好的方面，首先五个小时没那么罚坐了，基本还是从头到尾都有题目做，其次，两道 dp 题也都还算顺利，说明对 dp 的感觉变好了。\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"Trie","url":"/2022/04/23/Trie/","content":"踹树 ！！\n\n\n他们今天在打天梯赛！\n我做了两道 cf ，然后有点不想做题了，想起来 Co 老师前几天教我的 Trie 树还没有写笔记（我太懒了，总是不写，问题是不写我还会忘，Co 老师就会很生气，为了不被逐出师门，我决定好好学习\nTrie啥是 Trie 树顾名思义，它应该是一个树……\n这个树给我一种很像自动机的感觉\n官方回答：Trie 树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。\n咋建立的这个建立的过程十分的自动机…… 由于我实在是口拙，还是举例子说一下吧\n比如给了两个串，abc 和 abdc\n处理第一个串的时候，从 1 号结点建立一条 a 的出边到 2 号结点，再从 2 号结点建立一条 b 的出边到 3 号结点，再从 3 号结点建立一条 c 的出边到 4 号结点。\n处理第二个串的时候，从 1 号结点开始，因为 1 号结点已经有 a 出边，故顺着这条边到 2 号结点，因为 2 号结点有 b 出边，故顺着这条边到 3 号结点，因为 3 号结点没有 d 的出边，故从 3 号结点建立一条 d 的边到 5 号结点，再从 5 号结点建立一条 c 的出边到 6 号结点。\n例题口胡题1给一堆字符串，若干次询问，每次询问一个串是否是那一堆字符串中任意一个串的前缀。\n解：看能否再 Trie 树上找到一条路径来匹配当前串。\n口胡题2给一堆字符串，若干次询问，每次询问一个串是那一堆字符串中多少个串的前缀。\n解：每个结点加个计数器。\n洛谷 P2580 于是他错误的点名开始了这道题大概就是，一个老师要点名，问是否存在该名字，如果第一次点到这个人输出 OK ，没有这个人输出 WRONG ，如果不是第一次点输出 REPEAT 。\n#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123;    bool f = 0;    int x = 0;    char c = getchar();    for (;!isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;);    for (; isdigit(c); c = getchar()) x = x * 10 + c - &#x27;0&#x27;;    return f ? -x : x;&#125;struct node &#123;    int nxt[26], cnt;&#125;c[500007];int nodecnt;string s;void insert() &#123;    int rt = 0, len = s.length();    for (int i = 0; i &lt; len; ++i) &#123;        int w = s[i] - &#x27;a&#x27;;        if (!c[rt].nxt[w]) c[rt].nxt[w] = ++nodecnt;        rt = c[rt].nxt[w];    &#125;&#125;int query() &#123;    int rt = 0, len = s.length();    for (int i = 0; i &lt; len; ++i) &#123;        int w = s[i] - &#x27;a&#x27;;        if (!c[rt].nxt[w]) return 0;        rt = c[rt].nxt[w];    &#125;    return ++c[rt].cnt;&#125;int main() &#123;    int n = rd();    for (int i = 1; i &lt;= n; ++i) &#123;        cin &gt;&gt; s; insert();    &#125;    int m = rd();    for (int i = 1; i &lt;= m; ++i) &#123;        cin &gt;&gt; s; int ans = query();        if (ans == 0) puts(&quot;WRONG&quot;);        else if (ans == 1) puts(&quot;OK&quot;);        else puts(&quot;REPEAT&quot;);    &#125;    return 0;&#125;\nSPOJ 4033 Phone List这是道洛谷要 waiting 亿万年的题目…… 最后是 Co 老师在 SPOJ 上帮我测的代码\n#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123;    bool f = 0;    int x = 0;    char c = getchar();    for (;!isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;);    for (; isdigit(c); c = getchar()) x = x * 10 + c - &#x27;0&#x27;;    return f ? -x : x;&#125;struct node &#123;    int nxt[26], cnt, fl;&#125;c[100007];int nodecnt;string s;void insert() &#123;    int rt = 0, len = s.length();    for (int i = 0; i &lt; len; ++i) &#123;        int w = s[i] - &#x27;0&#x27;;        if (!c[rt].nxt[w]) c[rt].nxt[w] = ++nodecnt;        rt = c[rt].nxt[w]; ++c[rt].cnt;    &#125;    c[rt].fl = 1;&#125;inline void work() &#123;    for (int i = 0; i &lt;= nodecnt; ++i) &#123;        c[i].cnt = c[i].fl = 0;        memset(c[i].nxt, 0, sizeof(c[i].nxt));    &#125;    nodecnt = 0;    int n = rd();    for (int i = 1; i &lt;= n; ++i) &#123;        cin &gt;&gt; s; insert();    &#125;    for (int i = 1; i &lt;= nodecnt; ++i)        if (c[i].fl &amp;&amp; c[i].cnt &gt;= 2) &#123;puts(&quot;NO&quot;); return;&#125;    puts(&quot;YES&quot;);&#125;int main() &#123;    for (int t = rd(); t; --t) work();    return 0;&#125;\nTrie 树 Function++Trie 树不仅可以解决一些字符串的前缀问题，还可以解决数字的异或贪心问题。\n#include&lt;bits/stdc++.h&gt;#define ll long long#define N 1007#define mod 998244353using namespace std;inline int rd() &#123;    bool f = 0;    int x = 0;    char c = getchar();    for (;!isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;);    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;&#125;int a[1 &lt;&lt; 17], l, r, totnode;struct node &#123;    int nxt[2];&#125;c[2000007];void build(int x) &#123;\tint rt = 0;\tfor (int i = 17; i &gt;= 0; --i) &#123;\t\tint w = ((x &amp; (1 &lt;&lt; i)) &gt; 0);\t\tif (c[rt].nxt[w] == 0) c[rt].nxt[w] = ++totnode;        rt = c[rt].nxt[w];\t&#125;&#125;int checkmx(int x) &#123;\tint rt = 0, res = 0;\tfor (int i = 17; i &gt;= 0; --i) &#123;\t\tint w = ((x &amp; (1 &lt;&lt; i)) &gt; 0);\t\tif (c[rt].nxt[w ^ 1]) &#123;\t\t\tres += (1 &lt;&lt; i);\t\t\trt = c[rt].nxt[w ^ 1];\t\t&#125; else rt = c[rt].nxt[w];\t&#125;\treturn res;&#125;int checkmn(int x) &#123;\tint rt = 0, res = 0;\tfor (int i = 17; i &gt;= 0; --i) &#123;\t\tint w = ((x &amp; (1 &lt;&lt; i)) &gt; 0);\t\tif (c[rt].nxt[w]) &#123;\t\t\trt = c[rt].nxt[w];\t\t&#125; else &#123;\t\t\tres += (1 &lt;&lt; i);            rt = c[rt].nxt[w ^ 1];        &#125;\t&#125;\treturn res;&#125;inline void work() &#123;    for (int i = 0; i &lt;= totnode; ++i)        for (int j = 0; j &lt; 2; ++j) c[i].nxt[j] = 0;    totnode = 0;    l = rd(); r = rd();    for (int i = 1; i &lt;= r - l + 1; ++i) build(a[i] = rd());    for (int i = 1; i &lt;= r - l + 1; ++i) &#123;        if (checkmx(a[i] ^ l) == r &amp;&amp; checkmn(a[i] ^ l) == l) &#123;printf(&quot;%d\\n&quot;, a[i] ^ l); return;&#125;    &#125;&#125;int main() &#123;    for (int t = rd(); t; --t) work();    return 0;&#125;\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"abc238","url":"/2022/02/07/abc238/","content":"ABCDEFG ~\n\nC\n取模问题，坑死我了，呜呜呜\n乘法取模问题：两个乘数分别   后，对结果再取  。\n除法操作也需要特别注意，涉及到下取整的问题。\n#include&lt;bits/stdc++.h&gt;using namespace std;#define N 377#define mod 998244353#define inv 499122177typedef long long ll;inline ll rd() {  ll x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}inline void work() {    ll n = rd();    ll m = n;    int cnt = 0;    ll ans = 0, x = 1, t = 0;    while (n) {        n = n / 10;        cnt++;    }    for (int i = 1; i &lt; cnt; ++i) {        t = t * 10 + 9;        if ((t - x + 1) % 2 == 0) ans = (ans + (((1 + (t - x + 1)) % mod) * (((t - x + 1) / 2) % mod))) % mod;        else ans = (ans + ((((1 + (t - x + 1)) / 2) % mod) * ((t - x + 1) % mod))) % mod;        x *= 10;    }    if ((m - x + 1) % 2 == 0) ans = (ans + (((1 + (m - x + 1)) % mod) * (((m - x + 1) / 2) % mod))) % mod;    else ans = (ans + ((((1 + (m - x + 1)) / 2) % mod) * ((m - x + 1) % mod))) % mod;    printf(\"%lld\\n\", ans);}int main() {    work();    return 0;}\nD\n因为  ，所以， ，所以  一定要  。\n且  二进制有  的位置， 对应的位置一定是  。\n#include&lt;bits/stdc++.h&gt;using namespace std;#define N 377#define mod 998244353#define inv 499122177typedef long long ll;inline ll rd() {  ll x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}inline void work() {    ll a = rd(), s = rd();    if (s &lt; 2 * a) {puts(\"No\"); return;}    if (s == 2 * a) {puts(\"Yes\"); return;}    ll res = s - 2 * a;    if ((res &amp; a) == 0) {puts(\"Yes\"); return;}    puts(\"No\");}int main() {    int t = rd();    while (t--) work();    return 0;}\nE‘\n给的  就是知道区间和，故我们想用前缀和数组来分析这个问题。\n   \n\n借助图来解决这一问题，存在从  到  的边，就相当于知道  。\n#include&lt;bits/stdc++.h&gt;using namespace std;#define N 200007#define mod 998244353#define inv 499122177typedef long long ll;vector&lt;int&gt; V[N];int n, Q, vis[N];inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}inline void dfs(int x) {    vis[x] = 1;    for (auto i : V[x]) {        if (!vis[i]) dfs(i);    }}int main() {    n = rd(); Q = rd();    while (Q--) {        int u = rd() - 1, v = rd();        V[u].push_back(v); V[v].push_back(u);    }    dfs(0);    vis[n] == 1 ? puts(\"Yes\") : puts(\"No\");    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"二分图","url":"/2022/07/04/bi-partite-graph-matching/","content":"“远方那是什么？“\n”是荒野。“ 鼹鼠说。\n”别害怕它。“\n”想象一下，如果我们不那么恐惧，会变成什么样？“\n\n二分图二分图：可以把所有的点分成两个集合，集合内部的点没有边相连，只有不同集合的点才有边相连。\n\n二分图判定与染色#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {\tint x = 0;\tbool f = 0;\tchar c = getchar();\tfor (; !isdigit(c); c = getchar()) f |= (c == '-');\tfor (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);\treturn f ? -x : x;}#define N 200007int bl[N];vector&lt;int&gt; e[N];bool dfs(int u) {\tfor (auto v : e[u]) {\t\tif (~bl[v]) {\t\t\tbl[v] = bl[u] ^ 1;\t\t\tif (!dfs(v)) return false;\t\t} else {\t\t\tif (bl[u] == bl[v]) return false;\t\t}\t}\treturn true;}inline void add(int u, int v) {e[u].push_back(v); e[v].push_back(u);}inline void work() {\tint n = rd(), m = rd();\tfor (int i = 1; i &lt;= n; ++i) {e[i].clear(); bl[i] = -1;}\tfor (int i = 1; i &lt;= m; ++i) {\t\tint u = rd(), v = rd();\t\tadd(u, v); add(v, u);\t}\tfor (int i = 1; i &lt;= n; ++i)\t\tif (~bl[i]) {\t\t\tbl[i] = 0;\t\t\tif (!dfs(i)) {puts(\"NO\"); return;}\t\t}\tputs(\"YES\");}int main() {\tfor (int t = rd(); t; --t) work();\treturn 0;}\n二分图最大匹配二分图最大匹配是指，让匹配上的点尽可能多。\n思路：把边看成有向边，从左边指向右边，给左边的点建立邻接表，右面的点开一个  数组，记，每一个点与左面的哪个点进行匹配。扫描左边的每一个点，尝试匹配。尝试匹配的过程开一个  数组，表示在尝试更新当前点的时候，已经试过和左边的这个点进行交换，这样子可以避免环的情况，如上图中，左边第一、三个点和右面两个点会形成一个循环。\n洛谷P3386     洛谷P1894     洛谷P2756\n模板题，求最大匹配。\n#define N 507vector&lt;int&gt; e[N];bool vis[N];int match[N];bool dfs(int u) {    for (auto v : e[u])        if (!vis[v]) {            vis[v] = 1;            if (!match[v] || dfs(match[v])) {                match[v] = u; return true;            }        }    return false;}int main() {    int n = rd(), m = rd(); m = rd();    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd();        e[u].push_back(v);    }    int ans = 0;    for (int i = 1; i &lt;= n; ++i) {        memset(vis, 0, sizeof(vis));        ans += dfs(i);    }    printf(\"%d\\n\", ans);    return 0;}\n洛谷P2071\n有  排座位，  个人，每个人有自己喜欢的排，每排有两个座位，问有多少个人能做到自己喜欢的排。\n思路：\n\n拆点，把一排拆成两个点。 和  \n\n 数组和  数组开成两维。\n\n\n#define N 2007vector&lt;int&gt; e[N * 2];bool vis[N][2];int match[N][2];bool dfs(int u) {    for (auto v : e[u]) {        if (!vis[v][0]) {            vis[v][0] = 1;            if (!match[v][0] || dfs(match[v][0])) {match[v][0] = u; return true;}        }        if (!vis[v][1]) {            vis[v][1] = 1;            if (!match[v][1] || dfs(match[v][1])) {match[v][1] = u; return true;}        }    }    return false;}int main() {    int n = rd();    for (int i = 1; i &lt;= 2 * n; ++i) {        for (int j = 1; j &lt;= 2; ++j) {            int v = rd(); e[i].push_back(v);        }    }    int ans = 0;    for (int i = 1; i &lt;= 2 * n; ++i) {        memset(vis, 0, sizeof(vis));        ans += dfs(i);    }    printf(\"%d\\n\", ans);    return 0;}\n洛谷P1129 \n给一个  的  矩阵，问能否通过行交换和列交换，使得对角线上的位置，都是  。\n思路：等价于这个矩阵是否满秩，也就是是否每一行都能找到一个主元位置。把行抽象成左边的点，列抽象成右边的点，等价于最大匹配是否等于  。\n#define N 207vector&lt;int&gt; e[N];bool vis[N];int match[N];bool dfs(int u) {    for (auto v : e[u])        if (!vis[v]) {            vis[v] = 1;            if (!match[v] || dfs(match[v])) {                match[v] = u; return true;            }        }    return false;}inline void work() {    memset(match, 0, sizeof(match));    int n = rd();    for (int i = 1; i &lt;= n; ++i) e[i].clear();    for (int i = 1; i &lt;= n; ++i) {        for (int j = 1; j &lt;= n; ++j) {            int c = rd();            if (c) e[i].push_back(j);        }    }    int ans = 0;    for (int i = 1; i &lt;= n; ++i) {        memset(vis, 0, sizeof(vis));        ans += dfs(i);    }    if (ans == n) puts(\"Yes\");    else puts(\"No\");}int main() {    for (int t = rd(); t; --t) work();    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"最短路","url":"/2022/07/03/co-shortest-path/","content":"“好了！”\n\ndij不加优化 ，复杂度为  \n算法思路：把所有的点分成两个集合，每次从还未打标记的集合中，选取出距离最短的点，用它来更新其他点。\n第19届浙江省赛G\n#define N 1007 struct node {    double x, y;    double sqr(double t) {return t * t;}    double dis(node t) {return sqrt(sqr(t.x - x) + sqr(t.y - y));}} a[N]; double mp[N][N], v1, v2, dis[N];bool vis[N]; int main() {    int n = rd();    for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i].x &gt;&gt; a[i].y;    cin &gt;&gt; a[0].x &gt;&gt; a[0].y &gt;&gt; a[n + 1].x &gt;&gt; a[n + 1].y &gt;&gt; v1 &gt;&gt; v2;    for (int i = 0; i &lt;= n + 1; ++i) {        dis[i] = 1e18;        for (int j = 0; j &lt;= n + 1; ++j) {            if (i == 0) mp[i][j] = a[i].dis(a[j]) / v1;            else {                double tmp = a[i].dis(a[j]);                if (tmp &gt; 3 * v2) mp[i][j] = 3 + (tmp - 3 * v2) / v1;                else mp[i][j] = tmp / v2;            }        }    }    dis[0] = 0;    for (int i = 0; i &lt;= n + 1; ++i) {        double mn = 1e18;        int pos = 0;        for (int j = 0; j &lt;= n + 1; ++j)            if (!vis[j] &amp;&amp; dis[j] &lt; mn) {mn = dis[j]; pos = j;} // 找点        vis[pos] = 1;        for (int j = 0; j &lt;= n + 1; ++j)            dis[j] = min(dis[j], dis[pos] + mp[pos][j]); // 更新    }    printf(\"%.12lf\\n\", dis[n + 1]);    return 0;}\n堆优化 ，复杂度是  。所以如果边是  级别的，不如不用优化                                                                                                                                    \nvector&lt;pair&lt;int, int&gt; &gt; e[N];ll dis[N];bool vis[N];priority_queue&lt;pair&lt;ll, int&gt; &gt; Q;void dij(int s) {    memset(dis, 0x3f, sizeof(dis));    dis[s] = 0; Q.push(make_pair(0, s));    while (!Q.empty()) {        int u = Q.top().second; Q.pop();        if (vis[u]) continue;        vis[u] = 1;        for (auto [v, w] : e[u])            if (dis[v] &gt; dis[u] + w) {                dis[v] = dis[u] + w;                Q.push(make_pair(-dis[v], v));            }    }}\nBellman-ford复杂度是  \n#define N 100007int n, dis[N];struct edge {int u, v, w;};vector&lt;edge&gt; V;void bellman_ford(int x) {    memset(dis, 0x3f, sizeof(dis));    dis[x] = 0;    for (int i = 1; i &lt;= n; ++i)        for (int j = 0; j &lt; V.size(); ++j) {            dis[V[i].v] = min(dis[V[i].v], dis[V[i].u] + V[i].w);        }}\nSPFA （队列优化的 Bellman_ford）复杂度是  ，对于随机生成的图复杂度为线性，但是很容易构造卡到 。\n#define N 100007int dis[N];vector&lt;pair&lt;int, int&gt; &gt; V[N];bool vis[N];queue&lt;int&gt; Q;void spfa(int x) {    memset(dis, 0x3f, sizeof(dis));    dis[x] = 0;    while (!Q.empty()) {       int u = Q.front(); Q.pop(); vis[u] = 0;       for (auto [v, w] : V[u]) {           if (dis[v] &gt; dis[u] + w) {               dis[v] = dis[u] + w;               if (!vis[v]) {Q.push(v); vis[v] = 1;}           }        }    }}\n多关键字把 dis 改成一个结构体，比较的时候按多关键字比较规则进行比较。\n分层图有些问题的信息，可能要在跑最短路的过程中才能确定，这样的问题，我们会根据过程中，可能遇到的不同状态，来进行分层，每一层里面都是一个最基本的图，层与层之间的连边，代表着不同状态的切换。\n关于要开多少点和边。点数：层数  每层的点数；边数：层数  每层的边数   (双向边)  （层内  层间）\n洛谷P2939 \n给一张图，从  号点走到  号点，可以选择  条边，将其代价变为  ，问最后的总代价最小是多少。\n思路：按走了多少条代价变为   的边进行分层。\n#define N 210007 //10000 * 21#define M 4200007// 50000 * 21 * 2 * 2#define ll long longvector&lt;pair&lt;int, int&gt; &gt; e[N];ll dis[N];bool vis[N];priority_queue&lt;pair&lt;ll, int&gt; , vector&lt;pair&lt;ll, int&gt; &gt;, greater&lt;pair&lt;ll, int&gt; &gt; &gt; Q;int n;void dij(int s) {    memset(dis, 0x3f, sizeof(dis));    dis[s] = 0; Q.push(make_pair(0, s));    while (!Q.empty()) {        int u = Q.top().second; Q.pop();        if (vis[u]) continue;        vis[u] = 1;        for (auto [v, w] : e[u])            if (dis[v] &gt; dis[u] + w) {                dis[v] = dis[u] + w;                Q.push(make_pair(dis[v], v));            }    }}inline void add(int u, int v, int w) {    e[u].push_back(make_pair(v, w));}int main() {    n = rd(); int m = rd(), k = rd();    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd(), w = rd();        for (int j = 0; j &lt;= k; ++j) {            add(j * n + u, j * n + v, w);            add(j * n + v, j * n + u, w);            if (j == k) continue;            add(j * n + u, (j + 1) * n + v, 0);            add(j * n + v, (j + 1) * n + u, 0);        }    }    dij(1);    ll ans = 1e18;    for (int i = 0; i &lt;= k; ++i) ans = min(ans, dis[i * n + n]);    printf(\"%lld\\n\", ans);    return 0;}\n2022广西省赛D\n有一辆小车要从起点  到终点  ，车的初始速度为  。在图上，有两类点，一类是普通的点，一类是可以花  代价进行倍速的点，提升速度为原来的两倍。边也有两类，一类是普通的边，一类是经过以后，速度会减为  。经过一条边的代价是  。问从起点到终点的最小代价（时间最短）是多少。\n思路：这题我们可以根据速度分层。首先根据代价的计算方法可以知道，层数最多就是最大边权的  。然后就根据条件建图。层与层之间的边有两类，一类是加速的，加速的就从上一层连到下一层的自己，代价是  ；还有一类是回到  的，这类边就从当前层的  连到第  层的  ，不在当前层内部连接  和  。\n#define N 420007 // 20000 * 21#define ll long longvector&lt;pair&lt;int, int&gt; &gt; e[N];ll dis[N];bool vis[N];priority_queue&lt;pair&lt;ll, int&gt; , vector&lt;pair&lt;ll, int&gt; &gt;, greater&lt;pair&lt;ll, int&gt; &gt; &gt; Q;void dij(int s) {    memset(dis, 0x3f, sizeof(dis));    dis[s] = 0; Q.push(make_pair(0, s));    while (!Q.empty()) {        int u = Q.top().second; Q.pop();        if (vis[u]) continue;        vis[u] = 1;        for (auto [v, w] : e[u])            if (dis[v] &gt; dis[u] + w) {                dis[v] = dis[u] + w;                Q.push(make_pair(dis[v], v));            }    }}inline void add(int u, int v, int w) {    e[u].push_back(make_pair(v, w));}int main() {    int n = rd(), m = rd(), s = rd(), t = rd();    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd(), w = rd();        char c = getchar();        for (; c != 'G' &amp;&amp; c != 'B'; c = getchar()) ;        for (int j = 0; j &lt;= 20; ++j) {            if (c == 'B')                add(j * n + u, v, (w + (1 &lt;&lt; j) - 1) / (1 &lt;&lt; j));            else                add(j * n + u, j * n + v, (w  + (1 &lt;&lt; j) - 1) / (1 &lt;&lt; j));        }    }    int p = rd();    for (int i = 1; i &lt;= p; ++i) {        int x = rd(), c = rd();        for (int j = 0; j &lt; 20; ++j)            add(j * n + x, (j + 1) * n + x, c);    }    dij(s);    ll ans = 1e18;    for (int i = 0; i &lt;= 20; ++i) ans = min(ans, dis[i * n + t]);    printf(\"%lld\\n\", ans == 1e18 ? -1 : ans);    return 0;}\narc061E\n 个点，  条边的图，每一条边有一个颜色。每次换一个颜色的边走需要  的代价，在同颜色里走不需要额外的代价。问从  号点走到  号点，最少需要的代价是多少。\n思路：每个颜色一层。层之间的边代价为  ，内部的边代价为  。考虑层之间的边，需要给每两层的这个点连一条边，这样子会连  级别的边，这也太多了…… 换个方法，我们给每个点建立一个实点，让每一层的这个点，都连到这个实点上且代价为  （ 也可以，但是为了后面可以做 01 BFS ，这里就取代价为  ，最终结果再除  ）。考虑要开多大的点集合边集，点集： 个实点，每条边  个点，所以一共是  ；边集： 条边，最多有  个在层里面的点，所以边集大概是  。\n#define N 100007#define M 500007 unordered_map&lt;int, int&gt; id[N];struct edge {int v, w, nxt;} e[2000007];int hd[M], tot, totn, dis[M];deque&lt;int&gt; Q;bool vis[M]; inline void add(int u, int v, int w) {    e[++tot].v = v; e[tot].w = w;    e[tot].nxt = hd[u]; hd[u] = tot;} int main() {    int n = rd(), m = rd();    totn = n;    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd(), c = rd();        if (!id[u][c]) {id[u][c] = ++totn; add(u, totn, 1); add(totn, u, 1);}        if (!id[v][c]) {id[v][c] = ++totn; add(v, totn, 1); add(totn, v, 1);}        add(id[u][c], id[v][c], 0); add(id[v][c], id[u][c], 0);    }    memset(dis, 0x3f, sizeof(dis));    Q.push_front(1); dis[1] = 0;    while (!Q.empty()) {        int u = Q.front(); Q.pop_front();        if (vis[u]) continue;        vis[u] = 1;        for (int i = hd[u], v; i; i = e[i].nxt)            if (dis[v = e[i].v] &gt; dis[u] + e[i].w) {                dis[v] = dis[u] + e[i].w;                if (e[i].w) Q.push_back(v);                else Q.push_front(v);            }    }    printf(\"%d\\n\", dis[n] == dis[0] ? -1 : dis[n] / 2);    return 0;}\n洛谷P1073\n有  个点，  条边，有单向边也有双向边，每个点有个价格  ，在该点买入水晶需花费  ，卖掉水晶可以赚  。现有一个商人从  号点开始走，要走到  号点，可以重复经过城市，在旅行过程中，他最多可以买一次、卖一次。问他最多能赚到多少钱。\n思路：以价格为边权建图，以买和卖两个动作分层。在图的内部边权都是  ，第  层到第  层之间的边代表买，所以边权是负数，第  层到第  层之间的边代表卖，所以便全是正的。因为要最大化赚到的钱，所以跑最长路。因为有负权边，所以不能用 dij 要用 spfa 。\n#define N 300007vector&lt;pair&lt;int, int&gt; &gt; e[N];int dis[N], vis[N];queue&lt;int&gt; Q;void spfa(int s) {    memset(dis, 0xcf, sizeof(dis));    dis[s] = 0; Q.push(s);    while (!Q.empty()) {       int u = Q.front(); Q.pop(); vis[u] = 0;       for (auto [v, w] : e[u])           if (dis[v] &lt; dis[u] + w) {               dis[v] = dis[u] + w;               if (!vis[v]) {Q.push(v); vis[v] = 1;}           }    }}inline void add(int u, int v, int w) {e[u].push_back(make_pair(v, w));}int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        int c = rd();        add(i, n + i, -c);        add(n + i, n * 2 + i, c);    }    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd(), z = rd();        add(u, v, 0); add(n + u, n + v, 0); add(u + 2 * n, v + 2 * n, 0);        if (z == 2) {add(v, u, 0); add(n + v, n + u, 0); add(v + 2 * n, u + 2 * n, 0);}    }    spfa(1);    printf(\"%d\\n\", max(0, dis[2 * n + n]));    return 0;}\nFloyd求传递闭包\n洛谷P2419\n#define N 107bool a[N][N];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd();        a[u][v] = 1;    }    // floyd    for (int k = 1; k &lt;= n; ++k)        for (int i = 1; i &lt;= n; ++i)            for (int j = 1; j &lt;= n; ++j)                if (a[i][k] &amp;&amp; a[k][j]) a[i][j] = 1;    // 统计有多少个点    int cnt = 0;    for (int i = 1; i &lt;= n; ++i) {        bool f = 1;        for (int j = 1; j &lt;= n; ++j)            if (i != j &amp;&amp; !a[i][j] &amp;&amp; !a[j][i])             f = 0;        if (f) cnt++;    }    printf(\"%d\\n\", cnt);    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"树形DP","url":"/2022/07/01/dp-on-tree/","content":"“当你有半杯水时，你觉得是有一半空着。还是有一半满了呢？” 鼹鼠问。\n“我会感激我拥有一个杯子。” 男孩说。\n\n概述 树形DP，顾名思义，就是在数据结构 “树” 上进行DP。“树” 是有  条边的连通图。通常我们用父子关系来刻画一颗树。\n最大独立集给一无向图，找出一个点集，使得任意两点之间都没有连边，这个点集就是独立集。而点最多的独立集，就是最大独立集。\n问题：要从一个无向图里选出一些点，这些点不能相邻，问最多可以选出来多少个点。\n思路：设置状态 f[u][0/1] 表示，以  为根节点的子树， 这个点选或者不选，可以选出来的点数。、\n初态：对于叶子结点 f[u][0] = 0, f[u][1] = 1 \n状态转移方程：\n\nf[u][0] = \\sum_{son} max(f[son][0], f[son][1]) \\\\\nf[u][1] = \\sum_{son} f[son][0] + 1void dfs(int u, int f) {    f[u][0] = 0; f[u][1] = 1;    for (auto son : e[u])        if (son != fa) {            dfs(son, u);            f[u][0] += max(f[v][0], f[v][1]);            f[u][1] += f[son][0];        }}\n最大匹配匹配：定义一个图 ，匹配是指边集的一个子集  。在  中，没有任意一个节点  ，使得  与  边相连又与  边相连（  ）。\n最大匹配：在所有极大匹配中，边集数量最大的那个就是最大匹配，最大匹配可能不唯一。\n问题：最大化选的边数，使得所有的点两两配对。\n思路：设置状态 f[u][0/1]表示以  为根的子树中，点  是否与其子结点中的一个配对，最多能选多少条边。\n状态转移方程：\n\nf[u][0] = \\sum_{son} f[son][1]如果点  与其子结点中的一个配对，需要枚举这个子结点是谁，其他的子结点，贡献依然为 f[son][1] ，只有该子结点的贡献为 f[son][0] 。对比 f[u][0] ，也就是说要选择一个 f[son][1] - f[son][0] 最小的点与点  相连。\nvoid dfs(int u, int fa) {    int dlt = 1e9;    for (auto son :e[u]) {        f[u][0] += f[son][1];        dlt = min(dlt, f[son][1] - f[som][0]);    }    f[u][1] = f[u][0] - dlt;}\n最小点覆盖点覆盖的概念定义：对于图  中的一个点覆盖是一个集合  ，使得每一条边至少有一个端点在  中。\n最小点覆盖：就是点个数最少的  集合。\n思路：设置状态 f[u][0/1] 表示，以  为根的子树中， 这个点选或者不选，选了的点数。\n状态转移方程：\n\nf[u][1] = \\sum_{son} max(f[son][0], f[son][1]) + 1\\\\\nf[u][0] = \\sum_{son} f[son][1]void dfs(int um int fa) {    f[u][0] = 0; f[u][1] = 1;    for (auto son : e[U])        if (son != fa) {            dfs(son, u);            f[u][1] += max(f[son][0], f[son][1]);            f[u][0] += f[son][1];        }}\n练习洛谷P2986\n给一棵树点权为  ，边权为  ，选一个点作为目的地，定义  表示点  到目的地的距离，总路程为  。\n问题：选择一个点作为目的地，使得总路程最小。\n思路：先随便选择一个点作为根，求出 f[u] 和 sum[u] ，分别表示，以  为根的子树中的点，都走到  的总路程，以及点权和。后面用换根技巧，分别计算到其他点的答案。\n\n#define N 100007#define ll long longint tot, hd[N], c[N];struct edge {int to, w, nxt;} e[N &lt;&lt; 1];inline void add(int u, int v, int w) {    e[++tot].to = v; e[tot].w = w;    e[tot].nxt = hd[u]; hd[u] = tot;}ll f[N], sum[N];void dfs(int u, int fa) {    sum[u] = c[u];    for (int i = hd[u], v; i; i = e[i].nxt)        if ((v = e[i].to) != fa) {            dfs(v, u);            sum[u] += sum[v];            f[u] += f[v] + sum[v] * e[i].w;        }}ll ans[N];void dfs1(int u, int fa) {    for (int i = hd[u], v; i; i = e[i].nxt)        if ((v = e[i].to) != fa) {            ans[v] = ans[u] - sum[v] * e[i].w + (sum[1] - sum[v]) * e[i].w;            dfs1(v, u);        }}int main() {    int n = rd();    for (int i = 1; i &lt;= n; ++i) c[i] = rd();    for (int i = 1; i &lt; n; ++i) {        int u = rd(), v = rd(), w = rd();        add(u, v, w); add(v, u, w);    }    dfs(1, 1);    ans[1] = f[1];    dfs1(1, 1);    ll res = 1e18;    for (int i = 1; i &lt;= n; ++i) res = min(res, ans[i]);    printf(\"%lld\\n\", res);    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"dsu on tree","url":"/2022/08/30/dsu-on-tree/","content":"“你说过的最勇敢的话是什么？” 男孩问。“帮帮我。” 马回答。\n\ndsu on tree用于统计子树信息。\n核心与树链剖分相似，为划分轻重儿子；\n核心思想：\n\n先处理轻儿子，并且不保留子树的信息；\n\n处理重儿子，并保留子树信息；\n\n再遍历一遍轻儿子，统计答案；\n\n再加上当前点，统计答案。\n\n\n时间复杂度分析：\n一个点只会被操作  遍历一遍，而被操作  ， 遍历的次数为它到根的链上的轻边个数，最多只有 log 个，所以为 ；\n统计每一个子树的众数和https://codeforces.com/problemset/problem/600/E\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_backinline int rd() {    int x = 0;    bool f = 0;    char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}#define N 100007vector&lt;int&gt; e[N];int sz[N], mxs[N], cnt[N], co[N], n, mx; // cnt 统计颜色 mx 全局的众数出现的次数ll ans[N], res; // res 众数和void dfs(int u, int fa) {    sz[u] = 1;    for (auto v : e[u]) {        if (v != fa) {            dfs(v, u); sz[u] += sz[v];            if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v;        }    }}void add(int u, int fa) {    cnt[co[u]]++;    if (cnt[co[u]] == mx) res += co[u];    else if (cnt[co[u]] &gt; mx) {res = co[u]; mx = cnt[co[u]];}    for (auto v : e[u]) {        if (v != fa) add(v, u);    }}void del(int u, int fa) {    cnt[co[u]] = 0;    for (auto v : e[u]) {        if (v != fa) del(v, u);    }}void dfs1(int u, int fa) {    for (auto v : e[u]) {        if (v != fa &amp;&amp; v != mxs[u]) {dfs1(v, u); del(v, u); mx = res = 0;}    }    if (mxs[u]) dfs1(mxs[u], u);    for (auto v : e[u])        if (v != fa &amp;&amp; v != mxs[u]) add(v, u);    cnt[co[u]]++;    if (cnt[co[u]] == mx) res += co[u];    else if (cnt[co[u]] &gt; mx) {res = co[u]; mx = cnt[co[u]];}    ans[u] = res;}int main() {    n = rd();    for (int i = 1; i &lt;= n; ++i) co[i] = rd();    for (int i = 1; i &lt; n; ++i) {        int u = rd(), v = rd();        e[u].pb(v); e[v].pb(u);    }    dfs(1, 1); dfs1(1, 1);    for (int i = 1; i &lt;= n; ++i) printf(\"%lld \", ans[i]);    return 0;}\n统计一棵树所有可能的 dfs 序的逆序对个数和https://pintia.cn/problem-sets/994805046380707840/problems/1518582895035215872\n用树状数组统计逆序对的个数；将 ”逆序对个数和“ 转换成 ”期望的逆序对个数“ 乘 ”dfs 序“ 的个数。\n期望的逆序对个数：对于祖孙关系的逆序对，贡献为  。对于不是祖孙关系的序对，有  的概率成为逆序对。所以期望的逆序对个数就是，祖孙关系逆序对个数 +  不是祖先关系的序对。用 dsu + 树状数组 求祖孙关系逆序对个数。不是祖先关系的序对数 = 全部序对数 - 是祖先关系的序对数。全部序对数 =  。祖先关系的序对数 =  。dfs 序的个数 =  。      \n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_backinline int rd() {    int x = 0;    bool f = 0;    char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}#define N 300007#define mod 1000000007int c[N], n;inline int lowbit(int x) {return x &amp; -x;}inline void add(int p) {    for (; p &lt;= n; p += lowbit(p)) c[p]++;}inline int sum(int p) {    int tmp = 0;    for (; p; p -= lowbit(p)) tmp += c[p];    return tmp;}vector&lt;int&gt; e[N];int sz[N], mxs[N], r;ll cnt, dfscnt = 1, f[N], res;void dfs(int u, int fa) {    sz[u] = 1;    for (auto v : e[u]) {        if (v != fa) {            dfs(v, u); sz[u] += sz[v];            if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v;        }    }    cnt = (cnt + sz[u] - 1) % mod;    dfscnt = (1ll * dfscnt * f[e[u].size() - (u != r)]) % mod;}void add(int u, int fa) {    add(u);    for (auto v : e[u]) {        if (v != fa) add(v, u);    }}void clear(int p) {    for (; p &lt;= n; p += lowbit(p)) c[p] = 0;}void del(int u, int fa) {    clear(u);    for (auto v : e[u]) {        if (v != fa) del(v, u);    }}void dfs1(int u, int fa) {    for (auto v : e[u]) {        if (v != fa &amp;&amp; v != mxs[u]) {dfs1(v, u); del(v, u);}    }    if (mxs[u]) dfs1(mxs[u], u);    for (auto v : e[u])        if (v != fa &amp;&amp; v != mxs[u]) add(v, u);    res = (res + sum(u)) % mod; add(u);}inline ll qpow(ll x, int p) {    ll res = 1;    for (; p; p &gt;&gt;= 1, x = 1ll * x * x % mod)        if (p &amp; 1) res = 1ll * res * x % mod;    return res;}int main() {    n = rd(); r = rd(); f[0] = 1;    for (int i = 1; i &lt;= n; ++i) f[i] = (1ll * f[i - 1] * i) % mod;    for (int i = 1; i &lt; n; ++i) {        int u = rd(), v = rd();        e[u].pb(v); e[v].pb(u);    }    dfs(r, r); dfs1(r, r);    printf(\"%lld\\n\", ((res + qpow(2, mod - 2) * ((1ll * n * (n - 1) / 2 - cnt) % mod) % mod) * dfscnt) % mod);    return 0;}\n每个结点上有一个小写字母，每次询问点  的子树中，深度为  的结点上的字母能否构成回文串https://codeforces.com/problemset/problem/570/D\n构成回文串的充要条件是点  的子树中，出现个数为奇数的字母小于等于  个。用数组 cnt[N][26] 统计子树中每个字母出现的次数。由于可能对同一个子树有多次询问（不同深度），对每一个点开一个存放询问的 vector。\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_backinline int rd() {    int x = 0;    bool f = 0;    char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}#define N 500007vector&lt;int&gt; e[N];int n;int sz[N], mxs[N], dep[N];void dfs1(int u) {    sz[u] = 1;    for (auto v : e[u]) {        dep[v] = dep[u] + 1;        dfs1(v); sz[u] += sz[v];        if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v;    }}struct que {int k, id;};vector&lt;que&gt; q[N];int cnt[N][27];bool ans[N];string s;void add(int u) {    cnt[dep[u]][s[u - 1] - 'a']++;    for (auto v : e[u]) add(v);}void del(int u) {    cnt[dep[u]][s[u - 1] - 'a']--;    for (auto v : e[u]) del(v);}void dfs2(int u) {    for (auto v : e[u]) {        if (v != mxs[u]) {dfs2(v); del(v);}    }    if (mxs[u]) dfs2(mxs[u]);    for (auto v : e[u])        if (v != mxs[u]) add(v);     cnt[dep[u]][s[u - 1] - 'a']++;     for (auto cur : q[u]) {         int tmp = 0;         for (int i = 0; i &lt; 26; ++i)            if (cnt[cur.k][i] % 2 == 1) tmp++;         if (tmp &lt;= 1) ans[cur.id] = 1;     }}int main() {    n = rd(); int m = rd();    for (int i = 2; i &lt;= n; ++i) {        int u = rd(); e[u].pb(i);    }    cin &gt;&gt; s;    for (int i = 1 ; i &lt;= m; ++i) {        int u = rd(), k = rd();        q[u].pb(que{k, i});    }    dep[1] = 1; dfs1(1); dfs2(1);    for (int i = 1; i &lt;= m; ++i) puts(ans[i] ? \"Yes\" : \"No\");    return 0;}\n每次询问查询与点  有共同的  级祖先的点的个数 （不包括 ）https://codeforces.com/problemset/problem/208/E\n用倍增思想处理  级祖先；cnt 数组统计各个深度的点数。\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_backinline int rd() {    int x = 0;    bool f = 0;    char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}#define N 100007vector&lt;int&gt; e[N];int n, fa[N][21], t, dep[N];void dfs(int u) {    for (int i = 1; i &lt;= t; ++i)        fa[u][i] = fa[fa[u][i - 1]][i - 1];    for (auto v : e[u]) {        fa[v][0] = u;        dep[v] = dep[u] + 1;        dfs(v);    }}int sz[N], mxs[N];void dfs1(int u) {    sz[u] = 1;    for (auto v : e[u]) {        dfs1(v); sz[u] += sz[v];        if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v;    }}struct que {int k, u, id;};vector&lt;que&gt; q[N];int cnt[N], ans[N];void add(int u, int fa) {    cnt[dep[u]]++;    for (auto v : e[u])        if (v != fa) add(v, u);}void del(int u, int fa) {    cnt[dep[u]]--;    for (auto v : e[u])        if (v != fa) del(v, u);}void dfs2(int u) {    for (auto v : e[u]) {        if (v != mxs[u]) {dfs2(v); del(v, u);}    }    if (mxs[u]) dfs2(mxs[u]);    for (auto v : e[u])        if (v != mxs[u]) add(v, u);     for (auto cur : q[u])         ans[cur.id] = cnt[dep[u] + cur.k] - 1;     cnt[dep[u]]++;}int main() {    n = rd(); t = __lg(n);    for (int i = 1; i &lt;= n; ++i) {        fa[i + 1][0] = rd() + 1; e[fa[i + 1][0]].pb(i + 1);    }    fa[1][0] = 1; dfs(1);    for (int i = 1; i &lt;= t; ++i)       for (int j = 1; j &lt;= n + 1; ++j) {           fa[j][i] = fa[fa[j][i - 1]][i - 1];       }    int m = rd();    for (int i = 1 ; i &lt;= m; ++i) {        int v = rd() + 1, k = rd();        if (dep[v] &lt;= k) continue;        int u = v;        for (int j = t; j &gt;= 0; --j)               if (k &amp; (1 &lt;&lt; j)) u = fa[u][j];        q[u].pb(que{k, u, i});    }    dfs1(1); dfs2(1);    for (int i = 1; i &lt;= m; ++i) printf(\"%d \", ans[i]);    return 0;}\n每个点上有一个字符串，每次询问查询以点  的  级祖先为根的子树中，与  深度相同深度的点中，有多少个不同的字符串https://codeforces.com/problemset/problem/246/E\n用倍增思想求  级祖先；把询问挂在  级祖先上；用 map 统计有多少个不同的字符串，不用 set 是因为 del 的时候，不应该直接把这个字符串擦掉，因为有可能有别的点上也是这个字符串，所以用 map 当做一个计数器，如果计数器为  了，再把这个字符串删掉。为了防止保证访问不越界，查询时要注意。\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_backinline int rd() {    int x = 0;    bool f = 0;    char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}#define N 100007vector&lt;int&gt; e[N];int n;int sz[N], mxs[N], dep[N];void dfs1(int u) {    sz[u] = 1;    for (auto v : e[u]) {        dep[v] = dep[u] + 1;        dfs1(v); sz[u] += sz[v];        if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v;    }}struct que {int k, id;};vector&lt;que&gt; q[N];int cnt[N][27], ans[N];char name[N][21];map&lt;string, int&gt; S[N];void add(int u) {    S[dep[u]][name[u]]++;    for (auto v : e[u]) add(v);}void del(int u) {    S[dep[u]][name[u]]--;    if (S[dep[u]][name[u]] == 0) S[dep[u]].erase(name[u]);    for (auto v : e[u]) del(v);}void dfs2(int u) {    for (auto v : e[u]) {        if (v != mxs[u]) {dfs2(v); del(v);}    }    if (mxs[u]) dfs2(mxs[u]);    for (auto v : e[u])        if (v != mxs[u]) add(v);     S[dep[u]][name[u]]++;     for (auto cur : q[u]) {         if (dep[u] + cur.k &gt; n) continue;         ans[cur.id] = S[dep[u] + cur.k].size();     }}int main() {    n = rd();    for (int i = 1; i &lt;= n; ++i) {        cin &gt;&gt; name[i];        int u = rd(); if (u) e[u].pb(i);    }    int m = rd();    for (int i = 1 ; i &lt;= m; ++i) {        int u = rd(), k = rd();        q[u].pb(que{k, i});    }    for (int i = 1; i &lt;= n; ++i)        if (!dep[i]) {            dep[i] = 1; dfs1(i); dfs2(i); del(i);        }    for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]);    return 0;}\n对于每个点，求一个最小的  ，使得  最大。 为  子树中到  距离为  的节点数。https://codeforces.com/problemset/problem/1009/F\n记录子树每个深度的节点的个数，然后取个最大节点个数的最小深度即可\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_backinline int rd() {    int x = 0;    bool f = 0;    char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}#define N 1000007vector&lt;int&gt; e[N];int n;int sz[N], mxs[N], dep[N];void dfs1(int u, int fa) {    sz[u] = 1;    for (auto v : e[u]) {        if (v != fa) {            dep[v] = dep[u] + 1;            dfs1(v, u); sz[u] += sz[v];            if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v;        }    }}int cnt[N], ans[N], mx, mxid;void add(int u, int fa) {    cnt[dep[u]]++;    if (cnt[dep[u]] &gt; mx) {mxid = dep[u]; mx = cnt[dep[u]];}    else if (cnt[dep[u]] == mx) mxid = min(mxid, dep[u]);    for (auto v : e[u])        if (v != fa) add(v, u);}void del(int u, int fa) {    cnt[dep[u]]--;    for (auto v : e[u])        if (v != fa) del(v, u);}void dfs2(int u, int fa) {    for (auto v : e[u]) {        if (v != fa &amp;&amp; v != mxs[u]) {dfs2(v, u); del(v, u); mx = mxid = 0;}    }    if (mxs[u]) dfs2(mxs[u], u);    for (auto v : e[u])        if (v != fa &amp;&amp; v != mxs[u]) add(v, u);     cnt[dep[u]]++;     if (cnt[dep[u]] &gt; mx) {mxid = dep[u]; mx = cnt[dep[u]];}     else if (cnt[dep[u]] == mx) mxid = min(mxid, dep[u]);     ans[u] = mxid - dep[u];}int main() {    n = rd();    for (int i = 1; i &lt; n; ++i) {        int u = rd(), v = rd();        e[u].pb(v); e[v].pb(u);    }    dep[1] = 1; dfs1(1, 1); dfs2(1, 1);    for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", ans[i]);    return 0;}","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"树链剖分（重链剖分）","url":"/2022/08/02/heavy%20path%20decomposition/","content":"“我发现了比蛋糕更好的东西。”\n“不，你没有。” 男孩说。\n“我有。” 鼹鼠说。\n“是什么？”\n“拥抱。它比蛋糕更持久。”\n\n树链剖分的思想树链剖分用于将树分割成若干条链的形式，以维护树上路径的信息。\n具体来说，将整棵树剖分为若干条链，使它组合成线性结构，然后用其他的数据结构维护信息。\n重链剖分相关定义重子节点 表示其子节点中子树最大的子结点。如果有多个子树最大的子结点，取其一。如果没有子节点，就无重子节点。\n轻子节点 表示剩余的所有子结点。\n从这个结点到重子节点的边为 重边。\n到其他轻子节点的边为 轻边。\n若干条首尾衔接的重边构成 重链。\n把落单的结点也当作重链，那么整棵树就被剖分成若干条重链。\n代码int fa[N], dep[N], son[N], sz[N], top[N], dfn[N], cnt;void dfs1(int u, int d) {    dep[u] = d;    sz[u] = 1;    int mxid = 0;    for (int i = hd[u]; i; i = e[i].nxt) {        int v = e[i].to;        if (!fa[v]) {            fa[v] = u; dfs1(v, d + 1); sz[u] += sz[v];            if (sz[v] &gt; sz[mxid]) mxid = v;        }    }    son[u] = mxid;}void dfs2(int u, int t) {    top[u] = t;    dfn[u] = ++cnt;    if (son[u]) dfs2(son[u], t);    for (int i = hd[u]; i; i = e[i].nxt) {        int v = e[i].to;        if (!dfn[v]) dfs2(v, v);    }}\n应用重链剖分 可以将树上的任意一条路径划分成不超过  条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的 LCA 为链的一个端点）。\n重链剖分还能保证划分出的每条链上的节点 DFS 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。\n如：\n\n修改 树上两点之间的路径上 所有点的值。\n查询 树上两点之间的路径上 节点权值的 和/极值/其它（在序列上可以用数据结构维护，便于合并的信息）。\n\n除了配合数据结构来维护树上路径信息，树剖还可以用来 （且常数较小）地求 LCA。\n求 LCA考虑以下两种情况：\n\n ,  在一条重链上，那深度浅的那一个就是他们的 LCA\n ,  不在一条重链上，比较 dep[top[u]] 和 dep[top[v]] ，深度较浅的跳到其父亲，如此循环，最终会回到第 1 种情况。\n\n#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline ll rd() {    ll x = 0;    bool f = 0;    char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}#define N 500007#define M 1000007struct node {int to, nxt;} e[M];int hd[N], tot;inline void add(int u, int v) {    e[++tot].to = v; e[tot].nxt = hd[u]; hd[u] = tot;    e[++tot].to = u; e[tot].nxt = hd[v]; hd[v] = tot;}int fa[N], dep[N], son[N], sz[N], top[N], dfn[N], cnt;void dfs1(int u, int d) {    dep[u] = d;    sz[u] = 1;    int mxid = 0;    for (int i = hd[u]; i; i = e[i].nxt) {        int v = e[i].to;        if (!fa[v]) {            fa[v] = u; dfs1(v, d + 1); sz[u] += sz[v];            if (sz[v] &gt; sz[mxid]) mxid = v;        }    }    son[u] = mxid;}void dfs2(int u, int t) {    top[u] = t;    dfn[u] = ++cnt;    if (son[u]) dfs2(son[u], t);    for (int i = hd[u]; i; i = e[i].nxt) {        int v = e[i].to;        if (!dfn[v]) dfs2(v, v);    }}inline int lca(int u, int v) {    while (top[u] != top[v]) {        if (dep[top[u]] &gt; dep[top[v]])            u = fa[top[u]];        else             v = fa[top[v]];    }    return dep[u] &gt; dep[v] ? v : u;}int main() {    int n = rd(), m = rd(), s = rd();    for (int i = 1; i &lt; n; ++i) {        int u = rd(), v = rd(); add(u, v);    }    fa[s] = s;    dfs1(s, 1); dfs2(s, s);    for (int i = 1; i &lt;= m; ++i) {        int a = rd(), b = rd();        printf(\"%d\\n\", lca(a, b));    }    return 0;}\n子树加、查询 &amp; 路径加、查询洛谷 P3384\n在 dfs 序中，子树是连续的一段，而一段路径至多分为  段。配合线段树解决这一问题。\n#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline ll rd() {    ll x = 0;    bool f = 0;    char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}#define N 100007struct no {int to, nxt;} e[N &lt;&lt; 1];int hd[N], tot;inline void add(int u, int v) {    e[++tot].to = v; e[tot].nxt = hd[u]; hd[u] = tot;    e[++tot].to = u; e[tot].nxt = hd[v]; hd[v] = tot;}int fa[N], dep[N], son[N], sz[N], top[N], dfn[N], cnt, ran[N];void dfs1(int u, int d) {    dep[u] = d;    sz[u] = 1;    int mxid = 0;    for (int i = hd[u]; i; i = e[i].nxt) {        int v = e[i].to;        if (!fa[v]) {            fa[v] = u; dfs1(v, d + 1); sz[u] += sz[v];            if (sz[v] &gt; sz[mxid]) mxid = v;        }    }    son[u] = mxid;}void dfs2(int u, int t) {    top[u] = t;    dfn[u] = ++cnt;    ran[cnt] = u;    if (son[u]) dfs2(son[u], t);    for (int i = hd[u]; i; i = e[i].nxt) {        int v = e[i].to;        if (!dfn[v]) dfs2(v, v);    }}struct node{  int ls, rs;  ll lazy, sum;}c[N &lt;&lt; 1];int totnode, rot, a[N], p;inline int newn(){    return ++totnode;}inline void pushup(int rt) {    c[rt].sum = (c[c[rt].ls].sum + c[c[rt].rs].sum) % p;}void build(int &amp;rt, int l, int r){    if (rt == 0) rt = newn();    if (l == r) {c[rt].sum = a[ran[l]]; return;}    int mid = (l + r) &gt;&gt; 1;    build(c[rt].ls, l, mid);    build(c[rt].rs, mid + 1, r);    pushup(rt);}void pushdown(int rt, int ln, int rn) {//ln 左二子区间长度 rn 右儿子区间长度    if (c[rt].lazy) {        c[c[rt].ls].lazy = (c[c[rt].ls].lazy + c[rt].lazy) % p;        c[c[rt].rs].lazy = (c[c[rt].rs].lazy + c[rt].lazy) % p;        c[c[rt].ls].sum = (c[c[rt].ls].sum + c[rt].lazy * ln % p) % p;        c[c[rt].rs].sum = (c[c[rt].rs].sum + c[rt].lazy * rn % p) % p;                c[rt].lazy = 0;    }}void update(int rt, int l, int r, int L, int R, int val) {    if (L &lt;= l &amp;&amp; r &lt;= R) {        c[rt].sum = (c[rt].sum + val * (r - l + 1)) % p;        c[rt].lazy = (c[rt].lazy  + val) % p;        return;    }    int mid = (l + r) &gt;&gt; 1;    pushdown(rt, mid - l + 1, r - mid);    if (L &lt;= mid) update(c[rt].ls, l, mid, L, R, val);    if (R &gt; mid) update(c[rt].rs, mid + 1, r, L, R, val);    pushup(rt);}inline ll query(int rt, int l, int r, int L, int R) {    if (L &lt;= l &amp;&amp; r &lt;= R) return c[rt].sum;    ll ans = 0;    int mid = (l + r) &gt;&gt; 1;    pushdown(rt, mid - l + 1, r - mid);    if (L &lt;= mid) ans = (ans + query(c[rt].ls, l, mid, L, R)) % p;    if (R &gt; mid) ans = (ans + query(c[rt].rs, mid + 1, r, L, R)) % p;    return ans;}int main() {    int n = rd(), m = rd(), s = rd(); p = rd();    for (int i = 1; i &lt;= n; ++i) a[i] = rd() % p;    for (int i = 1; i &lt; n; ++i) {        int u = rd(), v = rd(); add(u, v);    }    fa[s] = s;    dfs1(s, 1); dfs2(s, s); build(rot, 1, n);    for (int i = 1; i &lt;= m; ++i) {        int op = rd();        if (op == 1) { // 路径加            int x = rd(), y = rd(), val = rd();            while (top[x] != top[y]) {                if (dep[top[x]] &gt; dep[top[y]]) {                    update(rot, 1, n, dfn[top[x]], dfn[x], val);                    x = fa[top[x]];                }                else {                    update(rot, 1, n, dfn[top[y]], dfn[y], val);                    y = fa[top[y]];                }            }            if (dep[x] &gt; dep[y]) swap(x, y);            update(rot, 1, n, dfn[x], dfn[y], val);        } else if (op == 2) { // 路径查询            int x = rd(), y = rd();            int ans = 0;            while (top[x] != top[y]) {                if (dep[top[x]] &gt; dep[top[y]]) {                    ans = (ans + query(rot, 1, n, dfn[top[x]], dfn[x])) % p;                    x = fa[top[x]];                }                else {                    ans = (ans + query(rot, 1, n, dfn[top[y]], dfn[y])) % p;                    y = fa[top[y]];                }            }            if (dep[x] &gt; dep[y]) swap(x, y);            ans = (ans + query(rot, 1, n, dfn[x], dfn[y])) % p;            printf(\"%d\\n\", ans);        } else if (op == 3) { // 子树加            int x = rd(), val = rd();            update(rot, 1, n, dfn[x], dfn[x] + sz[x] - 1, val);        } else { // 子树查询            int x = rd();            printf(\"%lld\\n\", query(rot, 1, n, dfn[x], dfn[x] + sz[x] - 1));        }    }    return 0;}","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"Hello World","url":"/2021/01/17/hello-world/","content":"Welcome to Hexo! \n\nThis is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n","tags":["other"]},{"title":"树形背包","url":"/2022/07/02/knapsack-on-tree/","content":"“我们还有那么长的路要走。” 男孩叹了口气。\n“是啊，但是你看，我们已经走了这么远了。” 马说。\n\n背包01 背包\n有  个物品，每个物品只有一个，每个物体都有对应的体积和价值，求在总体积不超过  的前提下，最大化物品的价值和。\n状态定义：f[i][j] 表示 前  个物品总体积不超过  时的最大收益。\n转移方程：f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]) \nint f[1007][1007];int v[1007], w[1007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd();    }    memset(f, 0, sizeof(f));    for (int i = 1; i &lt;= n; ++i) {        for (int j = 0; j &lt;= m; ++j) {            if (j &lt; v[i]) f[i][j] = f[i - 1] [j];            else f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);        }    }    printf(\"%d\\n\", f[n][m]);    return 0;}\n压缩空间\nint f[1007], v[1007], w[1007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd();    }    memset(f, 0, sizeof(f));    for (int i = 1; i &lt;= n; ++i) {        for (int j = m; j &gt;= 0; --j) {            if (j &lt; v[i]) f[j] = f[j];            else f[j] = max(f[j], f[j - v[i]] + w[i]);        }    }    printf(\"%d\\n\", f[m]);    return 0;}\n完全背包\n有  个物品，每个物品有无限个，每个物品有对应的体积和价值，求在总体积不超过  的前提下，最大化物品的价值和。\n状态定义：f[i][j] 表示 前 个物品总体积为 时的最大收益。\n转移方程：f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i]) \nint f[1007][1007], v[1007], w[1007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd();    }    memset(f, 0, sizeof(f));    for (int i = 1; i &lt;= n; ++i) {        for (int j = 0; j &lt;= m; ++j) {            if (j &lt; v[i]) f[i][j] = f[i - 1][j];            else f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i]);        }    }    printf(\"%d\\n\", f[n][m]);    return 0;}\n压缩空间\nint f[1007], v[1007], w[1007];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i) {        v[i] = rd(); w[i] = rd();    }    memset(f, 0, sizeof(f));    for (int i = 1; i &lt;= n; ++i) {        for (int j = 0; j &lt;= m; ++j) {            if (j &lt; v[i]) f[j] = f[j];            else f[j] = max(f[j], f[j - v[i]] + w[i]);        }    }    printf(\"%d\\n\", f[m]);    return 0;}\n树形背包在一个树上，每一个结点都有一个价值和体积，求在总体积不超过  时，最大化物品的价值和。要求，如果要选某个点，该点的父节点一定要选。\n设置状态：f[i][j] 表示，以  为根的子树中，体积不超过  时，能有的最大价值和。\n模板：\n不优化，复杂度为  \nvoid dfs(int u， int fa) {    for (auto son : e[u])        if (son != fa) {            dfs(son, u);            for (int j = V; j &gt;= 0; --j) // 给以u为根的子树多大体积 （不包含该儿子结点后面的儿子结点和u）            \tfor (int k = 0; k &lt;= j; ++j) // 给以son为根的子树多大体积                    f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);           \tsum[u] += sum[son]        }    // 强制把根节点塞进去    sum[u] += v[u];    for (int j = min(V, sum[u]); j; --j) f[u][j] = f[u][j - v[u]] + w[u];}\n优化后，复杂度为 \nvoid dfs(int u， int fa) {    for (auto son : e[u])        if (son != fa) {            dfs(son, u);            for (int j = min(V, sum[u] + sum[son]);j &gt;= 0; --j) // 上界就是该儿子的子树的最大体积和在他前面的子树的最大体积的和            \tfor (int k = max(0, j - sum[u]); k &lt;= min(j, sum[son]); ++j) // 上界时不超过该儿子的子树的最大体积，下界表示能给当前子树的最小体积，就是前面的子树都塞满                    f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);           \tsum[u] += sum[son]        }    // 强制把根节点塞进去    sum[u] += v[u];    for (int j = min(V, sum[u]); j; --j) f[u][j] = f[u][j - v[u]] + w[u];}\n洛谷P2014\n有些课程有前置课程，如果要选这个课，就必须同时选他的前置课程。现要从所有的课里选  门，要最大化能获得的学分。\n思路：这是一道模板题，数据范围不大，即使不优化也可以过。每门课的体积就是  ，价值就是学分。有一个问题就是，可能会有多棵树，我们建一个虚点  号点，其价值和代价都是  。使用优化的方法，代码如下。\n#define N 307int n, m, f[N][N], w[N], sum[N];vector&lt;int&gt; son[N];void dfs(int u) {    for (auto v : son[u]) {        dfs(v);        for (int j = min(m, sum[u] + sum[v]); j &gt;= 0; --j)            for (int k = max(j - sum[u], 0); k &lt;= min(j, sum[v]); ++k)                f[u][j] = max(f[u][j], f[u][j - k] + f[v][k]);        sum[u] += sum[v];    }    if (u) {        sum[u]++;        for (int j = min(m, sum[u]); j; --j) f[u][j] = f[u][j - 1] + w[u];    }}int main() {    n = rd(); m =rd();    for (int i = 1; i &lt;= n; ++i) {        son[rd()].push_back(i);        w[i] = rd();    }    dfs(0);    int ans = 0;    for (int i = 1; i &lt;= m; ++i) ans = max(ans, f[0][i]);    printf(\"%d\\n\", ans);    return 0;}\n洛谷P2015\n给一棵树，每条边有一个权值，求在只保留  条树枝的前提下，最大化所有保留下来的边的权值和。\n思路：把边的权值当作在子结点上。然后就跟上一道题一样了。采用邻接表的方式存图，dfs 的时候，把权值作为参数传下去。\n#define N 307int n, Q, f[N][N], sum[N], tot, hd[N];struct edge {int to, w, nxt;} e[N];void add(int u, int v, int w) {    e[++tot].to = v; e[tot].w = w;    e[tot].nxt = hd[u]; hd[u] = tot;}void dfs(int u, int fa, int w) {    for (int i = hd[u], v; i; i = e[i].nxt) {        if ((v = e[i].to) != fa) {            dfs(v, u, e[i].w);            for (int j = min(Q, sum[u] + sum[v]); j &gt;= 0; --j)                for (int k = max(j - sum[u], 0); k &lt;= min(j, sum[v]); ++k)                    f[u][j] = max(f[u][j], f[u][j - k] + f[v][k]);            sum[u] += sum[v];        }    }    if (u) {        sum[u]++;        for (int j = min(Q, sum[u]); j; --j) f[u][j] = f[u][j - 1] + w;    }}int main() {    n = rd(); Q = rd();    for (int i = 1; i &lt; n; ++i) {        int u = rd() - 1, v = rd() - 1, w = rd();        add(u, v, w); add(v, u, w);    }    dfs(0, 0, 0);    int ans = 0;    for (int i = 1; i &lt;= Q; ++i) ans = max(ans, f[0][i]);    printf(\"%d\\n\", ans);    return 0;}\n代码源219\n给一棵以  号点为根的树，每个点有一个价值，相邻两个点不能同时选，最多选  个点，问最大的价值是多少。\n思路：大体上跟上面的思路差不多，但其转移方程更像昨天学的树形DP。增加一维表示当前这个点选还是不选。\n注意，枚举体积更新的时候，要倒着枚举\n#define N 507int n, m, f[N][N][2], w[N], sum[N];vector&lt;int&gt; son[N];void dfs(int u) {    for (auto v : son[u]) {        dfs(v);        for (int j = min(m, sum[u] + sum[v]); j &gt;= 0; --j)            for (int k = max(j - sum[u], 0); k &lt;= min(j, sum[v]); ++k) {                f[u][j][0] = max(f[u][j][0], f[u][j - k][0] + max(f[v][k][0], f[v][k][1]));                f[u][j][1] = max(f[u][j][1], f[u][j - k][1] + f[v][k][0]);            }        sum[u] += sum[v];    }    sum[u]++;    for (int i = min(m, sum[u]); i; --i) f[u][i][1] = f[u][i - 1][1] + w[u];}int main() {    n = rd(); m = rd();    for (int i = 2; i &lt;= n; ++i) son[rd()].push_back(i);    for (int i = 1; i &lt;= n; ++i) w[i] = rd();    dfs(1);    int ans = 0;    for (int i = 1; i &lt;= m; ++i) ans = max(ans, max(f[1][i][0], f[1][i][1]));    printf(\"%d\\n\", ans);    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"调和级数 除法分块 埃筛 线性筛","url":"/2022/06/27/math1/","content":"“你觉得最浪费时间的事是什么？” \n“拿自己和别人比较”，鼹鼠说。\n\n前言已经好几次比赛遇到调和级数了，每次co老师要给我讲，我都委婉地拒绝了，然后每次一比赛就不会……终于在放假的第一天，把这个小小的知识，学习了一下。\n调和级数调和级数被叫做调和级数，是因其复杂度是调和级数。\n经典应用：求  每个数的因数和，最直接的想法是，先枚举  从  到  ，再枚举  的因子从  到  ，这样子复杂度为  ，能处理的数据范围大概是  。但如果想要  获得答案并且  ，原来的方法就没解决了。我们换个思路，不去枚举每一个数可能的因子，而是枚举每一个因子能对哪些数做贡献。也就是先枚举因子  从  到  ，再枚举该因子可以给哪些数提供贡献，也就是枚举  ，初始值为  ，上界为  ，步长为  ，代码如下。\nfor (int i = 1; i &lt;= n; ++i)     for (int j = i; j &lt;= n; j += i)\n上面这段代码的复杂度为  根据调和级数可得该复杂度为  。\n除法分块除法分块要解决的问题与商有关。比如，我要求  的商数和或者余数和 (  )，即  。暴力做的话就是  的。\n我们先来观察一个数  ：\n\n\n\n\n被除数\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n商\n10\n5\n3\n2\n2\n1\n1\n1\n1\n1\n\n\n\n\n其商可以划分为一段一段的，就利用这种性质，降低解决原问题方法的复杂度。\nfor (int r, t, l = 1; l &lt;= n; l = r + 1) { //区间左端点    t = n / l; // 商    r = n / t; // 区间右端点   \tans += (r - l + 1) * t; // 可以是其他的}\n该方法的复杂度为  ，\n比如，以下三个式子的求解。\n\n\n\n\n\n推导过程：\n\n\n\\begin{array}{l}\n\\sum_{i = 1} ^ n n \\mod i & = \\sum_{i =1} ^n (n - \\lfloor\\frac n i \\rfloor \\times i) \\\\\n& = n^2 - \\sum_{i = 1} ^n (\\lfloor \\frac n i \\rfloor \\times i)\\\\ \n& = n^2 - \\sum_t t \\sum_{i = l} ^r i \\\\\n& = n ^2 - \\sum_t (t \\times \\frac{(l + r)(r - l + 1)} 2) \n\\end{array}\n\nll ans = n * n;for (int r, t, l = 1; l &lt;= n; l = r + 1) {    t = n / l;    r = n / t;    ans += 1ll * t * (l + r) * (r - l + 1) / 2;}\n\n\n\\begin{array}{l}\n\\sum_{i = 1}^n (\\lfloor \\frac n i \\rfloor \\times (n \\mod i)) & =\\sum_{i = 1} ^ n (\\lfloor\\frac n i \\rfloor(n - \\lfloor \\frac n i \\rfloor \\times i)) \\\\ \n& =\\sum_{i = 1} ^ n (n \\lfloor \\frac n i \\rfloor - \\lfloor \\frac n i \\rfloor^2 \\times i)\\\\\n& = \\sum_{i = 1} ^ n (n \\times \\lfloor \\frac n i \\rfloor) - \\sum_{i = 1} ^ n (\\lfloor \\frac n i \\rfloor ^ 2 \\times i ) \\\\\n& = n \\sum_{i = 1} ^ n \\lfloor \\frac n i \\rfloor - \\sum_{i = 1} ^ n (\\lfloor \\frac n i \\rfloor ^ 2 \\times i) \\\\\n& = n \\sum_t(t \\times(r - l + 1)) + \\sum_t (t^2 \\times \\frac{(l + r)(r - l + 1)} 2 )\n\\end{array}\n\nll ans = 0;for (int r, t, l = 1; l &lt;= n; l = r + 1) {    t = n / l; r = n / t;    ans += 1ll * n * t * (r - l + 1) + 1ll * t * t * (r + l) * (r - l + 1) / 2; }\n\n其中   是  的二次和\n\n\n\\begin{array}{l}\n\\sum_{i = 1} ^n (n \\mod i) ^2 & = \\sum_{i = 1} ^ n (n ^ 2 - 2 \\times n \\times \\lfloor \\frac n i \\rfloor \\times i + \\lfloor \\frac n i \\rfloor ^ 2 \\times i ^ 2) \\\\\n& = n ^ 3 - 2 \\times n \\times \\sum_{i =1} ^ n \\lfloor \\frac n i \\rfloor i + \\sum_{i = 1} ^ n \\lfloor\\frac n i \\rfloor^2i^2 \\\\\n& = n^3 - 2 \\times n \\times \\sum_t (t \\times \\frac{(l + r)(r - l + 1)} 2) + \\sum_t (t^2 \\times (sum2(r) - sum2(l-1)))\n\\end{array}ll sum2(int x) {    return (x * (x + 1) * (2 * x + 1)) / 6;}ll ans = n * n * n;for (int r, t, l = 1; l &lt;= n; l = r + 1) {    t = n / l; r = n / t;    ans += 2 * n * t * (l + r) * (r - l + 1) / 2 + t * t * (sum2(r) - sum2(l - 1));}\n数论函数分类数论函数按积性可分为 完全积性函数和积性函数。完全积性函数满足  ，积性函数满足 如果  和  互质，则 。\n常见的完全积性函数有  、 、 等。常见积性函数有 欧拉函数  ，莫比乌斯函数  ，约数幂和函数族  。\n欧拉函数欧拉函数  ，为从  到  与  互质的数的个数。\n标准分解 ：把  分解成若干个质数的幂次的和。即  。\n若用标准分解来表示  ，则欧拉函数形式为  。\n埃拉托斯特尼筛大概就是套了一个调和级数。\n比如，我现在要统计从  到  ，哪些数是质数。\n暴力的想法就是枚举  从  到  ，再枚举  从  到  ，判断  是否含有  这个因子。这样子的复杂度是  。\n稍微好一点的想法是枚举  的时候，上界只枚举到  ，因为约数是成对存在的，大于  的根所配对的一定小于  。这样子的复杂度是  。\n但这还不够优秀，我们结合调和级数的想法来枚举因子，那么因子的倍数就一定不是质数，复杂度为  。代码如下：\nbool isp[N]; // 0 表示是质数，1 表示不是质数for (int i = 2; i &lt;= n; ++i) // 1 要排除在外 且 1 是质数    for (int j = 2 * i; j &lt;= n; j += i) // 排除自己要从 2 * i 开始        isp[j] = 1;\n稍微再优化一下，枚举  的下界从  开始，为啥是对的呢？因为如果  如果  那么在这之前就已经筛掉了，所以下届可以从  开始。这样子的复杂度为  。\n组合数\n{n \\choose m} = {n - 1 \\choose m - 1} + {n - 1 \\choose m}由上式可知，可以  求组合数。即  。\n\n{n \\choose m} = \\frac {n!} {m!(n - m)!} \\\\\nA_n^m = \\frac{n!}{(n - m)!}根据以上式子可知，如果想求组合数或者排列数，只需要知道阶乘和阶乘的逆元。求阶乘的复杂度是  的，即  ；求阶乘的逆元，如果对每一个元素都用费马小定理，复杂度是  ，但其实可以做到  ，对于最后一个元素用费马小定理，再反过来求阶乘的逆元，这样做的复杂度是  ，即  。 \n洛谷P5431\n给一组数列  ，求  。\n#define N 5000007ll fac[N], ifac[N];int mod, a[N];inline ll qpow(ll x, int p) {    ll res = 1;    for (; p; p &gt;&gt;= 1, x = 1ll * x * x % mod)        if (p &amp; 1) res = 1ll * res * x % mod;    return res;}int main() {    int n = rd(), p = rd(), k = rd();    for (int i = 1; i &lt;= n; ++i) a[i] = rd();    mod = p;    fac[0] = 1;    for (int i = 1; i &lt;= n; ++i)        fac[i] = fac[i - 1] * a[i] % p;    ifac[n] = qpow(fac[n], p - 2);    for (int i = n - 1; i; --i) ifac[i] = ifac[i + 1] * a[i + 1] % p;    ll ans = 0, tmp = k;    for (int i = 1; i &lt;= n; ++i) {ans = (ans + fac[i - 1] * ifac[i] % p * tmp % p) % p; tmp = tmp * k % p;}    printf(\"%lld\\n\", ans);    return 0;}\n线性筛线性筛是一种数论筛法，用于求一个不大的数域内全部的函数值，可以筛出一定范围内的质数或任意积性函数的值。\n其中”线性“的含义为 每个数字只被其最小的质因数筛出 ，并非时间复杂度。\n假设求积性函数  的质数幂  复杂度为 ，则最终复杂度为 。\n求 f(n)f(n) 的值时，考虑其标准分解\n\n对标准分解的最小质因数的指数  的情况讨论。\n\n 是素数 ，即 \n，其中  是任意正整数，且 ，即 \n，其中  是任意正整数，且 ，即 \n\n下面对三类情况分别进行处理：\n\n 是素数 ，即   往往可以利用数论函数的定义快速求出。\n，其中  是任意正整数，且 ，即   利用积性函数的定义，由于 ，有   由于 , ， 和  在此前都已求出。\n\n\n，其中  是任意正整数，且 ，即   将  重新表示为  的形式，此时  ，有   由于 ，， 和  在此前都已求出。\n\n现在只需要解决如何快速求出  对应的  和  的值。\n不妨设 , ，这两个函数虽然不是积性的，但依然可以按照上述思路讨论。\n讨论  和  的关系：\n\n 是素数  ： ，\n ，且  ： ，\n ，且  ： ，\n\n欧拉函数（） 表示，从  中，与  互质的数的个数。\n#define N 100007int mind[N], cnt[N], pw[N], prm[N], phi[N]; // 最小质因子; ; ; 保存质数; phiint main() {    phi[1] = 1;    for (int i = 2; i &lt; N; ++i) {        if (!mind[i]) {          mind[i] = i;          phi[i] = i - 1;          cnt[i] = 1; pw[i] = i;          prm[++prm[0]] = i;        }        for (int j = 1, p = prm[1]; j &lt;= prm[0]; p = prm[++j]) {            int n = i * p;            if (n &gt; N) break;            if (p == mind[i]) {                mind[n] = p;                cnt[n] = cnt[i] + 1;                pw[n] = pw[i] * p;                if (i == pw[i]) phi[n] = (p - 1) * i; // n = pw[n] = p^k                else phi[n] = phi[i / pw[i]] * phi[pw[i] * p]; // 积性函数性质                break;            }            phi[n] = phi[i] * phi[p]; // 积性函数性质            cnt[n] = 1; mind[n] = pw[n] = p;        }    }    return 0;}\n 函数 表示，代表  的约数的  次幂和。特别的， 是约数的个数， 是约数的和。\n// sigma0#define N 100007int mind[N], cnt[N], pw[N], prm[N], sigma0[N];int main() {    sigma0[1] = 1;    for (int i = 2; i &lt; N; ++i) {        if (!mind[i]) {          mind[i] = i;          sigma0[i] = 2;          cnt[i] = 1; pw[i] = i;          prm[++prm[0]] = i;        }        for (int j = 1, p = prm[1]; j &lt;= prm[0]; p = prm[++j]) {            int n = i * p;            if (n &gt; N) break;            if (p == mind[i]) {                mind[n] = p;                cnt[n] = cnt[i] + 1;                pw[n] = pw[i] * p;                if (i == pw[i]) sigma0[n] = cnt[n] + 1; // n = pw[n] = p^k                else sigma0[n] = sigma0[i / pw[i]] * sigma0[pw[i] * p];                break;            }            sigma0[n] = sigma0[i] * sigma0[p];            cnt[n] = 1; mind[n] = pw[n] = p;        }    }    return 0;}\n// sigma1#define N 100007int mind[N], cnt[N], pw[N], prm[N], sigma1[N];int main() {    sigma1[1] = 1;    for (int i = 2; i &lt; N; ++i) {        if (!mind[i]) {          mind[i] = i;          sigma1[i] = i + 1;          cnt[i] = 1; pw[i] = i;          prm[++prm[0]] = i;        }        for (int j = 1, p = prm[1]; j &lt;= prm[0]; p = prm[++j]) {            int n = i * p;            if (n &gt; N) break;            if (p == mind[i]) {                mind[n] = p;                cnt[n] = cnt[i] + 1;                pw[n] = pw[i] * p;                if (i == pw[i]) sigma1[n] = (1 - n * p) / (1 - p); // n = pw[n] = p^k                else sigma1[n] = sigma1[i / pw[i]] * sigma1[pw[i] * p];                break;            }            sigma1[n] = sigma1[i] * sigma1[p];            cnt[n] = 1; mind[n] = pw[n] = p;        }    }    return 0;}\n欧拉函数相关的求和式推导洛谷P2158\n前置小知识：从 (0,0) 到 (x,y) 的整点的个数为 gcd(x,y) + 1 （包括两端点）\n这道题是问，从原点（点阵的左下角）看向  的二维点阵，能看到多少个点。等价题意是：\n给出一个  ，求\n\n\\sum_{i = 0}^{n-1} \\sum_{j = 0}^{n-1} [(i,j) = 1]\n \n\n推导过程：\n\n\\begin{array}{l}\n原式 \n&= \\sum_{i = 0}^{n-1}\\bigg(\\sum_{j=0}^{i-1}[(i,j) = 1] +  [(i,i) = 1] + \\sum_{j=i+1}^{n-1}  [(i,j) = 1] \\bigg) \\\\\n&= \\sum_{i = 0}^{n-1}\\sum_{j=0}^{i-1}[(i,j) = 1] +  \\sum_{i = 0}^{n-1}[(i,i) = 1] + \\sum_{i = 0}^{n-1}\\sum_{j=i+1}^{n-1}  [(i,j) = 1] \\\\\n&= 2 \\times \\sum_{i = 0}^{n-1}\\sum_{j = 0}^{i-1}[(i,j) = 1] +[n - 1 \\ge 1] \\\\\n&= 2 \\times \\sum_{i = 0}^{n-1}\\bigg(\\sum_{j = 1}^{i}[(i,j) = 1] + [(i,0) = 1] - [(i,i) = 1]\\bigg) +[n \\ge 2] \\\\\n&= 2 \\times \\sum_{i = 0}^{n-1}\\varphi(i) + [n \\ge 2]\n\\end{array}所以可以先  求  ，再  对  维护前缀和，求得答案。综上，解决该问题的复杂度为  。\nbzojP2818\n给出一个  ，求\n\n\\sum_{i = 1}^{n} \\sum_{j = 1}^{n} [(i,j)\\ is\\ prime]先枚举  的值，式子变成\n\n\\begin{array}{l}\n原式\n&= \\sum_{d\\ is\\ prime}^n \\sum_{i = 1}^n \\sum_{j = 1}^n [(i,j) = d] \\\\\n&= \\sum_{d\\ is\\ prime}^n \\sum_{i = 1}^{\\lfloor \\frac n d \\rfloor} \\sum_{j = 1}^{\\lfloor \\frac n d \\rfloor} [(i,j) = 1] \\\\\n&= \\sum_{d\\ is\\ prime}^n \\sum_{i = 1}^{\\lfloor \\frac n d \\rfloor}\\bigg(\\sum_{j = 1}^{i - 1} [(i,j)=1] + \\sum_{j = i + 1}^{\\lfloor \\frac n d \\rfloor} [(i,j) = 1] + [(i,i) = 1]\\bigg)\\\\\n&= \\sum_{d\\ is\\ prime}^n \\sum_{i = 1}^{\\lfloor \\frac n d \\rfloor}\\bigg(2 \\times \\sum_{j = 1}^{i - 1} [(i,j)=1] + [(i,i) = 1]\\bigg)\\\\\n&= \\sum_{d\\ is\\ prime}^n \\sum_{i = 1}^{\\lfloor \\frac n d \\rfloor}\\bigg(2 \\times \\sum_{j = 1}^{i} [(i,j)=1] - 2 \\times [(i,i) = 1] + [(i,i) = 1]\\bigg)\\\\\n&= \\sum_{d\\ is\\ prime}^n \\sum_{i = 1}^{\\lfloor \\frac n d \\rfloor}\\bigg(2 \\times \\varphi(i) - [(i,i) = 1]\\bigg)\\\\\n&= \\sum_{d\\ is\\ prime}^n \\bigg(2\\times \\sum_{i = 1}^{\\lfloor \\frac n d \\rfloor}\\varphi(i) - 1\\bigg)\n\\end{array}所以可以先  求  ，再  对  维护前缀和（或者对  维护前缀和），线性筛出所有质数。其中  ，因为只有当  时才成立，且  一定大于  。综上，解决该问题的复杂度为  。\n洛谷P2398\n给出一个  ，求\n\n\\sum_{i=1}^n \\sum_{j=1}^n (i,j)\n\n\n先枚举  的值，式子变成\n\n\\sum_{d=1}^n d \\sum_{i=1}^n\\sum_{j=1}^n[(i,j) = d]跟上面一道题一样推导可以得到最后的式子为\n\n\\sum_{d=1}^n d\\bigg(2\\times \\sum_{i = 1}^{\\lfloor \\frac n d \\rfloor}\\varphi(i) - 1\\bigg)","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"matrix","url":"/2022/03/22/matrix/","content":"I’ve been read Jane Eyre recently; I really love it.\n\n矩阵快速幂矩阵乘法满足结合律和分配律，不满足交换律\n快速幂运算如果数据太大，记得开 long long\nint power (int a, int n) { // a^n    int ans;    if (n == 0) ans = 1;    else {        ans = power(a * a, n / 2);        if (n % 2 == 1) ans *= a;    }    return ans;}int power(int a, int n) {    int ans = 1;    while(n) {        if (n % 2) ans = ans * a;        a = a * a;        n = n / 2'    }    return ans;}\n矩阵快速幂应用：有以下递推式\n\nf[n]=f[n-1]+f[n-2]构造矩阵\n\n\\begin{bmatrix}\nf[n]\\\\\nf[n - 1]\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & 1\\\\\n1 & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nf[n-1]\\\\\nf[n - 2]\n\\end{bmatrix}转换\n\nC(n) = \\begin{bmatrix}\nf[n]\\\\\nf[n - 1]\n\\end{bmatrix}\n\\\\\nB = \\begin{bmatrix}\n1 & 1\\\\\n1 & 0\n\\end{bmatrix}得到新的递推式：\n\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"树上倍增","url":"/2022/02/07/multiply%20on%20the%20tree/","content":"昨天，是明天的前天，是前天的明天。\n\n树上倍增今天和Co老师学了树上倍增\n倍增思想其实之前Co老师也给我讲过倍增思想，是在 ST Table 那一节。\n倍增思想其实就是，每个数都可以转换成 二的幂次的和 。\n为什么叫倍增呢？因为， \n在树上，其就是对高度（深度）进行倍增思想。\n例题一Eva.oj 0009 \n给一棵树，询问 点  的  级祖先是谁。\n首先我们可以通过 dfs 求的每一个点的直接父亲是谁，根据倍增思想，我们可以求出每个点  级祖先是谁。 级祖先，可以通过不断找当前的二的幂次级的祖先，不断向上跳找到。\n定义 f[i][j] 为 点  的 ​ 级祖先。\n易错点：\n数组要开够，但不要太大，因为二维数组的空间大小是乘法计算。\n#include&lt;bits/stdc++.h&gt;using namespace std;#define N 500007typedef long long ll;vector&lt;int&gt; e[N];int fa[N][21], n, p, rot;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}inline void dfs(int u) {    for (int i = 1; i &lt;= t; ++i)            fa[u][i] = fa[fa[u][i - 1]][i - 1];    for (auto cur : e[u]) {        int v = cur.first, w = cur.second;        if (v != fa[u][0]) {            fa[v][0] = u;            dep[v] = dep[u] + 1;            dfs(v);        }    }}int main() {    n = rd(); q = rd(); rot = rd();    for (int i = 1; i &lt;= n - 1; ++i) {        int u = rd(), v = rd();        e[u].push_back(v); e[v].push_back(u);    }    fa[rot][0] = rot; dfs(rot);    for (int i = 1; i &lt;= 20; ++i)        for (int j = 1; j &lt;= n; ++j)            fa[j][i] = fa[fa[j][i - 1]][i - 1];    for (int i = 1; i &lt;= q; ++i) {        int u = rd(), k = rd();        for (int j = 20; j &gt;= 0; --j)            if (k &amp; (1 &lt;&lt; i)) u = fa[u][i];        printf(\"%d\\n\", u);    }    return 0;}\n二洛谷  \nLCA 模板题 求最近公共祖先\n首先，我们需要在 dfs 的过程中，求出每个点的深度，因为想用树上倍增解决这个问题，那就是对高度（深度）用倍增的思想解决问题，但两个点的深度有可能是不一样的，但从较浅的点到 ​ 这一段高度，两个人一定是相等的。所以我们把整个过程，分为两部分：\n\n较深的点跳到和较浅的点一样的深度（也用倍增思想\n两个点一起往上跳\n\n假设做完步骤  以后从两个点到  的高度差为  ，可得若跳跃的高度差  ，两个点跳到的是同一个点，若跳跃的高度差  ，两个点跳到的不是同一个点，利用这个性质，我们将往上跳  ，故最后还需要  操作。\n为什么是往上跳  呢，因为我们跳跃的条件是两个点往上跳的点不等，所以不可能停在  ，又因为根据倍增思想  一定能转化成二的幂次的和，所以我们一定会跳到这里。\n#include&lt;bits/stdc++.h&gt;using namespace std;#define N 500007typedef long long ll;vector&lt;int&gt; e[N];int fa[N][21], dep[N], t, n, m, rot;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}inline void dfs(int u) {    for (int i = 1; i &lt;= t; ++i)            fa[u][i] = fa[fa[u][i - 1]][i - 1];    for (auto cur : e[u]) {        int v = cur.first, w = cur.second;        if (v != fa[u][0]) {            fa[v][0] = u;            dep[v] = dep[u] + 1;            sum[v] = sum[u] + w;            dfs(v);        }    }}inline int lca(int u, int v) {    if (dep[u] &gt; dep[v]) swap(u, v);    for (int i = t; i &gt;= 0; --i)        if (dep[fa[v][i]] &gt;= dep[u]) v = fa[v][i];    if (u == v) return u;    for (int i = t; i &gt;= 0; --i)        if (fa[u][i] != fa[v][i]) {            u = fa[u][i]; v = fa[v][i];        }    return fa[u][0];}int main() {    n = rd(); m = rd(); rot = rd();    t = __lg(n - 1) + 1;    for (int i = 1; i &lt;= n - 1; ++i) {        int u = rd(), v = rd();        e[u].push_back(v); e[v].push_back(u);    }    fa[rot][0] = rot; dfs(rot);    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd();        int ans = lca(u, v);        printf(\"%d\\n\", ans);    }    return 0;}\n三HDU ​​​ 树上两点距离\n树上两个点的距离，可以转换为两个点到根节点的距离减去两倍他们的  到根节点的距离。\n#include&lt;bits/stdc++.h&gt;using namespace std;#define N 500007typedef long long ll;vector&lt;pair&lt;int, int&gt; &gt; e[N];int fa[N][21], dep[N], sum[N], t, n, m, rot;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}inline void dfs(int u) {    for (int i = 1; i &lt;= t; ++i)            fa[u][i] = fa[fa[u][i - 1]][i - 1];    for (auto cur : e[u]) {        int v = cur.first, w = cur.second;        if (v != fa[u][0]) {            fa[v][0] = u;            dep[v] = dep[u] + 1;            sum[v] = sum[u] + w;            dfs(v);        }    }}inline int lca(int u, int v) {    if (dep[u] &gt; dep[v]) swap(u, v);    for (int i = t; i &gt;= 0; --i)        if (dep[fa[v][i]] &gt;= dep[u]) v = fa[v][i];    if (u == v) return u;    for (int i = t; i &gt;= 0; --i)        if (fa[u][i] != fa[v][i]) {            u = fa[u][i]; v = fa[v][i];        }    return fa[u][0];}inline int getlen(int u, int v) {    int ans = lca(u, v);    return sum[u] + sum[v] - 2 * sum[ans];}inline void work(){    n = rd(); m = rd();    t = __lg(n - 1) + 1;    for (int i = 1; i &lt;= n - 1; ++i) {        int u = rd(), v = rd(), w = rd();        e[u].push_back(make_pair(v, w)); e[v].push_back(make_pair(u, w));    }    fa[1][0] = 1; dfs(1);    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd();        printf(\"%d\\n\", getlen(u, v));    }}int main() {    int t = rd();    while (t--) work();    return 0;}\n四HDU ​\n 不只一棵树。\n#include&lt;bits/stdc++.h&gt;using namespace std;#define N 10007typedef long long ll;vector&lt;pair&lt;int, int&gt; &gt; e[N];int fa[N][15], dep[N], sum[N], t, n, m, c;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}inline void dfs(int u) {    for (int i = 1; i &lt;= t; ++i)            fa[u][i] = fa[fa[u][i - 1]][i - 1];    for (auto cur : e[u]) {        int v = cur.first, w = cur.second;        if (v != fa[u][0]) {            fa[v][0] = u;            dep[v] = dep[u] + 1;            sum[v] = sum[u] + w;            dfs(v);        }    }}inline int lca(int u, int v) {    if (dep[u] &gt; dep[v]) swap(u, v);    for (int i = t; i &gt;= 0; --i)        if (dep[fa[v][i]] &gt;= dep[u]) v = fa[v][i];    if (u == v) return u;    for (int i = t; i &gt;= 0; --i)        if (fa[u][i] != fa[v][i]) {            u = fa[u][i]; v = fa[v][i];        }    if (fa[u][0] != fa[v][0]) return -1;    return fa[u][0];}inline int getlen(int u, int v) {    int ans = lca(u, v);    if (ans == -1) return -1;    return sum[u] + sum[v] - 2 * sum[ans];}inline void work(){    for (int i = 1; i &lt;= n; ++i) {e[i].clear(); sum[i] = dep[i] = fa[n][0] = 0;}    t = __lg(n - 1) + 1;    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd(), w = rd();        e[u].push_back(make_pair(v, w)); e[v].push_back(make_pair(u, w));    }    for (int i = 1; i &lt;= n; ++i)        if (dep[i] == 0) {            fa[i][0] = i; dfs(i);        }    for (int i = 1; i &lt;= c; ++i) {        int u = rd(), v = rd();        int ans = getlen(u, v);        ans == -1 ? puts(\"Not connected\") : printf(\"%d\\n\", ans);    }}int main() {    while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; c) work();    return 0;}\n五树上前缀和/差分\n洛谷 \n在一个树上，按 ​ 的顺序走，每路上每次经过的每个点都需要放一颗糖，问每个点各需要放多少颗糖。\n本质就是对一个区间里面的数，都 +1。\n树上前缀和，对于一条从点  到点  的路径，差分数组 d[u]++; d[v]++; d[lca(u, v)]--; d[fa[lca(u, v)][0]]--; \n注意：fa[1][0] = 0;\n因为对于从  开始以后的点，又是前一段的终点，又是后一段的起点，只用 +1，但我们重复计算，故需要再最后依次 -1。\n#include&lt;bits/stdc++.h&gt;using namespace std;#define N 300007typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}vector&lt;int&gt; e[N];int t, fa[N][20], dep[N], d[N], a[N];inline void dfs(int x) {    for (int i = 1; i &lt;= t; ++i)        fa[x][i] = fa[fa[x][i - 1]][i - 1];    for (auto j : e[x]) {        if(j != fa[x][0]) {            fa[j][0] = x;            dep[j] = dep[x] + 1;            dfs(j);        }    }}inline int lca(int u, int v) {    if (dep[u] &gt; dep[v]) swap(u, v);    for (int i = t; i &gt;= 0; --i)        if (dep[fa[v][i]] &gt;= dep[u]) v = fa[v][i];    if (u == v) return u;    for (int i = t; i &gt;= 0; --i)        if (fa[u][i] != fa[v][i]) {            u = fa[u][i]; v = fa[v][i];        }    if (fa[u][0] != fa[v][0]) return -1;    return fa[u][0];}inline void dfs2(int x) {    for (auto i : e[x])        if (i != fa[x][0]) {            dfs2(i);            d[x] += d[i];    }}int main() {    int n = rd(); t = __lg(n - 1) + 1;    for (int i = 1; i &lt;= n; ++i) a[i] = rd();    for (int i = 1; i &lt;= n - 1; ++i) {        int u = rd(), v = rd();        e[u].push_back(v); e[v].push_back(u);    }    fa[1][0] = 0; dep[1] = 1; dfs(1);    for (int i = 1; i &lt; n; ++i) {        int ans = lca(a[i], a[i + 1]);        d[a[i]]++; d[a[i + 1]]++; d[ans]--; d[fa[ans][0]]--;    }    dfs2(1);    for (int i = 2; i &lt;= n; ++i) --d[a[i]];    for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", d[i]);    return 0;}\n六判断树上两条路径是否有交点\n洛谷 \n注意到树形结构不会出现环，所以如果有交必然有一个 Lca 在另一个 Lca 到产生它的两个节点的路径之一上。\n\n#include&lt;bits/stdc++.h&gt;using namespace std;#define N 100007typedef long long ll;inline int rd() {  int x = 0;  bool f = 0;  char c = getchar();  for (; !isdigit(c); c = getchar()) f |= (c == '-');  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);  return f ? -x : x;}vector&lt;int&gt; V[N];int t, fa[N][20], dep[N];inline void dfs(int x) {    for (int i = 1; i &lt;= t; ++i)        fa[x][i] = fa[fa[x][i - 1]][i - 1];    for (auto j : V[x]) {        if(j != fa[x][0]) {            fa[j][0] = x;            dep[j] = dep[x] + 1;            dfs(j);        }    }}inline int lca(int u, int v) {    if (dep[u] &gt; dep[v]) swap(u, v);    for (int i = t; i &gt;= 0; --i)        if (dep[fa[v][i]] &gt;= dep[u]) v = fa[v][i];    if (u == v) return u;    for (int i = t; i &gt;= 0; --i)        if (fa[u][i] != fa[v][i]) {            u = fa[u][i]; v = fa[v][i];        }    if (fa[u][0] != fa[v][0]) return -1;    return fa[u][0];}inline int getlen(int u, int v) {    int ans = lca(u, v);    if (ans == -1) return -1;    return dep[u] + dep[v] - 2 * dep[ans];}inline bool valid(int m, int l, int r) {    return (lca(l, m) == m &amp;&amp; dep[m] &gt;= dep[r]);}inline bool check(int a, int b, int c, int d) {    int l1 = lca(a, b), l2 = lca(c, d);    return (valid(l2, a, l1) || valid(l2, b, l1) || valid(l1, c, l2) || valid(l1, d, l2));}int main() {    int n = rd(), q = rd(); t = __lg(n - 1) + 1;    for (int i = 1; i &lt;= n - 1; ++i) {        int u = rd(), v = rd();        V[u].push_back(v); V[v].push_back(u);    }    for (int i = 1; i &lt;= n; ++i)        if (dep[i] == 0) {            fa[i][0] = i; dfs(i);        }    for (int i = 1; i &lt;= q; ++i) {        int a = rd(), b = rd(), c = rd(), d = rd();        puts(check(a, b, c, d) ? \"Y\" : \"N\");    }    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"pronounciation","url":"/2021/08/03/pronounciation1/","content":"Practice…\n\nI saw the most beautiful thing ever one morning.\nIt was early with a slight frost on the ground,\nand I was walking on dewy grass down to the horse paddocks\n- my mind on the days chores.\nSuddenly a blazing laser flash erupted straight from the ground about 15 feet in front of me,\nand shot up into the sky.\nIt was so brilliant, clear and clean, it literally topped me in my tracks.\nI thought the only thing that could make such a dazzling flash must be a diamond\n- maybe someone had lost some kind of jewelry.\nOr some kind of weird reverse lightning strike\n- so bright.\nI waited to see if it repeated but it didn’t.\nI walked slowly towards it.\nThere was nothing to see.\nI stared down at the grass,\nsearching for a glint of gold or some kind of metal.\nNothing.\nSo I dropped down really close and there it was!\nA tiny - no bigger than a dime - trapdoor spider’s web,\ndelicately hanging between blades of grass,\nglistening with miniature drops of dew,\nflashing and twinkling in a myriad of colors.\nThe rising sun had caught the exact angle of the dewdrops,\nand that laser light had exploded up into the sky.\nIt was incredible and stunning,\nsuch a powerful flash from something so small and fragile,\nand I would have crushed it beneath my feet.\nIt was as though the unseen world was giving me a heads-up.\nHello! Look what’s around you.\nI’ve never forgotten that moment.\nSo I say to everyone-\ntake some time to notice the miracle of nature that most of us never even see.\nSo much beauty all around us if we would only take the time.\nLook at the brilliant colors and intricate patterns of tiny flowers that cover playing fields\n- we walk all over them without a second glance.\nWatch a bee harvesting pollen .\nSo busy with a purpose.\nTiny ants going about their day.\nBirds singing and fluffing their wings, being bossy.\nBusy iridescent beetles and glossy lizards.\nThe subtle shading and colors of practically any flower on earth are breathtaking and all natural\n- if we would only notice.\nIt doesn’t have to be a garden.\nIt can even be a weed flowering in the pavement crack.\nSo I say -\ntake the time\nand each day discover from nature one secret beautiful thing that you can keep in your heart.\nAnd get your children to do the same.\nTake a picture.\nit’s what life really consists of.\nAnd it’s free.\n","categories":["HDU's Learning"],"tags":["English speech"]},{"title":"pronounciation2","url":"/2021/08/12/pronounciation2/","content":"Imitate to improve pronounciation and intonation.\n\nSelf-education will make you a fortuneFormal education will make you a living. Self-education will make you a fortune. Formal education is standard, structured and systematic education. It is what you learn in schools and colleges. \nThere’s nothing wrong with formal education, but it is designed to get you a job, or make you a living. It is not designed to make you financially free or mentally strong. It is designed to keep you part of the system. There are limits to how far you can go with formal education. It is for people who want limited risk, and not much responsibility. Self-education knows no limits and that is why it has the potential to make you a fortune.\nSelf-education can not only make you a fortune, it can also make you fulfilled – because it gives you the choice to educate yourself on things that will enhance the quality of your life. Think of all the greatest entrepreneurs of today, and in history, these are all self-educated people. They’re all likely formally educated as well. But for all successful people, self-education never ends, not after school, not after success or failure. Life is the classroom and the only goal is to learn and grow every day. The major value in life is not what you get. The major value in life is what you become. The major question to ask is not “what am I getting here”. The major question to ask is “what am I becoming here”. It’s never the material success that gives us the most value – it is the self-pride that comes when you extend yourself. It’s not the money, or the house that will bring you the joy. It is the pride in knowing you earn the money and the house. That is where the value is, and you won’t get the money or the house without it. You won’t get anything more until you become more.\nIf you don’t design your own life plan, chances are you’ll fall into someone else’s life plan. And guess what they have planned for you? Not much. If you’re waiting for others to hand you success, you’ll be waiting with your hand out until your dying day. If you want anything in life, the responsibility falls on only one person, and that person is you. No one owes you anything. If you want it, you must plan for it. If you want it, you must sacrifice for it. If you want it, you must work for it.\nDon’t wait for anyone to give you a handout, or a magic map to achieve the life you want. You have to educate and execute your own life plan to live the life you want to live.\n正规教育让你有谋生的手段，自我教育会使你获得财富。正规教育是规范化、结构化、系统化的教育，是你在学校里所学的东西。\n正规教育无可厚非，但它不会让你实现财富自由，或者是内心强大。它仅仅是为了让你找份工作，聊以谋生，从而成为社会系统中的一部分。接受正规教育会让你的前程受到诸多限制。这种教育是为那些保守且不想承担太多责任的人准备的。而自我教育是不设限的，因此它有可能给你带来真正的财富。\n自我教育不仅能给你带来财富，它还会让你获得成就感，因为你可以主动选择学习那些能提高你的生活质量的东西。从古至今，那些最伟大的企业家，他们都是自学成才的，他们也可能接受过正规教育。但是对所有成功者而言，无论是课前课后，无论成功失败，自我教育永无止境。生活本就是课堂，我们唯一的目标就是每天的学习和成长。\n人生的主要价值不是你得到了什么，而是你成为了什么样的人。关键问题不是“我会有何收获”，而是“我会成为怎样的人”。物质方面的成就从来都不会带来最大的价值。只有当你提升自己时，才会感到自豪。带给你快乐的不是金钱或者房子，而是你关于金钱和房子的认知，这种认知带来的自豪感才是最有价值的。没有它，你也不会拥有金钱或者房子。你要让自己变得更有价值，然后才能更加富有。\n如果你不制定自己的生活规划，那就很有可能掉入别人的计划之中。想想他们为你计划了什么？少之又少。如果你在等待别人把成功交到你的手上，那么你就会一直等待，直到生命的最后一天。生活中如果你想要任何东西，那责任只能落在一个人身上，那个人就是你。没有人亏欠你。如果你想得到，你必须有所计划。如你想得到，你必须有所牺牲。如果你想得到，你必须有所作为。\n不要等待任何人给你施舍，或者给你一张实现理想生活的魔法图。你必须进行自我教育并且执行人生规划，从而让自己过上理想的生活。\nYour word are powerfulYour words, mixed with your beliefs, blend to become your reality. What you speak over your life is what your life will become.\nIf you’re always talking about how you’re stuck where you are… how you can’t find a way to out of the situation you’re in… how you never get any luck… how you’ll never be wealthy… well, you’re right. You’ll never have those things if that’s what you say, and that’s what you believe. If you don’t believe it, you won’t even try to get it. \nInstead of saying: “I don’t know how to do it”… Say: “I am committed to learn how to do it.” Instead of saying: “I always procrastinate and never get anything done”… Say: “I am going to find something that matters to me more than anything, and then I am going to get the job done!” Instead of saying: “I’m a failure”… Say: “I’ve failed… I’ve learned the lesson and when I become a huge success, that failure is going to make for one hell of a story.” Instead of saying: “My best days are behind me”… Say: “My best is yet to come!” Instead of believing others are born lucky or with special gifts. Know that you are capable of anything. Know that you can study and commit to learn from great people. Know that you can become a great person in your own right.\nEvery day, look yourself in the mirror and say:\nI am a great person.\nI am a kind person.\nI am strong.\nI am capable of anything.\nI am growing more each day.\nI am committed.\nI am determined.\nI have no limits.\nI can have the health and the body of my choice.\nI will have the health and the body of my choice.\nI can have the wealth of my choice.\nI will have the wealth of my choice.\nI do deserve abundance.\nI am worthy.\nI am more than worthy.\nI can make a huge difference in others’ lives.\nI will make that difference.\nGandhi once said: “Your beliefs become your thoughts. Your thoughts become your words. Your words become your actions. Your actions become your habits. Your habits become your values. Your values become your destiny.” When you stop blending your beliefs and your words together, they become so powerful you can move mountains. You are the creator of your destiny, and it starts with the words you speak into your life.\nSpeak positive things into your life, strong things, speak love and happiness into your life and you’ll notice more love and happiness. Speak good of others and you’ll see more good from others. Speak your dreams into existence. Believe your dreams will become reality. Act and live as though they are and they soon will be.\n你的言语和你的信念，它们相互融合，形成你所面对的现实。你关于生命的那些言论，最终会在你的生命中应验。\n如果你总是抱怨：你是如何被陷入困境的，你找不到摆脱困境的方法，你一点运气都没有，你永远都不会富有……那好吧，你说的都对。如果你就是这么说的，那你永远也不会拥有这些东西。因为如果连你都不相信自己可以拥有它们，那么你根本都不会去争取。\n不要说：“我不知道该怎么做”，而要说：“我会努力学习怎么做”。不要说：“我总是拖延，从来没有完成任何事情”，而要说：“我要找到一些至关重要的事情，然后我会把它完成！”不要说：“我是个失败者”，而要说：“我失败了，但我从中吸取了教训。当我取得巨大成功时，那次失败将成为一个传奇般的故事。”不要说：“我最美好的日子已经过去了”，而要说：“我最美好的日子还没有到来！”不要相信别人生来就幸运或者有特殊的天赋。要知道你无所不能。要知道你可以努力向伟大的人学习。要知道你可以凭借自己的能力成为一个伟大的人。\n每一天，对着镜子中的自己说：\n我是一个伟大的人。\n我是一个善良的人。\n我很强壮。\n我无所不能。\n我每天都在成长。\n我尽心尽力。\n我坚决果断。\n我无拘无束。\n我能拥有自己选择的健康和身体。\n我将拥有我选择的健康和身体。\n我能拥有我选择的财富。\n我将拥有我选择的财富。\n我应该得到更多。\n我是值得拥有这些。\n我完全配得上这些。\n我能给别人的生活带来巨大的改变。\n我将有所成就。\n甘地曾经说过：“你的信念会变成你的思想。你的思想会变成你的语言。你的言语会变成你的行为。你的行为会变成你的习惯。你的习惯会成为你的价值观。你的价值观将决定你的命运。”当你不再将自己的信念和言语混为一谈时，它们会变得非常强大，你可以借此移山越岭。你是你命运的创造者，从你对生活说的每一句话开始。\n把积极、力量、爱和幸福说给自己听，然后你会发现生活中会有更多的爱和幸福。多说别人的好话，你会从他们身上看到更多的美好。对着现实说出你的梦想。相信你的梦想将会变成现实。去付出行动，好好生活吧，就好像你的梦想已经或者将要实现了一样。\nOur planetJust 50 years ago, we finally ventured to the moon. For the very first time, we look back at our own planet. Since then, the human population has more than doubled. This series will celebrate the natural wonders that remain and reveal what we must preserve to ensure people and nature thrive.\nWhen human beings built their first settlements some 1000 years ago, the world around them, on the land and in the sea, was full of life. For generations, this stable Eden nurtured our growing civilization, but now in the space of just one human lifetime, all that has changed. In the last 50 years, wildlife populations have on average declined by 60 percent. \nFor the first time in human history, the stability of nature can no longer be taken for granted. But the nature world is resilient. Great rich still remain. And with our help, the planet can recover. Never has it been more important to understand how the nature world works, and how to help it.\n","categories":["HDU's Learning"],"tags":["English speech"]},{"title":"扫描线","url":"/2022/08/19/scan-line/","content":"“你长大后想成为什么样的人？”\n“善良的人。” 男孩说。\n\n重点把一个矩阵分成横竖两种边界，线性扫描一种边界，另一种边界转换成区间和或差等信息，用前缀和或者线段树维护区间信息。\n矩形面积并题目： https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/4/DSL_4_A\n思路：扫描线从左往右扫描，遇到左边界时，对应的区间 +1 ，遇到右边界时，对应的区间 -1 。用线段树维护区间加减情况，并统计在该区间里非 0 的位置个数。线段树，用 sum 维护非 0 位置的个数，tag 维护该区间的和。\n注意点：因为要维护的区间是从 -1e9 到 1e9 ，区间比较大需要动态开点。因为这道题有一个比较特殊的性质，就是每一个左边界一定有一个对应的右边界，所以只要区间的 tag 不为 0（即大于 0 ），那 sum 就是区间长度，否则就是左右儿子的和。每次答案的增量就是，整个区间的 sum 即 c[1].sum 乘上横轴移动的距离。\n细节：需要把线段树维护的整个区间右移到 1 到 2e9+1 ，不然计算 mid 的时候可能会出现问题，同时在计算 mid 的时候需要用 unsigned \n#define N 10000007int totnode, root;struct node {int ls, rs, sum, tag;} c[N];void pushup (int rt, int l, int r) {    if (c[rt].tag) c[rt].sum = r - l + 1;    else c[rt].sum = c[c[rt].ls].sum + c[c[rt].rs].sum;}void update(int &amp;rt, int l, int r, int L, int R, int val) {    if (!rt) rt = ++totnode;    if (L &lt;= l &amp;&amp; r &lt;= R) {        c[rt].tag += val; pushup(rt, l, r);        return;    }    int mid = ((unsigned)l + (unsigned)r) &gt;&gt; 1;    if (L &lt;= mid) update(c[rt].ls, l, mid, L, R, val);    if (R &gt; mid) update(c[rt].rs, mid + 1, r, L, R, val);    pushup(rt, l, r);}struct query {int x, l, r, f;};vector&lt;query&gt; q;inline bool cmp (query a, query b) {return a.x &lt; b.x;}int main() {    int n = rd();    for (int i = 1; i &lt;= n; ++i) {        int x1 = rd(), y1 = rd(), x2 = rd(), y2 = rd();        q.push_back(query{x1, y1 + 1000000001, y2 + 1000000000, 1});        q.push_back(query{x2, y1 + 1000000001, y2 + 1000000000, -1});    }    sort(q.begin(), q.end(), cmp);    ll ans = 0; int lst = q[0].x;    for (int i = 0; i &lt; (int)q.size();) {        int x = q[i].x; ans += 1ll * c[1].sum * (x - lst);        while (i &lt; (int)q.size() &amp;&amp; q[i].x == x) {            update(root, 1, 2e9 + 1, q[i].l, q[i].r, q[i].f);            ++i;        }        lst = x;    }    printf(\"%lld\\n\", ans);    return 0;}\n数矩形内有多少个点","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"杂想1","url":"/2021/08/04/thinking1/","content":"真实自有万钧之力\n\n\n很多事情，说起来词不达意，不说又被认为刻意隐瞒\n很多事情，我不理解，却当眼泪夺眶时逐渐明晰\n《看见》中的话 —— “真实自有万钧之力”\n很多事情，我觉得我无法理解，我觉得我无法被理解\n面对这些事情，我只想说，真实自有万钧之力\n\n以前，面对两个弟弟\n当他们犯错时，我很想纠正他们的行为\n只要他们不重蹈覆辙，我就会认为，犯错的事情过去了\n直到如今，我已经是一名大学生了\n弟弟们也长大了\n一个也读了大学，另一个则在美国求学\n很多时候，我很感恩，爸爸妈妈给了我两个弟弟\n现在也是\n弟弟们长大了，可是还是会犯错\n我也是\n可如今，当我面对犯错的他们时，我不再去纠结对错\n不是我不知道何为对、何为错，而是我发觉对于 “孩子” 来说\n有时，他们的感情远比事情的对错更为重要\n因为，当我犯错被责骂时，我心里是多么的清楚，“我错了”\n比起对我的指责，我更希望有人能关注我的感情\n犯错的孩子，心里也总是不好受的吧，尤其是明知故犯的孩子\n\n“你不必把自己装成姐姐的样子”\n“可我就是姐姐啊”\n“所以你不用装”\n\n想对妹妹说\n生活很美好\n世界不如想象般宁静，却要用心灵的平安与喜乐与世界抗衡\n\n想对所有 fall in love 的人说\n不管你该不该在你的年龄进入恋爱\n请享受纯粹的幸福，细心呵护，双向奔赴\n","categories":["HDU's Life"],"tags":["Daily"]},{"title":"杂想2","url":"/2021/08/07/thinking2/","content":"我将永远困惑，也永远寻找。困惑是我的诚实，寻找是我的勇敢。——周国平\n\n篇（一）那天见了她，我才对一句话有所体会\n“婚姻可以改变一个女人的一辈子”\n认识她是在好多年前，那时候的她正在闹离婚，也许是已经离了\n她有一个女儿，瘦瘦的，有点皮\n当时还是个小丫头，喜欢画画，玩儿起来比谁都疯\n回忆起那时候的她\n印象里是高梳着辫子，穿着一身紧致的衣服\n不怎么光滑的脸上涂满了”胭脂腮红“\n脸上也时常挂满笑容，却藏不住眉宇间的一抹忧伤\n她很爱小丫头，甚至有一点宠溺\n我因转学到杭州读书，便许久没有见过她\n前几天，她联系我说，近月里她待在杭州，得知我也在此，能否聚一聚\n我去了\n见面之前我对她近况的了解就是，再婚后生了一个女儿，且那个小丫头有些许抑郁\n他们是为了给小丫头看医生，才在杭州久待了些时日\n再见面时，她穿着一身暗淡无光，宽松肥大的衣服\n手里多了个两个月大的女儿，人也发福了不少\n我们一起逛了逛，然后吃了顿饭\n她变了\n蓬松的头发，肥大的衣服\n脸上除了岁月的痕迹，别无他物\n她笑起来时，连眉毛都在笑\n那个小丫头还是如以往般皮，随着年龄的增加，逐渐有了些恋财的感觉\n每当小丫头不听话时，她总是很耐心地引导小丫头\n至于那个两个月大的女儿，她笑着对我说：”她很听话，不哭也不闹“\n她总是会看看两个月大的女儿，然后嘴角扬起笑容\n我不知道我更喜欢什么时候的她\n以前的她，看起来美丽，却不那么喜悦\n如今的她，看起来苍老疲惫，却总能用眉头在笑\n也许她更享受现在点滴的幸福吧\n\n篇（二）最近总是长坐在实验室里，打着自己也不是很懂的代码\n有人问我，你喜欢学计算机吗\n我觉得，作为一个意外考入卓越学院计科英才班的我，很难回答\n我从来没有想过自己会学计算机，更没想到会在杭电学计算机\n有的时候，我也会想象，自己坐在桌子前打代码的样子\n有些欣慰，也有些遗憾\n不管怎么说，也不能说毫无兴趣，继续加油吧\n况且我还不是一个人\n\n篇（三）困惑就是\n为什么我还不会化妆，且没有动力去学\n寻找就是\n在学着打扮了\n嘻嘻嘻\n","categories":["HDU's Life"],"tags":["Daily"]},{"title":"二维差分与前缀和","url":"/2022/08/20/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/","content":"“最难原谅的人往往就是你自己。”\n\n二维前缀和\nsum[x][y] = \\sum_{i = 1}^x \\sum_{j = 1}^y a[i][j]几何意义：以  为左上角， 为右下角的矩形里的元素之和。\n二维差分差分的前缀和是原来的单点值，即\n\na[x][y] = \\sum_{i = 1}^x \\sum_{j = 1}^y d[i][j]现在想推出差分数组等于什么\n\n\\begin{array} {cll}\nd[x][y] & = & \\sum_{i = 1}^x \\sum_{j = 1}^y d[x][y] - \\sum_{i = 1}^x \\sum_{j = 1}^{y - 1} d[i][j] - \\sum_{i = 1}^{x - 1} \\sum_{j = 1}^y d[i][j] + \\sum_{i = 1}^{x - 1} \\sum_{j = 1}^{y - 1} d[i][j]\n\\\\\n& = & a[x][y] - a[x][y - 1] - a[x - 1][y] + a[x - 1][y - 1]\n\\end{array}要给二维平面上的一个矩形区域 +1 ，转换成单点的加减。即要给左上角为 (xl, yl) ，右下角为 (xr, yr) 的矩形范围里的点 +1 （包括边界），转换成下面的四个单点变化：\nd[xl][yl]++; d[xr + 1][yr + 1]++；d[xl][yr + 1]--; d[xr + 1][yl]--;\n例题https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/5/DSL_5_B\nThe Maximum Number of OverlapsGiven a set of  axis-aligned rectangular seals, find the number of overlapped seals on the region which has the maximum number of overlapped seals.InputThe input is given in the following format.\n\n\\begin{aligned}\n&N \\\\\n&x 1_{1} y 1_{1} x 2_{1} y 2_{1} \\\\\n&x 1_{2} y 1_{2} x 2_{2} y 2_{2} \\\\\n&: \\\\\n&x 1_{N} y 1_{N} x 2_{N} y 2_{N}\n\\end{aligned} and  are the coordinates of the top-left and the bottom-right corner of the -th seal respectively.Constraints\n\n\n\n\n are given in integersOutputPrint the maximum number of overlapped seals in a line.\n\n因为是求面积重合的最大值，就把每个矩形记到右下角上。即左上角要往右下移动一格。\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() {    int x = 0; bool f = 0; char c = getchar();    for (; !isdigit(c); c = getchar()) f |= (c == '-');    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);    return f ? -x : x;}#define N 1007int a[N][N];int main() {    int n = rd();    for (; n; --n) {        int xl = rd() + 1, yl = rd() + 1;        int xr = rd(), yr = rd();        a[xl][yl]++; a[xr + 1][yr + 1]++;        a[xr + 1][yl]--; a[xl][yr + 1]--;    }    int ans = 0;    for (int i = 1; i &lt;= 1000; ++i)         for (int j = 1; j &lt;= 1000; ++j) {            a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];            ans = max(ans, a[i][j]);        }    printf(\"%d\\n\", ans);    return 0;}","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"写博客","url":"/2021/01/18/%E5%86%99%E5%8D%9A%E5%AE%A2/","content":"Colin 教我写博客\n\n打广告 Colin’s Space\ncmd\n$ d:$ cd blog$ cd blog711$ hexo new posts haha &#x2F; $ hexo n &quot;haha&quot;$ hexo g$ hexo sctrl + cY$ hexo clean$ exit\n","categories":["HDU's Life"],"tags":["other"]},{"title":"岁月神偷","url":"/2021/08/11/%E5%B2%81%E6%9C%88%E7%A5%9E%E5%81%B7/","content":"时间是让人猝不及防的东西，晴时有风阴有时雨，争不过朝夕，又念着往昔。 ——岁月神偷\n\n\n昨天和 Colin 在肯德基看完了岁月神偷。\n内容梗概时代背景60年代的香港，风云变幻。一面要忍受港英政府的压制，一面又受到内地运动的波及，更要面对不时登陆的台风暴雨。老字号的永利街就处在这样一个风暴的旋涡中心。\n人物鞋匠罗一家四口，在街尾以做鞋为生。罗先生做得一手好鞋，在那个混乱的年代仅能养家糊口；罗太太为人辛辣直率，人称“侠盗罗嫂”。大儿子16岁，品学兼优，是运动会的冠军，全家人的希望，也是永利街的骄傲；小儿子8岁，在父母溺爱之下，天性顽劣，出了名的顽皮整蛊。\n剧情影片的故事以小弟的所见所闻作为线索展开叙事，展现了香港20世纪60年代社会最底层人民的感情与生活。\n讲了一个普普通通的家庭，靠做鞋、卖鞋为生。两个儿子：大儿子特别优秀，小儿子古灵精怪。但好景不长，鞋店先是遭受了台风的袭击。 “做人至少要保个顶”，在最危难的时候，罗先生和罗太太在阁楼上护顶，大儿子在楼下撑梁，小儿子害怕地抱住妈妈。风雨过后，一家人将一双双鞋从地上捡起来。大儿子倒地了。后经检查，确认大儿子患了绝症。父母为了操劳大儿子，几夜白头。最终离开。小儿子最后上了曾经哥哥在上的学校。\n杂想篇一先来说说小弟吧。他很可爱（鼻子和 Colin 好像……），也很顽皮。他总是会偷东西，把偷来的东西藏在包里。他很单纯，他相信奶奶说的，“只要用心爱的东西把苦海填满，就能见到想见的人”。哥哥死后，他把他偷来的东西都扔到了海里。哥哥生病住院，他去看哥哥，反复追问为什么自己不能去和妈妈说让哥哥回家住。哥哥不开心，他把自己偷来的东西，一件件拿出来给哥哥，最后无奈，因为这些东西，都不能让哥哥开心。\n小弟是幸福的，妈妈疼爸爸爱哥哥宠。小弟是幸福的，因为那个时候的他，并不用承担什么责任。小弟是幸福的，因为他还可以拥有放声大哭的能力。\n篇二再来说说哥哥进一吧。在整个剧中，他从刚开始的金牌获得者且有喜欢的女生，到后来生病和女生的移民。看似一些不好的事情都是发生在哥哥进一的身上。他走进女孩子家，发现他们之间的距离有多么遥不可及；站在医院的窗前，得知自己的疾病有多么令人绝望。\n但进一也是幸福的，无论在何种情况下，家人都在拼尽全力，带给他希望。弟弟会来陪他，妈妈会站在门外擦干眼泪后笑着来照顾他，爸爸愿意省吃俭用，从月初就开始省钱，为的是能早早给他交学费，不让他被同学看不起，愿意当掉最心爱的东西，来给他最好的东西。这个家为他牺牲了很多，他是幸福的。\n篇三最后来说说这一对相濡以沫的夫妻吧。影片当中对罗先生和罗太太的刻画还是很多的，也是影片最能打动人的两个人物。他们很真实，”难一步，佳一步“ 是对这对底层夫妻生活最有力的刻画。\n先生给太太做鞋，太太拿先生打趣，一点一滴的付出，都在给对方鼓励。\n我最难受的，应该是太太带着两个孩子去北京看病，先生留在鞋店。先生站在鞋店门口，看着远去的妻儿，挥了挥手。这一幕的分别，与发生台风时二人一起护顶，大儿子住院时一个修灯、一个刷匾形成了一定的对比。可能是作为一个女孩子，当能依靠的男人不能在自己身边时，就会比较担心害怕。\n有几个关于这对夫妻的场景，应该是让我印象比较深刻的。除了上面提到的两个，还有先生给太太介绍自己为她做的鞋，考虑到太太脚上的鸡眼，专门为她设计制作；在医院，先生掏出200块钱，说要给儿子输新鲜的血，太太看到钱，下意识伸手摸了摸先生的手，瞬间泪盈眶；儿子死后，先生拔树手心出血，然后伸手牵住了小弟。\n他们之间，从来不需要多说什么，彼此真的了解、理解对方。\nColin 说，这对夫妻让他想到了身边的很多人，那些最平凡的底层人，靠自己的血汗，养活一个家。确实吧，生活确实并不是一件容易的事情，我们在这个社会上，都算是无比幸运的人吧。\n”总要信“\n番外篇好羡慕小弟，被揍以后有爸爸抱着安慰给糖吃。嘻嘻嘻\n","categories":["HDU's Life"],"tags":["movie"]},{"title":"无问西东","url":"/2021/07/29/%E6%97%A0%E9%97%AE%E8%A5%BF%E4%B8%9C/","content":"一路走来，一路盛开\n\n经典语录\n如果提前了解了你们要面对的人生，不知道你们是否还会有勇气前来。\n这个世界缺的不是完美的人，而是从心底给出的真心，正义，无畏与同情。\n看到和听到的，经常会令你们沮丧，世俗是这样强大，强大到生不出改变它们的念头来。可是如果有机会提前了解了你们的人生，知道青春也不过只有这些日子，不知你们是否还会在意那些世俗希望你们在意的事情。比如占有多少才更荣耀，拥有什么才能被爱。\n等你们长大，你们会因绿芽冒出土地而喜悦，会对初升的朝阳欢呼跳跃。也会给别人善意和温暖。但是却会在赞美别的生命的同时，常常，甚至永远地忘了自己的珍贵。愿你在被打击时，记起你的珍贵，抵抗恶意；愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。\n什么是真实？你看到什么，听到什么，做什么，和谁在一起。有一种从心灵深处满溢出来的不懊悔，也不羞耻的和平与喜悦。\n人把自己置身于忙碌之中，有一种麻木的踏实，但丧失了真实，你的青春不过只有这些日子。\n那一刻，我从思索生命意义的羞耻感中释放出来，希望你们今后的岁月里，不要放弃对生命的思索，对自己的真实。\n世界于你而言，毫无意义和目的，却又充满随心所欲的幻想。但又有谁知，也许就在这闷热令人疲倦的正午，那个陌生人，提着满篮奇妙的货物，路过你的门前，他响亮的叫卖着，你就会从朦胧的梦中惊醒，走出房门，迎接命运的安排——《泰戈尔的诗》。\n你别怕，我就是那个给你托底的人，我会跟你一起往下掉。不管掉得有多深，我都会在下面给你托着。我最怕的是，掉的时候你把我推开，不让我给你托着。\n他们的爱与风华，只问自由，只问盛放，只问深情，只问初心，只问勇敢，无问西东。\n你怪她没有真实，你给她真实的力量了吗？\n逝者已矣，生者如斯，对以后的人好吧。\n一生太短，一瞬好长，我们哭着醒来，又哭着遗忘。\n\n观后感什么是真正的平淡？真正的平淡是指，生命中曾经历过轰轰烈烈与刻骨铭心后，才感悟到平淡的可贵。而不是一生碌碌无为，却安慰自己平凡是真。\n电影前前后后讲了四个时代的故事，四个不同时代的年轻人分别做出了自己的选择。\n吴岭澜听了泰戈尔的演讲后，遵从本心选择了文学之路；沈光耀从军牺牲；被诬陷险些丧生王敏佳、边防献身者李想、核事业贡献者陈鹏；张果果真心帮助四胞胎一家，并拒绝 robert 的提议。\n他们做出无悔选择，结局或好或坏，终究死而无憾。\n坚持初心 &amp;&amp; 传递爱\n不忘初心，方得始终，念念不忘，必有回响。\n","categories":["HDU's Life"],"tags":["movie"]},{"title":"银河补习班","url":"/2021/07/30/%E9%93%B6%E6%B2%B3%E8%A1%A5%E4%B9%A0%E7%8F%AD/","content":"白驹过隙，将梦想藏在裙子里\n\n马皓文因一次意外事故而入狱，让他遗憾地错过了儿子七年的成长时光。用自己独特的教育方法和满满的爱给予儿子马飞自由成长的空间，教会儿子独立思考的能力和面对困难的勇气。\n台词集\n\n当你能够做到自己身处黑暗之中，还能把光明留给别人，你就是一个成年人了。\n不，他人生最重要的时刻，一定是均匀散在每一天。\n人生就像射箭，梦想就像箭靶子。如果箭靶子都找不到，你每天张弓有什么意义。\n该冒的险，我是不会错过的。\n永远不要停止思考，永远不要服输。只要你不害怕，没有人，能挡住你的去向。\n\n","categories":["HDU's Life"],"tags":["movie"]},{"title":"图论","url":"/2021/08/24/ColinClass5/","content":"跑图啰 ~ ~\n开一个新 oj，叫 Eva.oj 专门存放 Co 老师给 Eva 口述的题 ~ ~\n\n图是啥图吧，由点和边组成，点可能有点权，边呢也可能会有边权，边还可分为 有向边（出边&amp;入边）和 无向边 两种。\n存图矩阵（邻接矩阵）矩阵  ， 则认为有  条从  号点到  号点的边。如果保证不重边则可认为  代表边权。（总而言之，就是，  刻画了这两个点之间的某种关系）\n例1Eva.oj 0001\nInput Format\n第一行两个整数  。代表这个图有  个点， 条边。接下来  行，每行三个整数  代表有一条边从  指向  ，且该边的边权为  。\nOutput Format\n对于每个点，第一行输出该点共有几条出边，接下来对应输出，每条边指向的点和该边的边权。\n解1a[N][N] 存图，cnt[i] 存  号点的出边数。\n#include &lt;bits/stdc++.h&gt;#define N 1007using namespace std;int a[N][N];int cnt[N];int main(){\tint m, n;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1; i &lt;= m; ++i){\t\tint u, v, w;\t\tcin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\t\ta[u][v] = w;\t\tcnt[u]++;\t}\tfor(int i = 1; i &lt;= n; ++i){\t\tcout &lt;&lt; cnt[i] &lt;&lt; endl;\t\tfor(int j = 1; j &lt;= n; ++j){\t\t\tif(a[i][j]) cout &lt;&lt; j &lt;&lt; ' ' &lt;&lt; a[i][j] &lt;&lt; endl;\t\t}\t}\t\t\treturn 0;}\n邻接表如果一个图，有很多点，但边的数量却很少，如果用邻接矩阵存储，会浪费很多的资源，因此，我们选用邻接表的方式存储，有利于节省不必要的空间。\n例1Eva.oj 0002\n在 Eva.oj 0001 的基础上除去边权，即该图的边，无边权。\n解1#include &lt;bits/stdc++.h&gt;#define N 100007using namespace std;vector&lt;int&gt; a[N];int main(){\tint m, n;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1; i &lt;= m; ++i){\t\tint u, v;\t\tcin &gt;&gt; u &gt;&gt; v;\t\ta[u].push_back(v);\t}\tfor(int i = 1; i &lt;= n; ++i){\t\tcout &lt;&lt; a[i].size() &lt;&lt; endl;\t\tfor(auto j : a[i]){\t\t\tcout &lt;&lt; j &lt;&lt; endl;\t\t}\t}\treturn 0;}\n例2Eva.oj 0001 \nInput Format\n第一行两个整数  。代表这个图有  个点， 条边。接下来  行，每行三个整数  代表有一条边从  指向  ，且该边的边权为  。\nOutput Format\n对于每个点，第一行输出该点共有几条出边，接下来对应输出，每条边指向的点和该边的边权。\n\n现在又有边权啦，Eva 不会 pair ，所以写了结构体\n解2-1#include &lt;bits/stdc++.h&gt;#define N 100007using namespace std;struct node{\tint v, w;};vector&lt;node&gt; a[N];int main(){\tint m, n;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1; i &lt;= m; ++i){\t\tint u, v, w;\t\tcin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\t\ta[u].push_back((node){v, w});\t}\tfor(int i = 1; i &lt;= n; ++i){\t\tcout &lt;&lt; a[i].size() &lt;&lt; endl;\t\tfor(auto j : a[i]){\t\t\tcout &lt;&lt; j.v &lt;&lt; ' ' &lt;&lt; j.w &lt;&lt; endl;\t\t}\t}\treturn 0;}\n解2-2Co老师教Eva用 pair\n#include &lt;bits/stdc++.h&gt;#define N 100007using namespace std;vector&lt;pair&lt;int, int&gt; &gt; a[N];int main(){\tint m, n;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1; i &lt;= m; ++i){\t\tint u, v, w;\t\tcin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\t\ta[u].push_back(make_pair(v, w));\t}\tfor(int i = 1; i &lt;= n; ++i){\t\tcout &lt;&lt; a[i].size() &lt;&lt; endl;\t\tfor(auto j : a[i]){\t\t\tcout &lt;&lt; j.first &lt;&lt; ' ' &lt;&lt; j.second &lt;&lt; endl;\t\t}\t}\treturn 0;}\n链式前向星“星”即指针，可此指针非彼指针。先上代码吧 ~\n例1Eva.oj 0001\nInput Format\n第一行两个整数  。代表这个图有  个点， 条边。接下来  行，每行三个整数  代表有一条边从  指向  ，且该边的边权为  。\nOutput Format\n对于每个点，第一行输出该点共有几条出边，接下来对应输出，每条边指向的点和该边的边权。\n解1#include &lt;bits/stdc++.h&gt;#define N 100007#define M 10000007using namespace std;struct node{\tint v, w, nxt;}e[M], hd[N];int tot;inline void add(int u, int v, int w) {\t++tot;\te[tot].v = v; e[tot].w = w;\te[tot].nxt = hd[u].nxt;\thd[u].nxt = tot; ++hd[u].w;}int main(){\tint m, n;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1; i &lt;= m; ++i){\t\tint u, v, w;\t\tcin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\t\tadd(u, v, w);\t}\tfor(int i = 1; i &lt;= n; ++i){\t\tcout &lt;&lt; hd[i].w &lt;&lt; endl;\t\tfor(int j = hd[i].nxt; j; j = e[j].nxt ){\t\t\tcout &lt;&lt; e[j].v &lt;&lt; ' ' &lt;&lt; e[j].w &lt;&lt; endl;\t\t}\t}\treturn 0;}\nhd[N] 就是  号点到  号点的头，可以开成一个 int 数组，也可以开成 node 用 node 里的  ，来存储该点有几条出边。接下来要在这些头的后面，接上它的出边（一条边有边权，起点和指向的点三个信息，所以我们用一个结构体来存储这些信息）。\ne[M] 预留出  大小的空间，给每一条边。e[i] 中  就是每条边的编号。\n遍历图DFS深度优先搜索 —— ”一条路走到黑，走不动了退一步“\n例1Eva.oj 0003\n给一个无向图，输出连通块的数量。\nInput Format\n第一行两个整数  。代表这个图有  个点， 条边。接下来  行，每行两个整数  代表有一条边连接  和  。\nOutput Format\n一个整数代表连通块的数量。\n解1#include &lt;bits/stdc++.h&gt;#define N 100007using namespace std;vector&lt;int&gt; a[N];int vis[N];inline int dfs(int x){\tvis[x] = 1;\tfor(auto j : a[x])\t\tif(!vis[j]) dfs(j);}int main(){\tint m, n;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1; i &lt;= m; ++i){\t\tint u, v;\t\tcin &gt;&gt; u &gt;&gt; v;\t\ta[u].push_back(v);\t\ta[v].push_back(u);\t}\tint cnt = 0;\tfor(int i = 1; i &lt;= n; ++i){\t\tif(!vis[i]) {dfs(i);cnt++;}\t}\tcout &lt;&lt; cnt;\treturn 0;}\n例2Eva.oj 0004\n给一个  个点的无向图，输出连通块数，接下来  行，输出各个连通块所含点的数量，且按从小到大的顺序输出该连通块中点的编号。\nInput Format\n第一行两个整数  。代表这个图有  个点， 条边。接下来  行，每行两个整数  代表有一条边连接  和  。\nOutput Format\n第一行输出连通块数。接下来  行，每行若干个数字。第一个数字，代表连通块所含点的数量，后面按从小到的顺序，输出该连通块中点的编号。\n解2num 即为连通块的编号。\n#include &lt;bits/stdc++.h&gt;#define N 100007using namespace std;int vis[N];vector&lt;int&gt; a[N], s[N];inline int dfs(int x, int num){\tvis[x] = num;\ts[num].push_back(x);\tfor(auto j : a[x])\t\tif(!vis[j]) dfs(j, num);}int main(){\tint m, n;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1; i &lt;= m; ++i){\t\tint u, v;\t\tcin &gt;&gt; u &gt;&gt; v;\t\ta[u].push_back(v);\t\ta[v].push_back(u);\t}\tint cnt = 0;\tfor(int i = 1; i &lt;= n; ++i){\t\tif(!vis[i]) {dfs(i, ++cnt);}\t}\tcout &lt;&lt; cnt &lt;&lt; endl;    \tfor(int i = 1; i &lt;= cnt; ++i){\t\tsort(s[i].begin(), s[i].end());\t\tcout &lt;&lt; s[i].size() &lt;&lt; ' ';\t\tfor(auto j : s[i]){\t\t\tcout &lt;&lt; j &lt;&lt; ' ';\t\t}\t\tcout &lt;&lt; endl;\t}\treturn 0;}\n例3求细胞数量\nhttps://www.luogu.com.cn/problem/P1451\n解3本质就是求连通块数。要注意边界 invalid 函数用于判断当前点是否合法（在图的范围里）且该被访问（先前未被访问且是细胞的部分）。\n#include &lt;bits/stdc++.h&gt;#define N 107using namespace std;int n, m, vis[N][N], a[N][N];const int dx[4] = {-1, 1, 0, 0};const int dy[4] = {0, 0, -1, 1};inline bool invalid(int x, int y){\treturn x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; m || a[x][y] == 0 || vis[x][y];}inline int dfs(int x, int y){\tvis[x][y] = 1;\tfor(int i = 0; i &lt; 4; ++i){\t\t int tx = x + dx[i];\t\t int ty = y + dy[i];\t\t if(!invalid(tx, ty)) {dfs(tx, ty);}\t}}inline int rd(){\tchar c = getchar();\twhile(!isdigit(c)) c = getchar();\treturn c - '0';}int main(){\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1; i &lt;= n; ++i)\t\tfor(int j = 1; j &lt;= m; ++j) a[i][j] = rd();\tint cnt = 0;\tfor(int i = 1; i &lt;= n; ++i){\t\tfor(int j = 1; j &lt;= m; ++j)\t\t\tif(!invalid(i, j)) {dfs(i, j); ++cnt;}\t}\t\tcout &lt;&lt; cnt &lt;&lt; endl;\treturn 0;}\nBFS广度优先搜索 —— ”谁离我近（最短的距离）谁先出“\n例1求细胞数量\nhttps://www.luogu.com.cn/problem/P1451\n解1本质就是求连通块数。要注意边界 invalid 函数用于判断当前点是否合法（在图的范围里）且该被访问（先前未被访问且是细胞的部分）。\n#include &lt;bits/stdc++.h&gt;#define N 107using namespace std;queue&lt;pair&lt;int, int&gt; &gt; s;int n, m, vis[N][N], a[N][N];const int dx[4] = {-1, 1, 0, 0};const int dy[4] = {0, 0, -1, 1};inline bool invalid(int x, int y){\treturn x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; m || a[x][y] == 0 || vis[x][y];}inline void bfs(int x, int y){\tvis[x][y] = 1;\ts.push(make_pair(x, y));\twhile(!s.empty()){\t\tpair&lt;int, int&gt; t = s.front();\t\ts.pop();\t\tfor(int i = 0; i &lt; 4; ++i){\t\t\tint tx = dx[i] + t.first;\t\t\tint ty = dy[i] + t.second;\t\t\tif(!invalid(tx, ty)) {vis[tx][ty] = 1; s.push(make_pair(tx, ty));}\t\t}\t}}inline int rd(){\tchar c = getchar();\twhile(!isdigit(c)) c = getchar();\treturn c - '0';}int main(){\tscanf(\"%d %d\", &amp;n, &amp;m);\tfor(int i = 1; i &lt;= n; ++i)\t\tfor(int j = 1; j &lt;= m; ++j) a[i][j] = rd();\tint cnt = 0;\tfor(int i = 1; i &lt;= n; ++i){\t\tfor(int j = 1; j &lt;= m; ++j)\t\t\tif(!invalid(i, j)) {++cnt; bfs(i, j);}\t}\t\tprintf(\"%d\", cnt);\treturn 0;}\n例2Eva.oj 0004\n给一个  个点的无向图，输出连通块数，接下来  行，输出各个连通块所含点的数量，且按从小到大的顺序输出该连通块中点的编号。\nInput Format\n第一行两个整数  。代表这个图有  个点， 条边。接下来  行，每行两个整数  代表有一条边连接  和  。\nOutput Format\n第一行输出连通块数。接下来  行，每行若干个数字。第一个数字，代表连通块所含点的数量，后面按从小到的顺序，输出该连通块中点的编号。\n解2#include &lt;bits/stdc++.h&gt;#define N 100007using namespace std;int vis[N];queue&lt;int&gt; q; vector&lt;int&gt; a[N], s[N];inline void bfs(int x, int num){\tvis[x] = num;\ts[num].push_back(x);\tq.push(x);\twhile(!q.empty()){\t\tint t = q.front();\t\tq.pop();\t\tfor(auto i : a[t]){\t\t\tif(!vis[i]) {vis[i] = num; q.push(i); s[num].push_back(i);}\t\t} \t}}int main(){\tint m, n;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1; i &lt;= m; ++i){\t\tint u, v;\t\tcin &gt;&gt; u &gt;&gt; v;\t\ta[u].push_back(v);\t\ta[v].push_back(u);\t}\t\tint cnt = 0;\tfor(int i = 1; i &lt;= n; ++i){\t\tif(!vis[i]) {bfs(i, ++cnt);}\t}\tcout &lt;&lt; cnt &lt;&lt; endl;\t\tfor(int i = 1; i &lt;= cnt; ++i){\t\tsort(s[i].begin(), s[i].end());\t\tcout &lt;&lt; s[i].size() &lt;&lt; ' ';\t\tfor(auto j : s[i]){\t\t\tcout &lt;&lt; j &lt;&lt; ' ';\t\t}\t\tcout &lt;&lt; endl;\t}\treturn 0;}\n练练练例1海战\nhttps://www.luogu.com.cn/problem/P1331\n解1（bfs）保证连通块都是方形的。\n我的思路：判断存不存在不合法的点。即那种类似于三角直尺的点。\nCo老师的思路：记一下该连通块，上下左右四个边界，看连通块的大小是否等于边界围成的面积。\n#include &lt;bits/stdc++.h&gt;#define N 1007using namespace std;queue&lt;pair&lt;int, int&gt; &gt; s;int n, m, vis[N][N], a[N][N];const int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1};const int dy[8] = {0, 0, -1, 1, 1, -1, 1, -1};inline bool invalid(int x, int y){\treturn x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; m || a[x][y] == 0 || vis[x][y];}inline bool valid(int x, int y){\tfor(int i = 4; i &lt; 8; ++i){\t\tint tx = x + dx[i];\t\tint ty = y + dy[i];\t\tif(tx &lt;= 0 || tx &gt; n || ty &lt;= 0 || ty &gt; m || vis[tx][ty] == 1) continue;\t\tif(i == 4 &amp;&amp; vis[x - 1][y] == 1 &amp;&amp; vis[x][y + 1] == 1) return 0;\t\telse if(i == 5 &amp;&amp; vis[x - 1][y] == 1 &amp;&amp; vis[x][y - 1] == 1) return 0;\t\telse if(i == 6 &amp;&amp; vis[x + 1][y] == 1 &amp;&amp; vis[x][y + 1] == 1) return 0;\t\telse if(i == 7 &amp;&amp; vis[x + 1][y] == 1 &amp;&amp; vis[x][y - 1] == 1) return 0;\t}\treturn 1;}inline void bfs(int x, int y){\tvis[x][y] = 1;\ts.push(make_pair(x, y));\twhile(!s.empty()){\t\tpair&lt;int, int&gt; t = s.front();\t\ts.pop();\t\tfor(int i = 0; i &lt; 4; ++i){\t\t\tint tx = dx[i] + t.first;\t\t\tint ty = dy[i] + t.second;\t\t\tif(!invalid(tx, ty)) {vis[tx][ty] = 1; s.push(make_pair(tx, ty));}\t\t}\t}}inline int rd(){\tchar c = getchar();\twhile(c != '.' &amp;&amp; c != '#') c = getchar();\tif(c == '.') return 0;\telse if(c == '#') return 1;}int main(){\tscanf(\"%d %d\", &amp;n, &amp;m);\tfor(int i = 1; i &lt;= n; ++i)\t\tfor(int j = 1; j &lt;= m; ++j) a[i][j] = rd();\tint cnt = 0;\tfor(int i = 1; i &lt;= n; ++i){\t\tfor(int j = 1; j &lt;= m; ++j)\t\t\tif(!invalid(i, j)) {++cnt; bfs(i, j);}\t}\t\tfor(int i = 1; i &lt;= n; ++i){\t\tfor(int j = 1; j &lt;= m; ++j){\t\t\tif(vis[i][j] == 1 &amp;&amp; !valid(i, j)){\t\t\t\tprintf(\"Bad placement.\");\t\t\t\treturn 0;\t\t\t}\t\t}\t}\t\tprintf(\"There are %d ships.\", cnt);\treturn 0;}\n解2（dfs）#include &lt;bits/stdc++.h&gt;#define N 1007using namespace std;int n, m, vis[N][N], a[N][N];const int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1};const int dy[8] = {0, 0, -1, 1, 1, -1, 1, -1};inline bool invalid(int x, int y){\treturn x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; m || a[x][y] == 0 || vis[x][y];}inline bool valid(int x, int y){\tfor(int i = 4; i &lt; 8; ++i){\t\tint tx = x + dx[i];\t\tint ty = y + dy[i];\t\tif(tx &lt;= 0 || tx &gt; n || ty &lt;= 0 || ty &gt; m || vis[tx][ty] == 1) continue;\t\tif(i == 4 &amp;&amp; vis[x - 1][y] == 1 &amp;&amp; vis[x][y + 1] == 1) return 0;\t\telse if(i == 5 &amp;&amp; vis[x - 1][y] == 1 &amp;&amp; vis[x][y - 1] == 1) return 0;\t\telse if(i == 6 &amp;&amp; vis[x + 1][y] == 1 &amp;&amp; vis[x][y + 1] == 1) return 0;\t\telse if(i == 7 &amp;&amp; vis[x + 1][y] == 1 &amp;&amp; vis[x][y - 1] == 1) return 0;\t}\treturn 1;}inline void dfs(int x, int y){\tvis[x][y] = 1;\tfor(int i = 0; i &lt; 4; ++i){\t\tint tx = x + dx[i];\t\tint ty = y + dy[i];\t\tif(!invalid(tx, ty)) dfs(tx, ty);\t}}inline int rd(){\tchar c = getchar();\twhile(c != '.' &amp;&amp; c != '#') c = getchar();\tif(c == '.') return 0;\telse if(c == '#') return 1;}int main(){\tscanf(\"%d %d\", &amp;n, &amp;m);\tfor(int i = 1; i &lt;= n; ++i)\t\tfor(int j = 1; j &lt;= m; ++j) a[i][j] = rd();\tint cnt = 0;\tfor(int i = 1; i &lt;= n; ++i){\t\tfor(int j = 1; j &lt;= m; ++j)\t\t\tif(!invalid(i, j)) {++cnt; dfs(i, j);}\t}\t\tfor(int i = 1; i &lt;= n; ++i){\t\tfor(int j = 1; j &lt;= m; ++j){\t\t\tif(vis[i][j] == 1 &amp;&amp; !valid(i, j)){\t\t\t\tprintf(\"Bad placement.\");\t\t\t\treturn 0;\t\t\t}\t\t}\t}\t\tprintf(\"There are %d ships.\", cnt);\treturn 0;}\n例2填涂颜色\nhttps://www.luogu.com.cn/problem/P1162\n解2（dfs）题意：被  包围的  输出用  ，其余  还是输出  。保证该图中只有一个由  围成的圈。\n思路：从边界的  开始搜索，凡是搜到的点一定不在圈里。\n#include &lt;bits/stdc++.h&gt;#define N 1007using namespace std;int n, vis[N][N], a[N][N];const int dx[4] = {-1, 1, 0, 0};const int dy[4] = {0, 0, -1, 1};inline bool invalid(int x, int y){\treturn x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; n || a[x][y] == 1 || vis[x][y];}inline void dfs(int x, int y){\tvis[x][y] = 1;\tfor(int i = 0; i &lt; 4; ++i){\t\tint tx = x + dx[i];\t\tint ty = y + dy[i];\t\tif(!invalid(tx, ty)) dfs(tx, ty);\t}}inline int rd(){\tchar c = getchar();\twhile(!isdigit(c)) c = getchar();\treturn c - '0';}int main(){\tscanf(\"%d\", &amp;n);\tfor(int i = 1; i &lt;= n; ++i)\t\tfor(int j = 1; j &lt;= n; ++j) a[i][j] = rd();\t\tfor(int i = 1; i &lt;= n; ++i){\t\tif(a[i][1] == 0 &amp;&amp; vis[i][1] == 0) dfs(i, 1);\t\tif(a[i][n] == 0 &amp;&amp; vis[i][n] == 0) dfs(i, n);\t\tif(a[1][i] == 0 &amp;&amp; vis[1][i] == 0) dfs(1, i);\t\tif(a[n][i] == 0 &amp;&amp; vis[n][i] == 0) dfs(n, i);\t}\t\tfor(int i = 1; i &lt;= n; ++i){\t\tfor(int j = 1; j &lt;= n; ++j){\t\t\tif(j == 1){\t\t\t\tif(a[i][j] == 1) printf(\"1\");\t\t\t\telse if(a[i][j] == 0 &amp;&amp; vis[i][j] == 1) printf(\"0\");\t\t\t\telse printf(\"2\");\t\t\t}else{\t\t\t\tif(a[i][j] == 1) printf(\" 1\");\t\t\t\telse if(a[i][j] == 0 &amp;&amp; vis[i][j] == 1) printf(\" 0\");\t\t\t\telse printf(\" 2\");\t\t\t}\t\t}\t\tprintf(\"\\n\");\t}\t\treturn 0;}\n解2（bfs）#include &lt;bits/stdc++.h&gt;#define N 1007using namespace std;queue&lt;pair&lt;int, int&gt; &gt; q;int n, vis[N][N], a[N][N];const int dx[4] = {-1, 1, 0, 0};const int dy[4] = {0, 0, -1, 1};inline bool invalid(int x, int y){\treturn x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; n || a[x][y] == 1 || vis[x][y];}inline void bfs(int x, int y){\tvis[x][y] = 1;\tq.push(make_pair(x, y));\twhile(!q.empty()){\t\tpair&lt;int, int&gt; t = q.front();\t\tq.pop();\t\tfor(int i = 0; i &lt; 4; ++i){\t\t\tint tx = t.first + dx[i];\t\t\tint ty = t.second + dy[i];\t\t\tif(!invalid(tx, ty)){\t\t\t\tvis[tx][ty] = 1;\t\t\t\tq.push(make_pair(tx, ty));\t\t\t\t}\t\t}\t}}inline int rd(){\tchar c = getchar();\twhile(!isdigit(c)) c = getchar();\treturn c - '0';}int main(){\tscanf(\"%d\", &amp;n);\tfor(int i = 1; i &lt;= n; ++i)\t\tfor(int j = 1; j &lt;= n; ++j) a[i][j] = rd();\t\tfor(int i = 1; i &lt;= n; ++i){\t\tif(a[i][1] == 0 &amp;&amp; vis[i][1] == 0) bfs(i, 1);\t\tif(a[i][n] == 0 &amp;&amp; vis[i][n] == 0) bfs(i, n);\t\tif(a[1][i] == 0 &amp;&amp; vis[1][i] == 0) bfs(1, i);\t\tif(a[n][i] == 0 &amp;&amp; vis[n][i] == 0) bfs(n, i);\t}\t\tfor(int i = 1; i &lt;= n; ++i){\t\tfor(int j = 1; j &lt;= n; ++j){\t\t\tif(j == 1){\t\t\t\tif(a[i][j] == 1) printf(\"1\");\t\t\t\telse if(a[i][j] == 0 &amp;&amp; vis[i][j] == 1) printf(\"0\");\t\t\t\telse printf(\"2\");\t\t\t}else{\t\t\t\tif(a[i][j] == 1) printf(\" 1\");\t\t\t\telse if(a[i][j] == 0 &amp;&amp; vis[i][j] == 1) printf(\" 0\");\t\t\t\telse printf(\" 2\");\t\t\t}\t\t}\t\tprintf(\"\\n\");\t}\t\treturn 0;}\n例3我觉得，是个求最短路\nhttps://codeforces.com/problemset/problem/689/B\n解3#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;queue&lt;int&gt; q; vector&lt;int&gt; a[N];int n, vis[N];inline void bfs(int x){    vis[x] = 0;\tq.push(x);\twhile(!q.empty()){\t\tint t = q.front();\t\tq.pop();\t\tfor(auto i : a[t]){\t\t\tif(vis[i] == -1) {vis[i] = vis[t] + 1; q.push(i);}\t\t} \t}}int main(){\tscanf(\"%d, %d\", &amp;n);\tfor(int i = 1; i &lt;= n; ++i){\t\tvis[i] = -1;\t\tint u;\t\tcin &gt;&gt; u;\t\tif(u != i) a[i].push_back(u);\t\tif(i == 1) a[i].push_back(i + 1);\t\telse if(i == n) a[i].push_back(i - 1);\t\telse{\t\t\ta[i].push_back(i + 1);\t\t\ta[i].push_back(i - 1);\t\t}\t}\tbfs(1);\tfor(int i = 1; i &lt;= n; ++i){\t\tprintf(\"%d \", vis[i]);\t}\treturn 0;}\n\n做题有点上瘾……\n","categories":["HDU's Learning"],"tags":["Algorithm"]},{"title":"OpenCV (bilibili教程代码)","url":"/2021/07/26/OPENCV1-1/","content":"我是代码搬运机\n\ngithub.com\nChapter 1#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;/// &lt;summary&gt;/// Images/// &lt;/summary&gt;//void main() &#123;//\tstring path = &quot;Resources/test.png&quot;;//\tMat img=imread(path);//matrix data type 由opencv引入来处理图像//\timshow(&quot;Image&quot;, img);//\twaitKey(0);//增加延时，0表示无穷//&#125;/// &lt;summary&gt;/// Video/// //视频是一系列图像，需要遍历所有图像或帧 一一捕获并显示，因此将使用while循环/// &lt;/summary&gt;//void main() &#123;//\tstring path = &quot;Resources/test_video.mp4&quot;;//\tVideoCapture cap(path);//\tMat img;////\twhile (true) &#123;//\t\tcap.read(img);//\t\timshow(&quot;Image&quot;, img);//\t\twaitKey(20);//增加延时 20ms//\t&#125;//\t//&#125;/// &lt;summary&gt;/// Webcam/// 与导入视频不同的是，不需要视频路径，只需要给相机ID，id=0表示默认的摄像头/// &lt;/summary&gt;//void main() &#123;//\tVideoCapture cap(0);//相机id=0//\tMat img;//\t//while (true) &#123;\t//\tcap.read(img);\t//\timshow(&quot;Image&quot;, img);\t//\twaitKey(1);//增加延时 1ms，以免太慢\t//&#125;////&#125;\nChapter 2#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;/// &lt;summary&gt;/// Basic Function/// &lt;/summary&gt;//void main() &#123;//\tstring path = &quot;Resources/test.png&quot;;//\tMat img=imread(path);//matrix data type 由opencv引入来处理图像//\tMat imgGray,imgBlur,imgCanny,imgDil,imgErode;////\tcvtColor(img, imgGray, COLOR_BGR2GRAY);//cvt是convert的缩写，将图像从一种颜色空间转换为另一种颜色空间。//\tGaussianBlur(imgGray, imgBlur,Size(7,7),5,0);//使用高斯滤波器模糊图像。该函数将源图像与指定的高斯核进行卷积,Size(7,7)是核大小,数字越大越模糊//\tCanny(imgBlur, imgCanny, 25, 75);//边缘检测，阈值1，2可调，目的：显示更多的边缘//\t//\tMat kernel = getStructuringElement(MORPH_RECT, Size(3, 3));//创建一个核，增加Size（只能是奇数）会扩张/侵蚀更多//\tdilate(imgCanny, imgDil, kernel);//扩张边缘（增加边缘厚度）//\terode(imgDil, imgErode, kernel);//侵蚀边缘（减小边缘厚度）//\timshow(&quot;Image&quot;, img);//\timshow(&quot;Image Gray&quot;, imgGray);//\timshow(&quot;Image Blur&quot;, imgBlur);//\timshow(&quot;Image Canny&quot;, imgCanny);//\timshow(&quot;Image Dilation&quot;, imgDil);//\timshow(&quot;Image Erode&quot;, imgErode);//\twaitKey(0);//增加延时，0表示无穷//&#125;\nChapter 3//学习如何调整大小以及裁剪图像#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;/// &lt;summary&gt;/// Resize and Crop/// &lt;/summary&gt;//void main() &#123;//\tstring path = &quot;Resources/test.png&quot;;//\tMat img=imread(path);//matrix data type 由opencv引入来处理图像//\tMat imgResize,imgCrop;//\tcout &lt;&lt; img.size() &lt;&lt; endl;//打印图像尺寸//\t//resize(img, imgResize, Size(640, 480));//指定图片尺寸缩放//\tresize(img, imgResize, Size(),0.5,0.5);//指定缩放比例，不指定图片尺寸////\t//矩形数据类型//\tRect roi(200, 100, 300, 300);//以左上角为坐标原点，（200，100）为矩形的左上角坐标，300,300为矩形长宽//\timgCrop = img(roi);//裁剪图像，为了找到特定区域 添加更多处理 roi:region of interest//\timshow(&quot;Image&quot;, img);//\timshow(&quot;Image Resize&quot;, imgResize);//\timshow(&quot;Image Crop&quot;, imgCrop);//\t//\twaitKey(0);//增加延时，0表示无穷//&#125;\nChapter 4//学习如何绘制形状（圆形、矩形、线段）和如何在图片上写字#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;/// &lt;summary&gt;/// Draw Shapes and Text/// &lt;/summary&gt;//void main() &#123;//\t//创建空白图像//\t//Scalar(255, 0, 255)，（蓝色：255，0，0），（紫色：255，0，255），（黑色：0，0，0），（白色：255，255，255）//\tMat img(512, 512, CV_8UC3, Scalar(255, 255, 255));//(512,512)为图片大小，CV8UC3中8表示每个像素的值从0到255，3表示3个颜色通道BGR,Scalar(255, 0, 0)表示图像将具有的颜色//\t//\tcircle(img, Point(256, 256), 155,Scalar(0,69,255),FILLED);//第一个参数：图片，第二个参数是圆心坐标，第三个参数是圆大小，第四个参数是颜色，第五个参数是厚度（可以不写），想要填充可以填FILLED//\trectangle(img, Point(130,226), Point(382,286),Scalar(255,255,255),FILLED);//第一个Point给矩形左上角坐标，第二个Point给矩形右下角坐标//\tline(img, Point(130, 296), Point(382, 296), Scalar(255, 255, 255), 2);//第一个Point是起点坐标、第二个Point是终点坐标//\tputText(img, &quot;zhuhuijin&quot;, Point(137, 262), FONT_HERSHEY_DUPLEX, 0.75, Scalar(0, 69, 255), 2);//\t//\timshow(&quot;Image&quot;, img);//\twaitKey(0);//增加延时，0表示无穷//&#125;\nChapter 5//学习如何扭曲图像，来扫描文档#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;/// &lt;summary&gt;/// Warp Images/// &lt;/summary&gt;//float w = 250, h = 350;//图片大小//Mat matrix, imgWarp;//void main() &#123;//\t//图片用画图打开，在屏幕左下角会显示点的坐标//\tstring path = &quot;Resources/cards.jpg&quot;;//\tMat img=imread(path);//matrix data type 由opencv引入来处理图像//\tPoint2f src[4] = &#123; &#123;529,142&#125;,&#123;771,190&#125;,&#123;405,395&#125;,&#123;674,457&#125; &#125;;//Point2f表示浮点数//\tPoint2f dst[4] = &#123; &#123;0.0f,0.0f&#125;,&#123;w,0.0f&#125;,&#123;0.0f,h&#125;,&#123;w,h&#125; &#125;;//Point2f表示浮点数////\tmatrix = getPerspectiveTransform(src, dst);//\twarpPerspective(img, imgWarp, matrix, Point(w,h));//\t//\t//确定src坐标是否正确//\tfor (int i = 0; i &lt; 4; i++) &#123;//\t\tcircle(img, src[i], 10, Scalar(0, 0, 255), FILLED);//\t&#125;////\timshow(&quot;Image&quot;, img);//\timshow(&quot;Image Warp&quot;, imgWarp);//\twaitKey(0);//增加延时，0表示无穷//&#125;\nChapter 6//学习检测图片中的颜色，来创建特定对象的对象检测器#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;/// &lt;summary&gt;/// Color Detection/// &lt;/summary&gt;//int hmin = 0, smin = 0, vmin = 0;//int hmax = 179, smax = 255, vmax = 255;//如何确定这6个值，每次都更改所有这些再次运行很痛苦 --&gt;创建跟踪栏（使我们可以实时更改这些值）//void main() &#123;//\tstring path = &quot;Resources/shapes.png&quot;;//\tMat img=imread(path);//\tMat imgHSV,mask;//\tcvtColor(img, imgHSV, COLOR_BGR2HSV);//转换图像到HSV空间，在其中查找颜色更加容易//\tnamedWindow(&quot;Trackbars&quot;, (640, 200));//(640,200)是尺寸//\t//运行时，把3个min的都移到最小值，把3个max的都移到最大值，然后移动使其保持为白色//\tcreateTrackbar(&quot;Hue Min&quot;, &quot;Trackbars&quot;, &amp;hmin, 179);//对于hue色相饱和度最大180,对于另外两个色相饱和度最大255//\tcreateTrackbar(&quot;Hue Max&quot;, &quot;Trackbars&quot;, &amp;hmax, 179);//\tcreateTrackbar(&quot;Sat Min&quot;, &quot;Trackbars&quot;, &amp;smin, 255);//\tcreateTrackbar(&quot;Sat Max&quot;, &quot;Trackbars&quot;, &amp;smax, 255);//\tcreateTrackbar(&quot;Val Min&quot;, &quot;Trackbars&quot;, &amp;vmin, 255);//\tcreateTrackbar(&quot;Val Max&quot;, &quot;Trackbars&quot;, &amp;vmax, 255);//\t//\twhile (true) &#123;//\t\t//检查数组元素是否位于其他两个数组的元素之间。//\t\t//imgHSV为输入图像，mask为输出图像////\t\tScalar lower(hmin, smin, vmin);//\t\tScalar upper(hmax, smax, vmax);//\t\tinRange(imgHSV, lower, upper, mask);//定义颜色下限和上限，因为由于照明和不同的阴影，颜色的值将不完全相同，会是一个值的范围//\t\timshow(&quot;Image&quot;, img);//\t\timshow(&quot;Image HSV&quot;, imgHSV);//\t\timshow(&quot;Image mask&quot;, mask);//\t\twaitKey(1);//增加延时//\t&#125;//&#125;\nChapter 7//学习如何检测形状或图像中的轮廓#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;/// &lt;summary&gt;/// Shapes/// &lt;/summary&gt;//! 获取轮廓void getContours(Mat imgDil,Mat img) &#123;//imgDil是传入的扩张边缘的图像用来查找轮廓，img是要在其上绘制轮廓的图像\tvector&lt;vector&lt;Point&gt;&gt; contours;//轮廓检测到的轮廓。每个轮廓线存储为一个点的向量\t\tvector&lt;Vec4i&gt; hierarchy;//包含关于映像拓扑的信息  typedef Vec&lt;int, 4&gt; Vec4i;具有4个整数值\t\t//在二值图像中查找轮廓。该函数利用该算法从二值图像中提取轮廓\tfindContours(imgDil, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);\t//drawContours(img, contours, -1, Scalar(255, 0, 255), 2);//img：要绘制轮廓在什么图片上，contours：要绘制的轮廓，-1定义要绘制的轮廓号（-1表示所有轮廓），Saclar表示轮廓颜色，2表示厚度\tvector&lt;vector&lt;Point&gt;&gt; conPoly(contours.size());//conploy的数量应小于contours\tvector&lt;Rect&gt; boundRect(contours.size());\t//过滤器：通过轮廓面积来过滤噪声\tfor (int i = 0; i &lt; contours.size(); i++) &#123;//遍历检测到的轮廓\t\tint area = contourArea(contours[i]);\t\t\t\t//cout &lt;&lt; area &lt;&lt; endl;\t\t\t\tstring objectType;\t\tif (area &gt; 1000) &#123;//轮廓面积＞1000才绘制\t\t\t//计算轮廓周长或凹坑长度。该函数计算了曲线长度和封闭的周长。\t\t\tfloat peri = arcLength(contours[i], true);//计算封闭轮廓周长\t\t\tapproxPolyDP(contours[i], conPoly[i],0.02*peri,true);//以指定的精度近似多边形曲线。第二个参数conPloy[i]存储近似的结果，是输出。\t\t\t\t\t\t\t\t\tboundRect[i]=boundingRect(conPoly[i]);//计算边界矩形\t\t\t\t\t\tint objCor = (int)conPoly[i].size();//找近似多边形的角点,三角形有3个角点，矩形/正方形有4个角点，圆形&gt;4个角点\t\t\tcout &lt;&lt; objCor &lt;&lt; endl;\t\t\tif (objCor == 3) &#123;objectType = &quot;Tri&quot;;&#125;\t\t\telse if (objCor == 4) &#123;\t\t\t\tfloat aspRatio = (float)boundRect[i].width / (float)boundRect[i].height;//宽高比\t\t\t\tif (aspRatio &gt; 0.95 &amp;&amp; aspRatio &lt; 1.05) &#123; objectType = &quot;Square&quot;;&#125;//矩形的宽高比不会正好等于1\t\t\t\telse objectType = &quot;Rect&quot;;\t\t\t&#125;\t\t\telse if (objCor &gt; 4) &#123; objectType = &quot;Circle&quot;;&#125;\t\t\t\t\t\tdrawContours(img, conPoly, i, Scalar(255, 0, 255), 2);\t\t\trectangle/*绘制边界矩形*/(img, boundRect[i].tl()/*tl()：topleft矩形左上角坐标*/, boundRect[i].br()/*br()：bottom right矩形右下角坐标*/, Scalar(0, 255, 0), 5);\t\t\tputText(img, objectType, &#123;boundRect[i].x,boundRect[i].y-5&#125;/*文字坐标*/, FONT_HERSHEY_PLAIN, 1, Scalar(0, 69, 255), 2);\t\t&#125;\t&#125;&#125;//void main() &#123;//\tstring path = &quot;Resources/shapes.png&quot;;//\tMat img=imread(path);//\t//\t//在检测形状前，对图片预处理：转换为灰度、添加高斯模糊、使用Canny边缘检测器、扩张边缘//\tMat imgGray, imgBlur, imgCanny, imgDil, imgErode;//\tcvtColor(img, imgGray, COLOR_BGR2GRAY);//cvt是convert的缩写，将图像从一种颜色空间转换为另一种颜色空间。//\tGaussianBlur(imgGray, imgBlur,Size(3,3),3,0);//使用高斯滤波器模糊图像。该函数将源图像与指定的高斯核进行卷积,Size(7,7)是核大小,数字越大越模糊//\tCanny(imgBlur, imgCanny, 25, 75);//边缘检测，阈值1，2可调，目的：显示更多的边缘//\tMat kernel = getStructuringElement(MORPH_RECT, Size(3, 3));//创建一个核，增加Size（只能是奇数）会扩张/侵蚀更多//\tdilate(imgCanny, imgDil, kernel);//扩张边缘（增加边缘厚度）//\t//\tgetContours(imgDil,img);//img是在其上绘轮廓的图片////\timshow(&quot;Image&quot;, img);//\t/*imshow(&quot;Image Gray&quot;, imgGray);//\timshow(&quot;Image Blur&quot;, imgBlur);//\timshow(&quot;Image Canny&quot;, imgCanny);//\timshow(&quot;Image Dil&quot;, imgDil);*///\twaitKey(0);//增加延时，0表示无穷//&#125;\nChapter 8//学习检测图像中的面部#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;opencv2/objdetect.hpp&gt;//对象检测头文件#include&lt;iostream&gt;using namespace std;using namespace cv;/// &lt;summary&gt;/// Images/// &lt;/summary&gt;//void main() &#123;//\tstring path = &quot;Resources/test.png&quot;;//\tMat img=imread(path);//\tCascadeClassifier faceCascade;/*用于对象检测的级联分类器类*///\tfaceCascade.load(&quot;Resources/haarcascade_frontalface_default.xml&quot;);//从文件加载分类器(已经训练好的模型)////\tif (faceCascade.empty()) &#123; cout &lt;&lt; &quot;XML file not loaded&quot; &lt;&lt; endl; &#125;//检测文件是否加载成功////\tvector&lt;Rect&gt; faces;//\tfaceCascade.detectMultiScale(img/*输入*/, faces/*输出*/, 1.1/*比例因子*/, 10/*最小邻居*/);//在输入图像中检测不同大小的对象。检测到的对象将以矩形列表的形式返回。//\t//\tfor (int i = 0; i &lt; faces.size(); i++) &#123;//\t\trectangle(img, faces[i].tl(),faces[i].br(), Scalar(255, 0, 255), 3);//绘制矩形//\t&#125;////\timshow(&quot;Image&quot;, img);//\twaitKey(0);//增加延时，0表示无穷//&#125;\nProject 1#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;/// &lt;summary&gt;/// Project 1/// 使用HSV空间检测颜色、找到轮廓所在位置、取轮廓的位置然后创建一个圆/// &lt;/summary&gt;//Mat img;//vector&lt;vector&lt;int&gt;&gt; newPoints;////vector&lt;vector&lt;int&gt;&gt; myColors&#123; &#123;98,109,54,127,255,255&#125;,//蓝色（hmin smin vmin hmax smax vmax）//\t\t\t\t\t\t\t\t&#123;35,0,0,77,245,255&#125; &#125;;//绿色（hmin smin vmin hmax smax vmax）////vector&lt;Scalar&gt; myColorValues&#123; &#123;255,0,255&#125;,//蓝色//\t\t\t\t\t\t\t\t&#123;0,255,0&#125; &#125;;//绿色//////! 获取轮廓//Point getContours(Mat imgDil) &#123;//imgDil是传入的扩张边缘的图像用来查找轮廓，img是要在其上绘制轮廓的图像//\tvector&lt;vector&lt;Point&gt;&gt; contours;//轮廓检测到的轮廓。每个轮廓线存储为一个点的向量////\tvector&lt;Vec4i&gt; hierarchy;//包含关于映像拓扑的信息  typedef Vec&lt;int, 4&gt; Vec4i;具有4个整数值////\t//在二值图像中查找轮廓。该函数利用该算法从二值图像中提取轮廓//\tfindContours(imgDil, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);//\t//drawContours(img, contours, -1, Scalar(255, 0, 255), 2);//img：要绘制轮廓在什么图片上，contours：要绘制的轮廓，-1定义要绘制的轮廓号（-1表示所有轮廓），Saclar表示轮廓颜色，2表示厚度//\t//\tvector&lt;vector&lt;Point&gt;&gt; conPoly(contours.size());//conploy的数量应小于contours//\tvector&lt;Rect&gt; boundRect(contours.size());////\tPoint myPoint(0, 0);////\t//过滤器：通过轮廓面积来过滤噪声//\tfor (int i = 0; i &lt; contours.size(); i++) &#123;//遍历检测到的轮廓//\t\tint area = contourArea(contours[i]);//\t\t//\t\t//cout &lt;&lt; area &lt;&lt; endl;////\t\tstring objectType;//\t\tif (area &gt; 1000) &#123;//轮廓面积＞1000才绘制//\t\t\t//计算轮廓周长或凹坑长度。该函数计算了曲线长度和封闭的周长。//\t\t\tfloat peri = arcLength(contours[i], true);//计算封闭轮廓周长//\t\t\tapproxPolyDP(contours[i], conPoly[i], 0.02 * peri, true);//以指定的精度近似多边形曲线。第二个参数conPloy[i]存储近似的结果，是输出。////\t\t\tboundRect[i] = boundingRect(conPoly[i]);//计算边界矩形////\t\t\tmyPoint.x = boundRect[i].x + boundRect[i].width / 2;//\t\t\tmyPoint.y = boundRect[i].y;////\t\t\trectangle/*绘制边界矩形*/(img, boundRect[i].tl()/*tl()：topleft矩形左上角坐标*/, boundRect[i].br()/*br()：bottom right矩形右下角坐标*/, Scalar(0, 255, 0), 5);//\t\t\tdrawContours(img, conPoly, i, Scalar(255, 0, 255), 2);//\t\t\t//\t\t&#125;//\t&#125;//\treturn myPoint;//&#125;//////vector&lt;vector&lt;int&gt;&gt; findColor(Mat img) &#123;//\tMat imgHSV;//\tcvtColor(img, imgHSV, COLOR_BGR2HSV);//转换图像到HSV空间，在其中查找颜色更加容易////\tfor (int i = 0; i &lt; myColors.size(); i++)//\t&#123;//\t\tScalar lower(myColors[i][0], myColors[i][1], myColors[i][2]);//\t\tScalar upper(myColors[i][3], myColors[i][4], myColors[i][5]);//\t\tMat mask;//\t\tinRange(imgHSV, lower, upper, mask);//定义颜色下限和上限，因为由于照明和不同的阴影，颜色的值将不完全相同，会是一个值的范围//\t\t//imshow(to_string(i), mask);//\t\tPoint myPoint=getContours(mask);//\t\tif (myPoint.x != 0 &amp;&amp; myPoint.y != 0) &#123;//没检测到东西的时候就不加入新点//\t\t\tnewPoints.push_back(&#123; myPoint.x,myPoint.y,i &#125;);//i为颜色索引//\t\t&#125;//\t&#125;//\treturn newPoints;//\t//&#125;////void drawOnCanvas(vector&lt;vector&lt;int&gt;&gt; newPoints, vector&lt;Scalar&gt; myColorValues) &#123;//\tfor (int i = 0; i &lt; newPoints.size(); i++) &#123;//\t\tcircle(img, Point(newPoints[i][0], newPoints[i][1]),6,myColorValues[newPoints[i][2]],FILLED);//\t&#125;//&#125;////void main() &#123;//\tVideoCapture cap(0);//相机id=0//\t////\twhile (true) &#123;//\t\tcap.read(img);////\t\tnewPoints=findColor(img);//\t\tdrawOnCanvas(newPoints,myColorValues);//\t\timshow(&quot;Image&quot;, img);//\t\twaitKey(1);//增加延时 1ms，以免太慢//\t&#125;////&#125;\nProject 2#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;/// &lt;summary&gt;/// Project 2 – Document Scanner/// 图像预处理：转换为灰度、添加模糊、使用Canny边缘检测器找到边缘（知道纸张在哪里）、基于纸张的坐标提取四个角得到顶视图/// &lt;/summary&gt;//Mat imgOriginal, imgGray, imgBlur, imgCanny, imgDil, imgErode, imgThre, imgWarp, imgCrop;//vector&lt;Point&gt; initialPoints,docPoints;//float w = 420, h = 596;//Mat preProcessing(Mat img) &#123;//\tcvtColor(img, imgGray, COLOR_BGR2GRAY);//cvt是convert的缩写，将图像从一种颜色空间转换为另一种颜色空间。//\tGaussianBlur(imgGray, imgBlur,Size(7,7),5,0);//使用高斯滤波器模糊图像。该函数将源图像与指定的高斯核进行卷积,Size(7,7)是核大小,数字越大越模糊//\tCanny(imgBlur, imgCanny, 25, 75);//边缘检测，阈值1，2可调，目的：显示更多的边缘//\t//\tMat kernel = getStructuringElement(MORPH_RECT, Size(3, 3));//创建一个核，增加Size（只能是奇数）会扩张/侵蚀更多//\tdilate(imgCanny, imgDil, kernel);//扩张边缘（增加边缘厚度）//\t//erode(imgDil, imgErode, kernel);//侵蚀边缘（减小边缘厚度）//\treturn imgDil;//&#125;////vector&lt;Point&gt;/*返回纸张的4个角点*/ getContours(Mat imgDil) &#123;//imgDil是传入的扩张边缘的图像用来查找轮廓，img是要在其上绘制轮廓的图像//\tvector&lt;vector&lt;Point&gt;&gt; contours;//轮廓检测到的轮廓。每个轮廓线存储为一个点的向量////\tvector&lt;Vec4i&gt; hierarchy;//包含关于映像拓扑的信息  typedef Vec&lt;int, 4&gt; Vec4i;具有4个整数值////\t//在二值图像中查找轮廓。该函数利用该算法从二值图像中提取轮廓//\tfindContours(imgDil, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);//\t//drawContours(img, contours, -1, Scalar(255, 0, 255), 2);//img：要绘制轮廓在什么图片上，contours：要绘制的轮廓，-1定义要绘制的轮廓号（-1表示所有轮廓），Saclar表示轮廓颜色，2表示厚度//\t//\tvector&lt;vector&lt;Point&gt;&gt; conPoly(contours.size());//conploy的数量应小于contours//\tvector&lt;Rect&gt; boundRect(contours.size());////\tvector&lt;Point&gt; biggest;//\tint maxArea = 0;////\t//过滤器：通过轮廓面积来过滤噪声//\tfor (int i = 0; i &lt; contours.size(); i++) &#123;//遍历检测到的轮廓//\t\tint area = contourArea(contours[i]);//\t\t//\t\t//cout &lt;&lt; area &lt;&lt; endl;////\t\tstring objectType;//\t\tif (area &gt; 1000) &#123;//轮廓面积＞1000才绘制//\t\t\t//计算轮廓周长或凹坑长度。该函数计算了曲线长度和封闭的周长。//\t\t\tfloat peri = arcLength(contours[i], true);//计算封闭轮廓周长//\t\t\tapproxPolyDP(contours[i], conPoly[i], 0.02 * peri, true);//以指定的精度近似多边形曲线。第二个参数conPloy[i]存储近似的结果，是输出。//\t\t\t//\t\t\tif (area &gt; maxArea&amp;&amp;conPoly[i].size()==4) &#123;//\t\t\t\tbiggest = &#123; conPoly[i][0],conPoly[i][1],conPoly[i][2],conPoly[i][3] &#125;;//\t\t\t\tmaxArea = area;//\t\t\t&#125;////\t\t\t//rectangle/*绘制边界矩形*/(imgOriginal, boundRect[i].tl()/*tl()：topleft矩形左上角坐标*/, boundRect[i].br()/*br()：bottom right矩形右下角坐标*/, Scalar(0, 255, 0), 5);//\t\t\t//drawContours(imgOriginal, conPoly, i, Scalar(255, 0, 255), 2);//\t\t\t//\t\t&#125;//\t&#125;//\treturn biggest;//&#125;////void drawPoints(vector&lt;Point&gt; points, Scalar color) &#123;//\tfor (int i = 0; i &lt; points.size(); i++) &#123;//\t\tcircle(imgOriginal, points[i], 10, color, FILLED);//\t\tputText(imgOriginal, to_string(i), points[i], FONT_HERSHEY_PLAIN, 4, color, 4);//\t&#125;//&#125;////vector&lt;Point&gt; reorder(vector&lt;Point&gt; points) &#123;//标记点的顺序会变，要确定一个顺序 0 1//\t\t\t\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\t 2 3//\tvector&lt;Point&gt; newPoints;//\tvector&lt;int&gt;  sumPoints, subPoints;//\tfor (int i = 0; i &lt; 4; i++) &#123;//\t\tsumPoints.push_back(points[i].x + points[i].y);//\t\tsubPoints.push_back(points[i].x - points[i].y);//\t&#125;//\t//\tnewPoints.push_back(points[min_element/* find smallest element*/(sumPoints.begin(), sumPoints.end())-sumPoints.begin()]);//\tnewPoints.push_back(points[max_element/* find largest element*/(subPoints.begin(), subPoints.end()) - subPoints.begin()]);//\tnewPoints.push_back(points[min_element/* find smallest element*/(subPoints.begin(), subPoints.end()) - subPoints.begin()]);//\tnewPoints.push_back(points[max_element/* find largest element*/(sumPoints.begin(), sumPoints.end()) - sumPoints.begin()]);////\treturn newPoints;//&#125;////Mat getWarp(Mat img,vector&lt;Point&gt; points,float w,float h) &#123;//\tPoint2f src[4] = &#123; points[0],points[1],points[2],points[3] &#125;;//Point2f表示浮点数//\tPoint2f dst[4] = &#123; &#123;0.0f,0.0f&#125;,&#123;w,0.0f&#125;,&#123;0.0f,h&#125;,&#123;w,h&#125; &#125;;//Point2f表示浮点数////\tMat matrix = getPerspectiveTransform(src, dst);//\twarpPerspective(img, imgWarp, matrix, Point(w,h));////\treturn imgWarp;//&#125;////void main() &#123;//\tstring path = &quot;Resources/paper.jpg&quot;;//\timgOriginal=imread(path);////\t//resize(imgOriginal/*source*/, imgOriginal/*destination*/, Size()/*不定义尺寸*/, 0.5/*定义比例*/, 0.5/*定义比例*/);////\t//预处理//\timgThre = preProcessing(imgOriginal);//\t//获得轮廓--获得最大矩形//\tinitialPoints=getContours(imgThre);//\t//drawPoints(initialPoints, Scalar(0, 0, 255));//\tdocPoints = reorder(initialPoints);//\t//drawPoints(docPoints, Scalar(0, 255, 0));//\t//扭曲//\timgWarp = getWarp(imgOriginal, docPoints, w, h);//\t//裁剪多余的边--通过创建一个矩形//\tint cropValue = 5;//\tRect roi(cropValue/*每条边要减去的像素*/, cropValue, w - 2 * cropValue/*宽度*/, h - 2 * cropValue/*高度*/);//\timgCrop = imgWarp(roi);//\timshow(&quot;Image&quot;, imgOriginal);//\timshow(&quot;Image Dilation&quot;, imgThre);//\timshow(&quot;Image Warp&quot;, imgWarp);//\timshow(&quot;Image Crop&quot;, imgCrop);//\twaitKey(0);//&#125;\nProject 3//学习如何检测车牌和如何裁剪并保存这些区域#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;opencv2/objdetect.hpp&gt;//对象检测头文件#include&lt;iostream&gt;using namespace std;using namespace cv;/// &lt;summary&gt;/// Project 3 – License Plate(车牌) Detector/// &lt;/summary&gt;void main() &#123;\t\tVideoCapture cap(0);//相机id=0\tMat img;\t//加载模型\tCascadeClassifier plateCascade;/*用于对象检测的级联分类器类*/\tplateCascade.load(&quot;Resources/haarcascade_russian_plate_number.xml&quot;);//从文件加载分类器(已经训练好的模型)\tif (plateCascade.empty()) &#123; cout &lt;&lt; &quot;XML file not loaded&quot; &lt;&lt; endl; &#125;//检测文件是否加载成功\tvector&lt;Rect&gt; plates;\twhile (true) &#123;\t\tcap.read(img);\t\t//可以更改比例因子和最小邻居来调整检测成功率\t\tplateCascade.detectMultiScale(img/*输入*/, plates/*输出*/, 1.1/*比例因子*/, 10/*最小邻居*/);//在输入图像中检测不同大小的对象。检测到的对象将以矩形列表的形式返回。\t\t\t\t\t\tfor (int i = 0; i &lt; plates.size(); i++) &#123;\t\t\tMat imgCrop = img(plates[i]);//plates是矩形列表，plates[i]是矩形\t\t\t//imshow(to_string(i), imgCrop);\t\t\timwrite(&quot;Resources/Plates/&quot; + to_string(i) + &quot;.png&quot;, imgCrop);\t\t\trectangle(img, plates[i].tl(), plates[i].br(), Scalar(255, 0, 255), 3);//绘制矩形\t\t&#125;\t\timshow(&quot;Image&quot;, img);\t\twaitKey(1);//增加延时，0表示无穷\t&#125;&#125;\nColorpicker#include&lt;opencv2/imgcodecs.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;//int hmin = 0, smin = 0, vmin = 0;//int hmax = 179, smax = 255, vmax = 255;//如何确定这6个值，每次都更改所有这些再次运行很痛苦 --&gt;创建跟踪栏（使我们可以实时更改这些值）//Mat img;//Mat imgHSV, mask, imgColor;//void main() &#123;//\tVideoCapture cap(0);//相机id=0//\t//\t//\tnamedWindow(&quot;Trackbars&quot;, (640, 200));//创建窗口，(640,200)是尺寸//\t//运行时，把3个min的都移到最小值，把3个max的都移到最大值，然后移动使其保持为白色//\tcreateTrackbar(&quot;Hue Min&quot;, &quot;Trackbars&quot;, &amp;hmin, 179);//对于hue色相饱和度最大180,对于另外两个色相饱和度最大255//\tcreateTrackbar(&quot;Hue Max&quot;, &quot;Trackbars&quot;, &amp;hmax, 179);//\tcreateTrackbar(&quot;Sat Min&quot;, &quot;Trackbars&quot;, &amp;smin, 255);//\tcreateTrackbar(&quot;Sat Max&quot;, &quot;Trackbars&quot;, &amp;smax, 255);//\tcreateTrackbar(&quot;Val Min&quot;, &quot;Trackbars&quot;, &amp;vmin, 255);//\tcreateTrackbar(&quot;Val Max&quot;, &quot;Trackbars&quot;, &amp;vmax, 255);//\t//\twhile (true) &#123;//\t\t//检查数组元素是否位于其他两个数组的元素之间。//\t\t//imgHSV为输入图像，mask为输出图像//\t\tcap.read(img);//\t\tcvtColor(img, imgHSV, COLOR_BGR2HSV);//转换图像到HSV空间，在其中查找颜色更加容易//\t\tScalar lower(hmin, smin, vmin);//\t\tScalar upper(hmax, smax, vmax);//\t\tinRange(imgHSV, lower, upper, mask);//定义颜色下限和上限，因为由于照明和不同的阴影，颜色的值将不完全相同，会是一个值的范围//\t\tcout &lt;&lt; hmin &lt;&lt; &quot;,&quot; &lt;&lt; smin &lt;&lt; &quot;,&quot; &lt;&lt; vmin &lt;&lt; &quot;,&quot; &lt;&lt; hmax &lt;&lt; &quot;,&quot; &lt;&lt; smax &lt;&lt; &quot;,&quot; &lt;&lt; vmax &lt;&lt; endl;//\t\timshow(&quot;Image&quot;, img);//\t\timshow(&quot;Image HSV&quot;, imgHSV);//\t\timshow(&quot;Image mask&quot;, mask);//\t\twaitKey(1);//增加延时//\t&#125;//&#125;\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (视频读写&&背景消去&&对象跟踪)","url":"/2021/07/28/OPENCV1-2/","content":"这是Eva今年暑假学的~\n\nChapter 1 视频读写#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;using namespace std;using namespace cv;int main(/*int argc, char** argv*/)&#123; //括号里应该不重要吧\tVideoCapture capture;\tcapture.open(&quot;D:/.../&quot;);         //要打开的文件的路径\tif(!capture.isOpened())&#123;         //如果打开失败了\t\tcout &lt;&lt; &quot;could not load&quot; &lt;&lt; endl;\t\treturn -1; \t&#125;\t\tdouble fps = capture.get(CV_CAP_PROP_FPS);\tVedioWriter writer(&quot;...&quot;, -1, fps, Size(640, 480), true);\t//Size size = Size(capture.get(CV_CAP_PROP_FRAME_WIDTH), capture.get(CV_CAP_PROP_FRAME_HEIGHT));\t\tMat frame, gray, binary;\tnamedWindow(&quot;Video-demo&quot;, CV_WINDOW_AUTOSIZE);\twhile(capture.read(frame))&#123;\t\t//imshow(&quot;Video-demo&quot;, frame);\t\t//cvtColor(frame, gray, COLOR_BGR2GRAY);        //转换成灰度图\t\t//imshow(&quot;Video-demo&quot;, gray);\t\t//threshold(gray, binary, 0, 255, THRESH_BINARY|THRESH_OTSU);      //二值化 \t\t//imshow(&quot;Video-demo&quot;, binary);\t\tbitwise_not(frame, frame);         //bitwise_xor,bitwise_and\t\timshow(&quot;Video-demo&quot;, frame);\t\t//writer.write(frame);\t\tchar c = waitKey(100);\t\tif(c == 27)&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t\twaitKey(0);\treturn 0;&#125;\n相关类和函数Capture 类//构造函数：filename – 打开的视频文件名。device – 打开的视频捕获设备id ，如果只有一个摄像头可以填0，表示打开默认的摄像头。 VideoCapture::VideoCapture();VideoCapture::VideoCapture(const string&amp; filename);VideoCapture::VideoCapture(int device);//open 打开一个视频文件或者打开一个捕获视频的设备bool VideoCapture::open(const string&amp; filename);bool VideoCapture::open(int device);//先实例化再初始化VideoCapture capture;capture.open(&quot;dog.avi&quot;);//在实例化的同时进行初始化VideoCapture(&quot;dog.avi&quot;);//isopenbool VideoCapture::isOpened();//release 关闭视频文件或者摄像头void VideoCapture::release();//grab 抓取下一个帧，假如调用成功返回truebool VideoCapture::grab();//retrieve 解码并且返回刚刚抓取的视频帧bool VideoCapture::retrieve(Mat&amp; image, int channel=0);//read 该函数结合VideoCapture::grab()和VideoCapture::retrieve()其中之一被调用，用于捕获、解码和返回下一个视频帧这是一个最方便的函数对于读取视频文件或者捕获数据从解码和返回刚刚捕获的帧VideoCapture&amp; VideoCapture::operator&gt;&gt;(Mat&amp; image);bool VideoCapture::read(Mat&amp; image);// 方法一 capture.read(frame); // 方法二 capture.grab(); // 方法三capture.retrieve(frame); // 方法四capture &gt;&gt; frame;//get 帧率、总帧数、尺寸、格式等，VideoCapture的get方法可以获取这些属性double VideoCapture::get(int propId);//参数是属性的ID//set 设置属性 (属性ID，要设置的值)bool VideoCapture::set(int propertyId, double value);\n#include &lt;iostream&gt; #include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt; int main(int argc,char* argv[])&#123;    cv::VideoCapture capture(argv[1]);    if(!capture.isOpened())     &#123;        std::cout&lt;&lt;&quot;video not open.&quot;&lt;&lt;std::endl;        return 1;    &#125;    //获取当前视频帧率    double rate = capture.get(CV_CAP_PROP_FPS);    //当前视频帧    cv::Mat frame;    //每一帧之间的延时    //与视频的帧率相对应    int delay = 1000/rate;    bool stop(false);    while(!stop)    &#123;        if(!capture.read(frame))        &#123;            std::cout&lt;&lt;&quot;no video frame&quot;&lt;&lt;std::endl;            break;         &#125;         //此处为添加对视频的每一帧的操作方法        int frame_num = capture.get(CV_CAP_PROP_POS_FRAMES);        std::cout&lt;&lt;&quot;Frame Num : &quot;&lt;&lt;frame_num&lt;&lt;std::endl;        if(frame_num==20)        &#123;            capture.set(CV_CAP_PROP_POS_FRAMES,10);        &#125;         cv::imshow(&quot;video&quot;,frame);        //引入延时        //也可通过按键停止        if(cv::waitKey(delay)&gt;0)        stop = true;    &#125;      //关闭视频，手动调用析构函数（非必须）    capture.release();    return 0;&#125;\nVideoWriter​ 类//三种构造函数VideoWriter::VideoWriter()VideoWriter::VideoWriter(const String &amp;filename, int fourcc, double fps, Size frameSize, bool isColor=true)VideoWriter::VideoWriter(const String &amp;filename, int apiPreference, int fourcc, double fps, Size frameSize, bool isColor=true)\nfilename​ : 输出视频文件的路径名称\nfourcc​ : 字符类型的编码，表示用于编码视频文件的编码器。其中\n\nVideoWriter::fourcc(&#39;P’,’I’,’M’,’1’) 表示 MPEG-1 编码文件扩展名为 .avi​ ; \nVideoWriter::fourcc(&#39;X&#39;,&#39;V&#39;,&#39;I&#39;,&#39;D&#39;) 表示 MPEG-4 编码文件扩展名为 .avi ; \nVideoWriter::fourcc(&#39;X&#39;,’2&#39;,&#39;6&#39;,&#39;4&#39;)​ 表示 MPEG-4​ 编码文件扩展名为 .mp4​ ;\nVideoWriter::fourcc(&#39;I&#39;,’4&#39;,&#39;2&#39;,&#39;0&#39;) 表示 YUV 编码，文件扩展名为.avi ;\nVideoWriter::fourcc(&#39;M&#39;,’P&#39;,&#39;4&#39;,&#39;V&#39;) 表示旧的 MPEG-4 编码，文件扩展名为 .avi ;\nVideoWriter::fourcc(&#39;T&#39;,’H&#39;,&#39;E&#39;,&#39;O&#39;) 表示使用 ogg vorbis ，文件扩展名为 .ogv ;\nVideoWriter::fourcc(&#39;F&#39;,&#39;L&#39;,&#39;V&#39;,&#39;1&#39;) 表示 flash video ,文件扩展名为 .flv ;\n\nfps​ : 表示帧率\nframeSize​ : 表示每一帧图像的大小\nisColor : 灰度图像或者是彩色图像（仅仅在 windows 上支持）\napiPreference ： 使用指定的 API，例如可以使用 cv::CAP_FFMPEG 或者 cv::CAP_GSTREAMER​ 等。\n//常用函数VideoWriter::isOpened()    VideoWriter::getBackednName()    VideoWriter::open(const String &amp;filename, int fourcc, double fps, Size frameSize, bool isColor=true);VideoWriter::open(const String &amp;filename,int apiPreference,int fourcc,double fps,Size frameSize,bool isColor=true);VideoWriter::release()    VideoWriter::get(int propId);VideoWriter::set(int propId,double value);\nSize 类template&lt;typename _Tp&gt; class Size_&#123;public:    typedef _Tp value_type;    //! various constructors    Size_();    Size_(_Tp _width, _Tp _height);    Size_(const Size_&amp; sz);    Size_(const CvSize&amp; sz);    Size_(const CvSize2D32f&amp; sz);    Size_(const Point_&lt;_Tp&gt;&amp; pt);    Size_&amp; operator = (const Size_&amp; sz);    //! the area (width*height)    _Tp area() const;    //! conversion of another data type.    template&lt;typename _Tp2&gt; operator Size_&lt;_Tp2&gt;() const;    //! conversion to the old-style OpenCV types    operator CvSize() const;    operator CvSize2D32f() const;    _Tp width, height; // the width and the height&#125;;\ncvtColor_CV_8U_ 图像 其通道值范围为0到255\n_CV_16U_ 时其值通道值范围为0到65535\n_CV_32F_ 时，其通道值范围为0到1\n//src：为原图片 code：需要进行色彩空间转换的结果void cv::cvtColor (InputArray src, OutputArray dst, int code, int dstCn = 0)\nthreshold去掉噪，例如过滤很小或很大像素值的图像点\ndouble threshold( InputArray src, OutputArray dst, double thresh, double maxval, int type )//src 源图像Mat对象//dst 目标图像Mat对象//thresh 设定的阈值//maxval 是当灰度值大于（或小于）阈值时将该灰度值赋成的值//type 二值化的方式\n二值化的方式, 常用的有如下5种\nCV_THRESH_BINARY      =0,  /**大于阈值的部分被置为255，小于部分被置为0 */CV_THRESH_BINARY_INV  =1,  /**大于阈值部分被置为0，小于部分被置为255    */CV_THRESH_TRUNC       =2,  /**大于阈值部分被置为threshold，小于部分保持原样   */CV_THRESH_TOZERO      =3,  /**小于阈值部分被置为0，大于部分保持不变*/CV_THRESH_TOZERO_INV  =4,  /**大于阈值部分被置为0，小于部分保持不变 */\n#include&lt;opencv2/opencv.hpp&gt;using namespace cv;int main() &#123;    Mat src = imread(&quot;C:/Users/Administrator/Desktop/txyzm.png&quot;);//引入源图像    if (src.empty()) &#123;        return -1;    &#125;    Mat graySrc,dst;    cvtColor(src, graySrc,CV_BGR2GRAY);//转换为灰度图像    threshold(graySrc, dst, 170, 255, CV_THRESH_BINARY);//图像二值化    imshow(&quot;dst&quot;, dst);//展示目标图像    waitKey(0);    return 0;&#125;\nbitwise//bitwise_not 将二指图片的效果反转既黑色变白色，白色变黑色bitwise_not(InputArray src, OutputArray dst, InputArray mask = noArray());//bitwise_xor 对两个图像进行”异“处理//bitwise_or 计算每个位操作分离的两个数组或一个数\nnamedWindowvoid nameWindow(const string&amp; winname,int flags = WINDOW_AUTOSIZE) ;\n\nQt后端支持标志：\n\nWINDOW_NORMAL 或 WINDOW_AUTOSIZEWINDOW_NORMAL 使您可以调整大小窗口，而 WINDOW_AUTOSIZE 自动调整窗口大小以适应显示图像（参见 imshow ），您无法手动更改窗口大小。\nWINDOW_FREERATIO 或 WINDOW_KEEPRATIOWINDOW_FREERATIO 调整图像不考虑其比例，而 WINDOW_KEEPRATIO 保持图像比例。\nWINDOW_GUI_NORMAL 或 WINDOW_GUI_EXPANDEDWINDOW_GUI_NORMAL 是绘制窗口的旧方法没有状态栏和工具栏，而                   WINDOW_GUI_EXPANDED 是一个新的增强 GUI 。默认情况下，flags == WINDOW_AUTOSIZE | WINDOW_KEEPRATIO |WINDOW_GUI_EXPANDED \n\n\n\nChapter 2 背景消去建模（BSM）：背景不常变化的图像分割 （GMM — 高斯混合模型）\nPtr&lt;BackgroundSubtractorMOG2&gt; bgsubtractor = createBackgroundSubtractorMOG2();bgsubtractor-&gt;setHistory(20);bgsubtractor-&gt;setVarThreshold(100);bgsubtractor-&gt;setDetectShadows(true);bgsubtractor-&gt;setBackgroundRatio(4);bgsubtractor-&gt;setNMixtures(5);bgsubtractor-&gt;setShadowThreshold(40);bgsubtractor-&gt;setVarInit(15);bgsubtractor-&gt;setVarMax(20);bgsubtractor-&gt;setVarMin(4);bgsubtractor-&gt;setVarThresholdGen(100);\nHistory：用于训练背景的帧数，history可以用于计算当前的learning rate ，history越大，learning rate越低，背景更新越缓慢；\nVarThreshold：方差阈值，主要用于判断前景还是背景，值越大，灵敏度越低\nDetectShadows：是否检测有影子，开启后会增加算法复杂度\nNMixtures：高斯模型个数，默认5个，最多8个，模型数越多，耗时越长\nBackgroundRatio：高斯背景模型权重和阈值，nmixtures个模型按权重排序后，只取模型权重累加值大于backgroundRatio的前几个作为背景模型\nVarInit：新建高斯模型的方差初始值，默认15\nVarMax：背景更新时，用于限制高斯模型方差的最大值，默认20\nVarMin：背景更新时，用于限制高斯模型方差的最小值，默认4\nVarThresholdGen：方差阈值，用于已经存在的匹配的模型，如果不存在则新建一个\n原文链接：https://blog.csdn.net/holecloud/article/details/80139297\n#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;using namespace std;using namespace cv;int main()&#123;\tVideoCapture capture;\tcapture.open(&quot;...&quot;);\tif(!capture.isOpened())&#123;         //如果打开失败了\t\tcout &lt;&lt; &quot;could not load&quot; &lt;&lt; endl;\t\treturn -1; \t&#125;\t\tMat frame;\tMat bsmaskMOG2;\tnamedWindow(&quot;input video&quot;, CV_WINDOW_AUTOSIZE);\tnamedWindow(&quot;MOG2&quot;, CV_WINDOW_AUTOSIZE);\tPtr&lt;BackgroudSubtractor&gt; pMOG2 = createBackgroundSubtractorMOG2();  //选择API\twhile(capture.read(frame))&#123;\t\timshow(&quot;inpupt video&quot;, frame);\t\tpMOG2 -&gt; apply(frame, bsmaskMOG2);\t\timshow(&quot;MOG2&quot;, bsmaskMOG2);\t\tchar c = waitKey(100);\t\tif(c == 27)&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t\tcapture.release();\twaitKey(0);\treturn 0;&#125;\n机器学习（KNN — K​ 个最近邻）\n#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;using namespace std;using namespace cv;int main()&#123;\tVideoCapture capture;\tcapture.open(&quot;...&quot;);\tif(!capture.isOpened())&#123;         //如果打开失败了\t\tcout &lt;&lt; &quot;could not load&quot; &lt;&lt; endl;\t\treturn -1; \t&#125;\t\tMat frame;\tMat bsmaskKNN;\tnamedWindow(&quot;input video&quot;, CV_WINDOW_AUTOSIZE);\tnamedWindow(&quot;KNN&quot;, CV_WINDOW_AUTOSIZE);\tPtr&lt;BackgroudSubtractor&gt; pKNN = createBackgroundSubtractorKNN();\twhile(capture.read(frame))&#123;\t\timshow(&quot;inpupt video&quot;, frame);\t\tpKNN -&gt; apply(frame, bsmaskKNN);\t\timshow(&quot;KNN&quot;, bsmaskKNN);\t\tchar c = waitKey(100);\t\tif(c == 27)&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t\tcapture.release();\twaitKey(0);\treturn 0;&#125;\n开操作去噪声\n#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;using namespace std;using namespace cv;int main()&#123;\tVideoCapture capture;\tcapture.open(&quot;...&quot;);\tif(!capture.isOpened())&#123;         //如果打开失败了\t\tcout &lt;&lt; &quot;could not load&quot; &lt;&lt; endl;\t\treturn -1; \t&#125;\t\tMat frame;\tMat bsmaskMOG2;\tnamedWindow(&quot;input video&quot;, CV_WINDOW_AUTOSIZE);\tnamedWindow(&quot;MOG2&quot;, CV_WINDOW_AUTOSIZE);\t\tMat kernel = getStructuringELement(MORPH_RECT, Size(3, 3), Point(-1, -1));\t\tPtr&lt;BackgroudSubtractor&gt; pMOG2 = createBackgroundSubtractorMOG2();  //选择API\twhile(capture.read(frame))&#123;\t\timshow(&quot;inpupt video&quot;, frame);\t\tpMOG2 -&gt; apply(frame, bsmaskMOG2);\t\tmorphologyEx(bsmaskMOG2, bsmaskMOG2, MORPH_OPEN, kernel, Point(-1, -1));\t\timshow(&quot;MOG2&quot;, bsmaskMOG2);\t\tchar c = waitKey(50);\t\tif(c == 27)&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t\tcapture.release();\twaitKey(0);\treturn 0;&#125;\n相关类和函数BackgroundSubtractor\nBackgroundSubtractor （父类）   -  BackgroundSubtractorMOG2    -  BackgroundSubtractorKNN\nChapter 3 对象检测与跟踪：基于颜色inRange过滤利用颜色进行过滤\n形态学操作提取开操作 去噪声 膨胀 \n轮廓查找外接矩形获取位置标定#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;using namespace std;using namespace cv;Rect roi;void processFrame(Mat &amp;mask, Rect &amp;rect);int main()&#123;\tVideoCapture capture;\tcapture.open(&quot;...&quot;);\tif(!capture.isOpened())&#123;         //如果打开失败了\t\tcout &lt;&lt; &quot;could not load&quot; &lt;&lt; endl;\t\treturn -1; \t&#125;\t\tMat frame, mask;\tMat kernel1 = getStructuringElement(MORPH_RECT, Size(3, 3), Point(-1, -1));\tMat kernel2 = getStructuringElement(MORPH_RECT, Size(5, 5), Point(-1, -1));\t\tnamedWindow(&quot;input video&quot;, CV_WINDOW_AUTOSIZE);\tnamedWindow(&quot;track mask&quot;, CV_WINDOW_AUTOSIZE);\twhile(capture.read(frame))&#123;\t\tinRange(frame, Scalar(0, 0, 127), Scalar(120, 255, 120), mask); //过滤 \t\tmorphologyEx(mask, mask, MORPH_OPEN, kernel1, Point(-1, -1), 1); //开操作\t\timshow(&quot;track mask&quot;, mask);\t\tdilate(mask, mask, kernel2, Point(-1, -1), 4); //膨胀\t\timshow(&quot;dilate mask&quot;, mask);\t\t\t\tprocessFrame(mask, roi); //找轮廓并标定\t\t\t\trectangle(frame, roi, Scalar(0, 0, 255), 3, 8, 0);\t\t\t\timshow(&quot;input video&quot;, frame);\t\tchar c = waitKey(50);\t\tif(c == 27)&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t\tcapture.release();\twaitKey(0);\treturn 0;&#125;void processFrame(Mat &amp;mask, Rect &amp;rect)&#123; //查找轮廓 \tvector&lt;vector&lt;Point&gt; &gt; contours;\tvector&lt;Vec4i&gt; hireachy;\tfindContours(mask, contours, hireachy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, Point(0, 0));\tif(contours.size() &gt; 0)&#123;\t\tdouble maxArea = 0.0;\t\tfor(size_t t = 0; t &lt; contours.size(); ++t)&#123;\t\t\tdouble area = contourArea(contours[static_cast&lt;int&gt;(t)]);\t\t\tif(area &gt; maxArea)&#123;\t\t\t\tmaxArea = area;\t\t\t\trect = boundingRect(contours[static_cast&lt;int&gt;(t)]);\t\t\t&#125;\t\t&#125;\t&#125;else&#123;\t\trect.x = rect.y = rect.width = rect.height = 0;\t&#125;&#125;\n相关类和函数inRange()\n   OpenCV中的inRange()函数可实现二值化功能（这点类似threshold()函数），更关键的是可以同时针对多通道进行操作，使用起来非常方便！主要是将在两个阈值内的像素值设置为白色（255），而不在阈值区间内的像素值设置为黑色（0），该功能类似于之间所讲的双阈值化操作。\n  void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst);//src 输入要处理的图像，可以为单通道或多通道//lowerb 包含下边界的数组或标量//upperb 包含上边界数组或标量//dst 输出图像，与输入图像src 尺寸相同且为CV_8U 类型\nChecks if array elements lie between the elements of two other arrays.即检查数组元素是否在另外两个数组元素值之间。这里的数组通常也就是矩阵Mat或向量。\n\n该函数输出的dst是一幅二值化之后的图像。\n\nmorphologyEx\n形态学变化函数\n(4条消息) opencv 形态学变换 morphologyEx函数_keen_zuxwang的博客-CSDN博客\nfindContours\n检测物体轮廓\nfindContours(InputOutputArray image, OutputArrayOfArrays contours,  OutputArray hierarchy, int mode, int method, Point offset = Point());//image 单通道图像矩阵 灰度图or二值图像（Canny、拉普拉斯等边缘检测算子）//contours 向量vector&lt;vector&lt;Point&gt;&gt; contours//hierarchy 向量vector&lt;Vec4i&gt; hierarchy   vec4i:typedef Vec&lt;int, 4&gt; Vec4i; //mode 轮廓检索模式//method 定义轮廓的近似方法//Point偏移量 所有的轮廓信息相对于原始图像对应点的偏移量 相当于在每一个检测出的轮廓点上加上该偏移量 并且Point还可以是负值!\n轮廓检索模式\nCV_RETR_EXTERNAL //只检测最外围轮廓CV_RETR_LIST //检测所有的轮廓 轮廓不建立等级关系 即不存在父轮廓或内嵌轮廓CV_RETR_CCOMP //检测所有的轮廓 建立两个等级关系CV_RETR_TREE //检测所有轮廓 所有轮廓建立一个等级树结构\n定义轮廓的近似方法\nCV_CHAIN_APPROX_NONE //保存物体边界上所有连续的轮廓点到contours向量内CV_CHAIN_APPROX_SIMPLE //仅保存轮廓的拐点信息 把所有轮廓拐点处的点保存入contours  CV_CHAIN_APPROX_TC89_L1 //使用teh-Chinl chain 近似算法CV_CHAIN_APPROX_TC89_KCOS //使用teh-Chinl chain 近似算法\ncontourArea\n计算轮廓面积\ndouble contourArea(InputArray contour, bool oriented = false);//contour 输入的二维点集（轮廓顶点）可以是 vector 或 Mat 类型//riented，面向区域标识符 有默认值 false 若为 true 该函数返回一个带符号的面积值 正负取决于轮廓的方向（顺时针还是逆时针） 若为 false 表示以绝对值返回\narcLength\n计算封闭轮廓周长\ndouble arcLength(InputArray curve, bool closed);//contour 输入的二维点集（轮廓顶点）可以是 vector 或 Mat 类型//closed 用于指示曲线是否封闭\nboundingRect\n计算轮廓的垂直边界最小矩形，矩形是与图像上下边界平行的\nRect boundingRect(InputArray points);//points 输入的二维点集（轮廓顶点）可以是 vector 或 Mat 类型","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (计算立体图像的深度)","url":"/2021/08/04/OPENCV1-6/","content":"two camera\n\n要计算立体视觉系统的深度图，就必须计算每个像素的视差。\n\n得到水平极线用鲁棒匹配算法 (robustMatching) ，计算立体视觉系统的基础矩阵，得到水平极线。\nrobustMatcher.h\n#if !defined MATCHER#define MATCHER#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/features2d.hpp&gt;#include &lt;opencv2/calib3d.hpp&gt;#include &lt;opencv2/xfeatures2d.hpp&gt;#define NOCHECK      0#define CROSSCHECK   1#define RATIOCHECK   2#define BOTHCHECK    3class RobustMatcher &#123;  private:\t  // pointer to the feature point detector object\t  cv::Ptr&lt;cv::FeatureDetector&gt; detector;\t  // pointer to the feature descriptor extractor object\t  cv::Ptr&lt;cv::DescriptorExtractor&gt; descriptor;\t  int normType;\t  float ratio; // max ratio between 1st and 2nd NN\t  bool refineF; // if true will refine the F matrix\t  bool refineM; // if true will refine the matches (will refine F also)\t  double distance; // min distance to epipolar\t  double confidence; // confidence level (probability)  public:\t  RobustMatcher(const cv::Ptr&lt;cv::FeatureDetector&gt; &amp;detector, \t\t            const cv::Ptr&lt;cv::DescriptorExtractor&gt; &amp;descriptor= cv::Ptr&lt;cv::DescriptorExtractor&gt;())\t\t  : detector(detector), descriptor(descriptor),normType(cv::NORM_L2), \t\t    ratio(0.8f), refineF(true), refineM(true), confidence(0.98), distance(1.0) &#123;\t  \t\t// in this case use the associated descriptor\t\tif (!this-&gt;descriptor) &#123; \t\t\tthis-&gt;descriptor = this-&gt;detector;\t\t&#125; \t  &#125;\t  // Set the feature detector\t  void setFeatureDetector(const cv::Ptr&lt;cv::FeatureDetector&gt;&amp; detect) &#123;\t\t  this-&gt;detector= detect;\t  &#125;\t  // Set descriptor extractor\t  void setDescriptorExtractor(const cv::Ptr&lt;cv::DescriptorExtractor&gt;&amp; desc) &#123;\t\t  this-&gt;descriptor= desc;\t  &#125;\t  // Set the norm to be used for matching\t  void setNormType(int norm) &#123;\t\t  normType= norm;\t  &#125;\t  // Set the minimum distance to epipolar in RANSAC\t  void setMinDistanceToEpipolar(double d) &#123;\t\t  distance= d;\t  &#125;\t  // Set confidence level in RANSAC\t  void setConfidenceLevel(double c) &#123;\t\t  confidence= c;\t  &#125;\t  // Set the NN ratio\t  void setRatio(float r) &#123;\t\t  ratio= r;\t  &#125;\t  // if you want the F matrix to be recalculated\t  void refineFundamental(bool flag) &#123;\t\t  refineF= flag;\t  &#125;\t  // if you want the matches to be refined using F\t  void refineMatches(bool flag) &#123;\t\t  refineM= flag;\t  &#125;\t  // Clear matches for which NN ratio is &gt; than threshold\t  // return the number of removed points \t  // (corresponding entries being cleared, i.e. size will be 0)      int ratioTest(const std::vector&lt;std::vector&lt;cv::DMatch&gt; &gt;&amp; inputMatches,\t\t            std::vector&lt;cv::DMatch&gt;&amp; outputMatches) &#123;\t\tint removed=0;        // for all matches        for (std::vector&lt;std::vector&lt;cv::DMatch&gt; &gt;::const_iterator matchIterator= inputMatches.begin();\t\t\t matchIterator!= inputMatches.end(); ++matchIterator) &#123;\t\t\t\t \t\t\t\t //   first best match/second best match\t\t\t\t if ((matchIterator-&gt;size() &gt; 1) &amp;&amp; // if 2 NN has been identified \t\t\t\t\t (*matchIterator)[0].distance/(*matchIterator)[1].distance &lt; ratio) &#123;\t\t\t\t\t\t\t\t // it is an acceptable match\t\t\t\t\t outputMatches.push_back((*matchIterator)[0]);\t\t\t\t &#125; else &#123;\t\t\t\t\t removed++;\t\t\t\t &#125;\t\t&#125;\t\treturn removed;\t  &#125;\t  // Insert symmetrical matches in symMatches vector\t  void symmetryTest(const std::vector&lt;cv::DMatch&gt;&amp; matches1,\t\t                const std::vector&lt;cv::DMatch&gt;&amp; matches2,\t\t\t\t\t    std::vector&lt;cv::DMatch&gt;&amp; symMatches) &#123;\t\t\t\t\t// for all matches image 1 -&gt; image 2\t\tfor (std::vector&lt;cv::DMatch&gt;::const_iterator matchIterator1= matches1.begin();\t\t\t matchIterator1!= matches1.end(); ++matchIterator1) &#123;\t\t\t// for all matches image 2 -&gt; image 1\t\t\tfor (std::vector&lt;cv::DMatch&gt;::const_iterator matchIterator2= matches2.begin();\t\t\t\tmatchIterator2!= matches2.end(); ++matchIterator2) &#123;\t\t\t\t// Match symmetry test\t\t\t\tif (matchIterator1-&gt;queryIdx == matchIterator2-&gt;trainIdx  &amp;&amp; \t\t\t\t\tmatchIterator2-&gt;queryIdx == matchIterator1-&gt;trainIdx) &#123;\t\t\t\t\t\t// add symmetrical match\t\t\t\t\t\tsymMatches.push_back(*matchIterator1);\t\t\t\t\t\tbreak; // next match in image 1 -&gt; image 2\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t  &#125;\t  // Apply both ratio and symmetry test\t  // (often an over-kill)      void ratioAndSymmetryTest(const std::vector&lt;std::vector&lt;cv::DMatch&gt; &gt;&amp; matches1,                                const std::vector&lt;std::vector&lt;cv::DMatch&gt; &gt;&amp; matches2,\t\t\t\t\t            std::vector&lt;cv::DMatch&gt;&amp; outputMatches) &#123;\t\t// Remove matches for which NN ratio is &gt; than threshold\t\t// clean image 1 -&gt; image 2 matches\t\tstd::vector&lt;cv::DMatch&gt; ratioMatches1;\t\tint removed= ratioTest(matches1,ratioMatches1);\t\tstd::cout &lt;&lt; &quot;Number of matched points 1-&gt;2 (ratio test) : &quot; &lt;&lt; ratioMatches1.size() &lt;&lt; std::endl;\t\t// clean image 2 -&gt; image 1 matches\t\tstd::vector&lt;cv::DMatch&gt; ratioMatches2;\t\tremoved= ratioTest(matches2,ratioMatches2);\t\tstd::cout &lt;&lt; &quot;Number of matched points 1-&gt;2 (ratio test) : &quot; &lt;&lt; ratioMatches2.size() &lt;&lt; std::endl;\t\t// Remove non-symmetrical matches\t\tsymmetryTest(ratioMatches1,ratioMatches2,outputMatches);\t\tstd::cout &lt;&lt; &quot;Number of matched points (symmetry test): &quot; &lt;&lt; outputMatches.size() &lt;&lt; std::endl;\t  &#125;\t  // Identify good matches using RANSAC\t  // Return fundamental matrix and output matches\t  cv::Mat ransacTest(const std::vector&lt;cv::DMatch&gt;&amp; matches,\t\t                 std::vector&lt;cv::KeyPoint&gt;&amp; keypoints1, \t\t\t\t\t\t std::vector&lt;cv::KeyPoint&gt;&amp; keypoints2,\t\t\t\t\t     std::vector&lt;cv::DMatch&gt;&amp; outMatches) &#123;\t\t// Convert keypoints into Point2f\t\t\tstd::vector&lt;cv::Point2f&gt; points1, points2;\t\t\tfor (std::vector&lt;cv::DMatch&gt;::const_iterator it= matches.begin();\t\t\t it!= matches.end(); ++it) &#123;\t\t\t // Get the position of left keypoints\t\t\t points1.push_back(keypoints1[it-&gt;queryIdx].pt);\t\t\t // Get the position of right keypoints\t\t\t points2.push_back(keypoints2[it-&gt;trainIdx].pt);\t    &#125;\t\t// Compute F matrix using RANSAC\t\tstd::vector&lt;uchar&gt; inliers(points1.size(),0);\t\tcv::Mat fundamental= cv::findFundamentalMat(\t\t\tpoints1,points2, // matching points\t\t    inliers,         // match status (inlier or outlier)  \t\t    cv::FM_RANSAC,   // RANSAC method\t\t    distance,        // distance to epipolar line\t\t    confidence);     // confidence probability\t\t\t// extract the surviving (inliers) matches\t\tstd::vector&lt;uchar&gt;::const_iterator itIn= inliers.begin();\t\tstd::vector&lt;cv::DMatch&gt;::const_iterator itM= matches.begin();\t\t// for all matches\t\tfor ( ;itIn!= inliers.end(); ++itIn, ++itM) &#123;\t\t\tif (*itIn) &#123; // it is a valid match\t\t\t\toutMatches.push_back(*itM);\t\t\t&#125;\t\t&#125;\t\tif (refineF || refineM) &#123;\t\t// The F matrix will be recomputed with all accepted matches\t\t\t// Convert keypoints into Point2f for final F computation\t\t\t\tpoints1.clear();\t\t\tpoints2.clear();\t\t\t\tfor (std::vector&lt;cv::DMatch&gt;::const_iterator it= outMatches.begin();\t\t\t\t it!= outMatches.end(); ++it) &#123;\t\t\t\t // Get the position of left keypoints\t\t\t\t points1.push_back(keypoints1[it-&gt;queryIdx].pt);\t\t\t\t // Get the position of right keypoints\t\t\t\t points2.push_back(keypoints2[it-&gt;trainIdx].pt);\t\t\t&#125;\t\t\t// Compute 8-point F from all accepted matches\t\t\tfundamental= cv::findFundamentalMat(\t\t\t\tpoints1,points2, // matching points\t\t\t\tcv::FM_8POINT); // 8-point method\t\t\tif (refineM) &#123;\t\t\t\tstd::vector&lt;cv::Point2f&gt; newPoints1, newPoints2;\t\t\t\t\t// refine the matches\t\t\t\tcorrectMatches(fundamental,             // F matrix\t\t\t\t\t           points1, points2,        // original position\t\t\t\t\t\t\t   newPoints1, newPoints2); // new position\t\t\t\tfor (int i=0; i&lt; points1.size(); i++) &#123;\t\t\t\t\tstd::cout &lt;&lt; &quot;(&quot; &lt;&lt; keypoints1[outMatches[i].queryIdx].pt.x \t\t\t\t\t\t      &lt;&lt; &quot;,&quot; &lt;&lt; keypoints1[outMatches[i].queryIdx].pt.y \t\t\t\t\t\t\t  &lt;&lt; &quot;) -&gt; &quot;;\t\t\t\t\tstd::cout &lt;&lt; &quot;(&quot; &lt;&lt; newPoints1[i].x \t\t\t\t\t\t      &lt;&lt; &quot;,&quot; &lt;&lt; newPoints1[i].y &lt;&lt; std::endl;\t\t\t\t\tstd::cout &lt;&lt; &quot;(&quot; &lt;&lt; keypoints2[outMatches[i].trainIdx].pt.x \t\t\t\t\t\t      &lt;&lt; &quot;,&quot; &lt;&lt; keypoints2[outMatches[i].trainIdx].pt.y \t\t\t\t\t\t\t  &lt;&lt; &quot;) -&gt; &quot;;\t\t\t\t\tstd::cout &lt;&lt; &quot;(&quot; &lt;&lt; newPoints2[i].x \t\t\t\t\t\t      &lt;&lt; &quot;,&quot; &lt;&lt; newPoints2[i].y &lt;&lt; std::endl;\t\t\t\t\tkeypoints1[outMatches[i].queryIdx].pt.x= newPoints1[i].x;\t\t\t\t\tkeypoints1[outMatches[i].queryIdx].pt.y= newPoints1[i].y;\t\t\t\t\tkeypoints2[outMatches[i].trainIdx].pt.x= newPoints2[i].x;\t\t\t\t\tkeypoints2[outMatches[i].trainIdx].pt.y= newPoints2[i].y;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\treturn fundamental;\t  &#125;\t  // Match feature points using RANSAC\t  // returns fundamental matrix and output match set\t  cv::Mat match(cv::Mat&amp; image1, cv::Mat&amp; image2, // input images \t\t  std::vector&lt;cv::DMatch&gt;&amp; matches, // output matches and keypoints\t\t  std::vector&lt;cv::KeyPoint&gt;&amp; keypoints1, std::vector&lt;cv::KeyPoint&gt;&amp; keypoints2,\t\t  int check=CROSSCHECK) &#123;  // check type (symmetry or ratio or none or both)\t\t// 1. Detection of the feature points\t\tdetector-&gt;detect(image1,keypoints1);\t\tdetector-&gt;detect(image2,keypoints2);\t\tstd::cout &lt;&lt; &quot;Number of feature points (1): &quot; &lt;&lt; keypoints1.size() &lt;&lt; std::endl;\t\tstd::cout &lt;&lt; &quot;Number of feature points (2): &quot; &lt;&lt; keypoints2.size() &lt;&lt; std::endl;\t\t// 2. Extraction of the feature descriptors\t\tcv::Mat descriptors1, descriptors2;\t\tdescriptor-&gt;compute(image1,keypoints1,descriptors1);\t\tdescriptor-&gt;compute(image2,keypoints2,descriptors2);\t\tstd::cout &lt;&lt; &quot;descriptor matrix size: &quot; &lt;&lt; descriptors1.rows &lt;&lt; &quot; by &quot; &lt;&lt; descriptors1.cols &lt;&lt; std::endl;\t\t// 3. Match the two image descriptors\t\t//    (optionaly apply some checking method)   \t\t// Construction of the matcher with crosscheck \t\tcv::BFMatcher matcher(normType,            //distance measure\t                          check==CROSSCHECK);  // crosscheck flag                             \t\t// vectors of matches        std::vector&lt;std::vector&lt;cv::DMatch&gt; &gt; matches1;        std::vector&lt;std::vector&lt;cv::DMatch&gt; &gt; matches2;\t    std::vector&lt;cv::DMatch&gt; outputMatches;\t\t// call knnMatch if ratio check is required\t\tif (check==RATIOCHECK || check==BOTHCHECK) &#123;\t\t\t// from image 1 to image 2\t\t\t// based on k nearest neighbours (with k=2)\t\t\tmatcher.knnMatch(descriptors1,descriptors2, \t\t\t\tmatches1, // vector of matches (up to 2 per entry) \t\t\t\t2);\t\t  // return 2 nearest neighbours\t\t\tstd::cout &lt;&lt; &quot;Number of matched points 1-&gt;2: &quot; &lt;&lt; matches1.size() &lt;&lt; std::endl;\t\t\tif (check==BOTHCHECK) &#123;\t\t\t\t// from image 2 to image 1\t\t\t\t// based on k nearest neighbours (with k=2)\t\t\t\tmatcher.knnMatch(descriptors2,descriptors1, \t\t\t\t\tmatches2, // vector of matches (up to 2 per entry) \t\t\t\t\t2);\t\t  // return 2 nearest neighbours\t\t\t\tstd::cout &lt;&lt; &quot;Number of matched points 2-&gt;1: &quot; &lt;&lt; matches2.size() &lt;&lt; std::endl;\t\t\t&#125;\t\t&#125; \t\t\t\t// select check method\t\tswitch (check) &#123;\t\t\tcase CROSSCHECK:\t\t\t\tmatcher.match(descriptors1,descriptors2,outputMatches);\t\t\t\tstd::cout &lt;&lt; &quot;Number of matched points 1-&gt;2 (after cross-check): &quot; &lt;&lt; outputMatches.size() &lt;&lt; std::endl;\t\t\t\tbreak;\t\t\tcase RATIOCHECK:\t\t\t\tratioTest(matches1,outputMatches);\t\t\t\tstd::cout &lt;&lt; &quot;Number of matched points 1-&gt;2 (after ratio test): &quot; &lt;&lt; outputMatches.size() &lt;&lt; std::endl;\t\t\t\tbreak;\t\t\tcase BOTHCHECK:\t\t\t\tratioAndSymmetryTest(matches1,matches2,outputMatches);\t\t\t\tstd::cout &lt;&lt; &quot;Number of matched points 1-&gt;2 (after ratio and cross-check): &quot; &lt;&lt; outputMatches.size() &lt;&lt; std::endl;\t\t\t\tbreak;\t\t\tcase NOCHECK:\t\t\tdefault:\t\t\t\tmatcher.match(descriptors1,descriptors2,outputMatches);\t\t\t\tstd::cout &lt;&lt; &quot;Number of matched points 1-&gt;2: &quot; &lt;&lt; outputMatches.size() &lt;&lt; std::endl;\t\t\t\tbreak;\t\t&#125;\t\t// 4. Validate matches using RANSAC\t\tcv::Mat fundamental= ransacTest(outputMatches, keypoints1, keypoints2, matches);\t\tstd::cout &lt;&lt; &quot;Number of matched points (after RANSAC): &quot; &lt;&lt; matches.size() &lt;&lt; std::endl;\t\t// return the found fundamental matrix\t\treturn fundamental;\t&#125;\t  \t // Match feature points using RANSAC\t // returns fundamental matrix and output match set     // this is the simplified version presented in the book\t  cv::Mat matchBook(cv::Mat&amp; image1, cv::Mat&amp; image2, // input images \t\t  std::vector&lt;cv::DMatch&gt;&amp; matches, // output matches and keypoints\t\t  std::vector&lt;cv::KeyPoint&gt;&amp; keypoints1, std::vector&lt;cv::KeyPoint&gt;&amp; keypoints2) &#123; \t\t\t  \t\t// 1. Detection of the feature points\t\tdetector-&gt;detect(image1,keypoints1);\t\tdetector-&gt;detect(image2,keypoints2);\t\t// 2. Extraction of the feature descriptors\t\tcv::Mat descriptors1, descriptors2;\t\tdescriptor-&gt;compute(image1,keypoints1,descriptors1);\t\tdescriptor-&gt;compute(image2,keypoints2,descriptors2);\t\t// 3. Match the two image descriptors\t\t//    (optionnally apply some checking method)   \t\t// Construction of the matcher with crosscheck \t\tcv::BFMatcher matcher(normType,   //distance measure\t                          true);      // crosscheck flag                             \t\t// match descriptors\t    std::vector&lt;cv::DMatch&gt; outputMatches;\t\tmatcher.match(descriptors1,descriptors2,outputMatches);\t\t// 4. Validate matches using RANSAC\t\tcv::Mat fundamental= ransacTest(outputMatches, keypoints1, keypoints2, matches);\t\t// return the found fundemental matrix\t\treturn fundamental;\t&#125;&#125;;#endif\nrobustMatcher.cpp\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;numeric&gt;#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/features2d.hpp&gt;#include &lt;opencv2/calib3d.hpp&gt;#include &lt;opencv2/objdetect.hpp&gt;#include &lt;opencv2/xfeatures2d.hpp&gt;#include &lt;opencv2/viz.hpp&gt;#include &quot;robustMatcher.h&quot;int main()&#123;\t// Read input images\tcv::Mat image1= cv::imread(&quot;brebeuf1.jpg&quot;,0);\tcv::Mat image2= cv::imread(&quot;brebeuf2.jpg&quot;,0);\tif (!image1.data || !image2.data)\t\treturn 0; \t// Prepare the matcher (with default parameters)\t// here SIFT detector and descriptor\tRobustMatcher rmatcher(cv::xfeatures2d::SIFT::create(250));\t// Match the two images\tstd::vector&lt;cv::DMatch&gt; matches;\tstd::vector&lt;cv::KeyPoint&gt; keypoints1, keypoints2;\tcv::Mat fundamental = rmatcher.match(image1, image2, matches,\t\tkeypoints1, keypoints2);\t// draw the matches\tcv::Mat imageMatches;\tcv::drawMatches(image1, keypoints1,  // 1st image and its keypoints\t\timage2, keypoints2,  // 2nd image and its keypoints\t\tmatches,\t\t\t// the matches\t\timageMatches,\t\t// the image produced\t\tcv::Scalar(255, 255, 255),  // color of the lines\t\tcv::Scalar(255, 255, 255),  // color of the keypoints\t\tstd::vector&lt;char&gt;(),\t\t2);\tcv::namedWindow(&quot;Matches&quot;);\tcv::imshow(&quot;Matches&quot;, imageMatches);\t// Convert keypoints into Point2f\t\tstd::vector&lt;cv::Point2f&gt; points1, points2;\tfor (std::vector&lt;cv::DMatch&gt;::const_iterator it = matches.begin();\tit != matches.end(); ++it) &#123;\t\t// Get the position of left keypoints\t\tfloat x = keypoints1[it-&gt;queryIdx].pt.x;\t\tfloat y = keypoints1[it-&gt;queryIdx].pt.y;\t\tpoints1.push_back(keypoints1[it-&gt;queryIdx].pt);\t\t// Get the position of right keypoints\t\tx = keypoints2[it-&gt;trainIdx].pt.x;\t\ty = keypoints2[it-&gt;trainIdx].pt.y;\t\tpoints2.push_back(keypoints2[it-&gt;trainIdx].pt);\t&#125;\t// Compute homographic rectification\tcv::Mat h1, h2;\tcv::stereoRectifyUncalibrated(points1, points2, fundamental, image1.size(), h1, h2);\t// Rectify the images through warping\tcv::Mat rectified1;\tcv::warpPerspective(image1, rectified1, h1, image1.size());\tcv::Mat rectified2;\tcv::warpPerspective(image2, rectified2, h2, image1.size());\t// Display the images\tcv::namedWindow(&quot;Left Rectified Image&quot;);\tcv::imshow(&quot;Left Rectified Image&quot;, rectified1);\tcv::namedWindow(&quot;Right Rectified Image&quot;);\tcv::imshow(&quot;Right Rectified Image&quot;, rectified2);\tpoints1.clear();\tpoints2.clear();\tfor (int i = 20; i &lt; image1.rows - 20; i += 20) &#123;\t\tpoints1.push_back(cv::Point(image1.cols / 2, i));\t\tpoints2.push_back(cv::Point(image2.cols / 2, i));\t&#125;\t// Draw the epipolar lines\tstd::vector&lt;cv::Vec3f&gt; lines1;\tcv::computeCorrespondEpilines(points1, 1, fundamental, lines1);\tfor (std::vector&lt;cv::Vec3f&gt;::const_iterator it = lines1.begin();\tit != lines1.end(); ++it) &#123;\t\tcv::line(image2, cv::Point(0, -(*it)[2] / (*it)[1]),\t\t\tcv::Point(image2.cols, -((*it)[2] + (*it)[0] * image2.cols) / (*it)[1]),\t\t\tcv::Scalar(255, 255, 255));\t&#125;\tstd::vector&lt;cv::Vec3f&gt; lines2;\tcv::computeCorrespondEpilines(points2, 2, fundamental, lines2);\tfor (std::vector&lt;cv::Vec3f&gt;::const_iterator it = lines2.begin();\tit != lines2.end(); ++it) &#123;\t\tcv::line(image1, cv::Point(0, -(*it)[2] / (*it)[1]),\t\t\tcv::Point(image1.cols, -((*it)[2] + (*it)[0] * image1.cols) / (*it)[1]),\t\t\tcv::Scalar(255, 255, 255));\t&#125;\t// Display the images with epipolar lines\tcv::namedWindow(&quot;Left Epilines&quot;);\tcv::imshow(&quot;Left Epilines&quot;, image1);\tcv::namedWindow(&quot;Right Epilines&quot;);\tcv::imshow(&quot;Right Epilines&quot;, image2);\t// draw the pair\tcv::drawMatches(image1, keypoints1,  // 1st image \t\timage2, keypoints2,              // 2nd image \t\tstd::vector&lt;cv::DMatch&gt;(),\t\t\t\t\timageMatches,\t\t             // the image produced\t\tcv::Scalar(255, 255, 255),  \t\tcv::Scalar(255, 255, 255),  \t\tstd::vector&lt;char&gt;(),\t\t2);\tcv::namedWindow(&quot;A Stereo pair&quot;);\tcv::imshow(&quot;A Stereo pair&quot;, imageMatches);\t// Compute disparity\tcv::Mat disparity;\tcv::Ptr&lt;cv::StereoMatcher&gt; pStereo = cv::StereoSGBM::create(0,   // minimum disparity\t\t                                                        32,  // maximum disparity\t\t                                                        5);  // block size\tpStereo-&gt;compute(rectified1, rectified2, disparity);\t// draw the rectified pair\t/*\tcv::warpPerspective(image1, rectified1, h1, image1.size());\tcv::warpPerspective(image2, rectified2, h2, image1.size());\tcv::drawMatches(rectified1, keypoints1,  // 1st image \t\trectified2, keypoints2,              // 2nd image\t\tstd::vector&lt;cv::DMatch&gt;(),\t\t\t\timageMatches,\t\t                // the image produced\t\tcv::Scalar(255, 255, 255),  \t\tcv::Scalar(255, 255, 255),  \t\tstd::vector&lt;char&gt;(),\t\t2);\tcv::namedWindow(&quot;Rectified Stereo pair&quot;);\tcv::imshow(&quot;Rectified Stereo pair&quot;, imageMatches);\t*/\tdouble minv, maxv;\tdisparity = disparity * 64;\tcv::minMaxLoc(disparity, &amp;minv, &amp;maxv);\tstd::cout &lt;&lt; minv &lt;&lt; &quot;+&quot; &lt;&lt; maxv &lt;&lt; std::endl;\t// Display the disparity map\tcv::namedWindow(&quot;Disparity Map&quot;);\tcv::imshow(&quot;Disparity Map&quot;, disparity);\tcv::waitKey();\treturn 0;&#125;\n\n利用单应变换将每个相机的图像平面投影到完全对齐的虚拟平面上。\n// 计算单应变换矫正量Mat h1, h2;stereoRectifyUncalibrated(points1, points2, fundamental, image1.size(), h1, h2);// 用变换实现图像校正Mat rectified1;warpPerspective(image1, rectified1, h1, image1.size());Mat rectified2;warpPerspective(image2, rectified2, h2, image1.size()); // ??? image1 or image2// 计算视差Mat disparity;Ptr&lt;StereoMatcher&gt; pStereo = StereoSGBM::create(0, 32, 5); // 最小视差，最大视差，块的大小pStereo -&gt; compute(rectified1, rectified2, disparity);\n部分对极线\n\n经矫正的图像对\n\n视差图：亮的地方视差大，离物体近\n\n\n\n","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"OpenCV (操作像素)","url":"/2021/08/24/OPENCV2-4/","content":"越看不下去的部分，越要逼着自己跑代码。\n\n访问像素值Mat 类包含多种方法，可用来访问图像的各种属性：利用公共成员变量 cols 和 rows 可得到图像的列数和行数；利用 at(int y, int x) 方法可以访问元素，其中 y 是行号，x 是列号。使用 at 方法时，须指定图像元素的类型，例如 image.at&lt;uchar&gt;(j, i) = 255; 必须保证指定的类型与矩阵内的类型是一致的。\n彩色图像的每个像素对应三个部分：R,G,B ，因此包含彩色图像的 Mat 类会返回一个向量，向量中包含三个8位的数值。OpenCV 为这样的短向量定义了一种类型，即 cv::Vec3d 。这个向量包含三个无符号字符类型性的数据，访问像素用如下方式：image.at&lt;cv::Vec3b&gt;(j, i)[channel] = value;  channel 用来指明三个颜色通道中的一个。 OpenCV 存储通道的顺序是 B,G,R 也可以直接用短向量：image.at&lt;cv::Vec3b&gt;(j, i) = cv::Vec3b(255, 255, 255) \n我们随机选择一些像素，将其颜色置成白色。\n#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;random&gt;// Add salt noise to an imagevoid salt(cv::Mat image, int n) {\t// C++11 random number generator\tstd::default_random_engine generator;\tstd::uniform_int_distribution&lt;int&gt; randomRow(0, image.rows - 1);\tstd::uniform_int_distribution&lt;int&gt; randomCol(0, image.cols - 1);\tint i,j;\tfor (int k=0; k&lt;n; k++) {\t\t// random image coordinate\t\ti= randomCol(generator);\t\tj= randomRow(generator); \t\tif (image.type() == CV_8UC1) { // gray-level image\t\t\t// single-channel 8-bit image\t\t\timage.at&lt;uchar&gt;(j,i)= 255; \t\t} else if (image.type() == CV_8UC3) { // color image\t\t\t// 3-channel image\t\t\timage.at&lt;cv::Vec3b&gt;(j,i)[0]= 255; \t\t\timage.at&lt;cv::Vec3b&gt;(j,i)[1]= 255; \t\t\timage.at&lt;cv::Vec3b&gt;(j,i)[2]= 255; \t\t\t// or simply:\t\t\t// image.at&lt;cv::Vec3b&gt;(j, i) = cv::Vec3b(255, 255, 255);\t\t}\t}}// This is an extra version of the function// to illustrate the use of cv::Mat_// works only for a 1-channel imagevoid salt2(cv::Mat image, int n) {\t// must be a gray-level image\tCV_Assert(image.type() == CV_8UC1);\t// C++11 random number generator\tstd::default_random_engine generator;\tstd::uniform_int_distribution&lt;int&gt; randomRow(0, image.rows - 1);\tstd::uniform_int_distribution&lt;int&gt; randomCol(0, image.cols - 1);\t// use image with a Mat_ template\tcv::Mat_&lt;uchar&gt; img(image);\t    //  or with references:    //\tcv::Mat_&lt;uchar&gt;&amp; im2= reinterpret_cast&lt;cv::Mat_&lt;uchar&gt;&amp;&gt;(image);\tint i,j;\tfor (int k=0; k&lt;n; k++) {\t\t// random image coordinate\t\ti = randomCol(generator);\t\tj = randomRow(generator);\t\t// add salt\t\timg(j,i)= 255; \t}}int main(){\t// open the image\tcv::Mat image= cv::imread(\"D:/colleage learning/Freshman_Summer Holiday Practice/opencv learning/Resources/OpenCVBook/boldt.jpg\",1);\t// call function to add noise\tsalt(image,3000);\t// display result\tcv::namedWindow(\"Image\");\tcv::imshow(\"Image\",image);\t// write on disk\tcv::imwrite(\"salted.bmp\",image);\tcv::waitKey();\t// test second version\timage= cv::imread(\"D:/colleage learning/Freshman_Summer Holiday Practice/opencv learning/Resources/OpenCVBook/boldt.jpg\",0);\tsalt2(image, 500);\tcv::namedWindow(\"Image\");\tcv::imshow(\"Image\",image);\tcv::waitKey();\treturn 0;}\n\n扫描像素#include &lt;iostream&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;// 1st version// see recipe Scanning an image with pointersvoid colorReduce(cv::Mat image, int div = 64) {    int nl = image.rows; // number of lines    int nc = image.cols * image.channels(); // total number of elements per line    for (int j = 0; j &lt; nl; j++) {        // get the address of row j        uchar* data = image.ptr&lt;uchar&gt;(j);        for (int i = 0; i &lt; nc; i++) {            // process each pixel ---------------------            data[i] = data[i] / div * div + div / 2;            // end of pixel processing ----------------        } // end of line    }}// version with input/ouput images// see recipe Scanning an image with pointersvoid colorReduceIO(const cv::Mat&amp; image, // input image    cv::Mat&amp; result,      // output image    int div = 64) {    int nl = image.rows; // number of lines    int nc = image.cols; // number of columns    int nchannels = image.channels(); // number of channels    // allocate output image if necessary    result.create(image.rows, image.cols, image.type());    for (int j = 0; j &lt; nl; j++) {        // get the addresses of input and output row j        const uchar* data_in = image.ptr&lt;uchar&gt;(j);        uchar* data_out = result.ptr&lt;uchar&gt;(j);        for (int i = 0; i &lt; nc * nchannels; i++) {            // process each pixel ---------------------            data_out[i] = data_in[i] / div * div + div / 2;            // end of pixel processing ----------------        } // end of line    }}// Test 1// this version uses the dereference operator *void colorReduce1(cv::Mat image, int div = 64) {    int nl = image.rows; // number of lines    int nc = image.cols * image.channels(); // total number of elements per line    uchar div2 = div &gt;&gt; 1; // div2 = div/2    for (int j = 0; j &lt; nl; j++) {        uchar* data = image.ptr&lt;uchar&gt;(j);        for (int i = 0; i &lt; nc; i++) {            // process each pixel ---------------------            *data++ = *data / div * div + div2;            // end of pixel processing ----------------        } // end of line    }}// Test 2// this version uses the modulo operatorvoid colorReduce2(cv::Mat image, int div = 64) {    int nl = image.rows; // number of lines    int nc = image.cols * image.channels(); // total number of elements per line    uchar div2 = div &gt;&gt; 1; // div2 = div/2    for (int j = 0; j &lt; nl; j++) {        uchar* data = image.ptr&lt;uchar&gt;(j);        for (int i = 0; i &lt; nc; i++) {            // process each pixel ---------------------            int v = *data;            *data++ = v - v % div + div2;            // end of pixel processing ----------------        } // end of line    }}// Test 3// this version uses a binary maskvoid colorReduce3(cv::Mat image, int div = 64) {    int nl = image.rows; // number of lines    int nc = image.cols * image.channels(); // total number of elements per line    int n = static_cast&lt;int&gt;(log(static_cast&lt;double&gt;(div)) / log(2.0) + 0.5);    // mask used to round the pixel value    uchar mask = 0xFF &lt;&lt; n; // e.g. for div=16, mask= 0xF0    uchar div2 = 1 &lt;&lt; (n - 1); // div2 = div/2    for (int j = 0; j &lt; nl; j++) {        uchar* data = image.ptr&lt;uchar&gt;(j);        for (int i = 0; i &lt; nc; i++) {            // process each pixel ---------------------            *data &amp;= mask;     // masking            *data++ |= div2;   // add div/2          // end of pixel processing ----------------        } // end of line    }}// Test 4// this version uses direct pointer arithmetic with a binary maskvoid colorReduce4(cv::Mat image, int div = 64) {    int nl = image.rows; // number of lines    int nc = image.cols * image.channels(); // total number of elements per line    int n = static_cast&lt;int&gt;(log(static_cast&lt;double&gt;(div)) / log(2.0) + 0.5);    int step = image.step; // effective width    // mask used to round the pixel value    uchar mask = 0xFF &lt;&lt; n; // e.g. for div=16, mask= 0xF0    uchar div2 = div &gt;&gt; 1; // div2 = div/2    // get the pointer to the image buffer    uchar* data = image.data;    for (int j = 0; j &lt; nl; j++) {        for (int i = 0; i &lt; nc; i++) {            // process each pixel ---------------------            *(data + i) &amp;= mask;            *(data + i) += div2;            // end of pixel processing ----------------        } // end of line        data += step;  // next line    }}// Test 5// this version recomputes row size each timevoid colorReduce5(cv::Mat image, int div = 64) {    int nl = image.rows; // number of lines    int n = static_cast&lt;int&gt;(log(static_cast&lt;double&gt;(div)) / log(2.0) + 0.5);    // mask used to round the pixel value    uchar mask = 0xFF &lt;&lt; n; // e.g. for div=16, mask= 0xF0    for (int j = 0; j &lt; nl; j++) {        uchar* data = image.ptr&lt;uchar&gt;(j);        for (int i = 0; i &lt; image.cols * image.channels(); i++) {            // process each pixel ---------------------            *data &amp;= mask;            *data++ += div / 2;            // end of pixel processing ----------------        } // end of line    }}// Test 6// this version optimizes the case of continuous imagevoid colorReduce6(cv::Mat image, int div = 64) {    int nl = image.rows; // number of lines    int nc = image.cols * image.channels(); // total number of elements per line    if (image.isContinuous()) {        // then no padded pixels        nc = nc * nl;        nl = 1;  // it is now a 1D array    }    int n = static_cast&lt;int&gt;(log(static_cast&lt;double&gt;(div)) / log(2.0) + 0.5);    // mask used to round the pixel value    uchar mask = 0xFF &lt;&lt; n; // e.g. for div=16, mask= 0xF0    uchar div2 = div &gt;&gt; 1; // div2 = div/2   // this loop is executed only once   // in case of continuous images    for (int j = 0; j &lt; nl; j++) {        uchar* data = image.ptr&lt;uchar&gt;(j);        for (int i = 0; i &lt; nc; i++) {            // process each pixel ---------------------            *data &amp;= mask;            *data++ += div2;            // end of pixel processing ----------------        } // end of line    }}// Test 7// this versions applies reshape on continuous imagevoid colorReduce7(cv::Mat image, int div = 64) {    if (image.isContinuous()) {        // no padded pixels        image.reshape(1,   // new number of channels            1); // new number of rows    }    // number of columns set accordingly    int nl = image.rows; // number of lines    int nc = image.cols * image.channels(); // number of columns    int n = static_cast&lt;int&gt;(log(static_cast&lt;double&gt;(div)) / log(2.0) + 0.5);    // mask used to round the pixel value    uchar mask = 0xFF &lt;&lt; n; // e.g. for div=16, mask= 0xF0    uchar div2 = div &gt;&gt; 1; // div2 = div/2    for (int j = 0; j &lt; nl; j++) {        uchar* data = image.ptr&lt;uchar&gt;(j);        for (int i = 0; i &lt; nc; i++) {            // process each pixel ---------------------            *data &amp;= mask;            *data++ += div2;            // end of pixel processing ----------------        } // end of line    }}// Test 8// this version processes the 3 channels inside the loop with Mat_ iteratorsvoid colorReduce8(cv::Mat image, int div = 64) {    // get iterators    cv::Mat_&lt;cv::Vec3b&gt;::iterator it = image.begin&lt;cv::Vec3b&gt;();    cv::Mat_&lt;cv::Vec3b&gt;::iterator itend = image.end&lt;cv::Vec3b&gt;();    uchar div2 = div &gt;&gt; 1; // div2 = div/2    for (; it != itend; ++it) {        // process each pixel ---------------------        (*it)[0] = (*it)[0] / div * div + div2;        (*it)[1] = (*it)[1] / div * div + div2;        (*it)[2] = (*it)[2] / div * div + div2;        // end of pixel processing ----------------    }}// Test 9// this version uses iterators on Vec3bvoid colorReduce9(cv::Mat image, int div = 64) {    // get iterators    cv::MatIterator_&lt;cv::Vec3b&gt; it = image.begin&lt;cv::Vec3b&gt;();    cv::MatIterator_&lt;cv::Vec3b&gt; itend = image.end&lt;cv::Vec3b&gt;();    const cv::Vec3b offset(div / 2, div / 2, div / 2);    for (; it != itend; ++it) {        // process each pixel ---------------------        *it = *it / div * div + offset;        // end of pixel processing ----------------    }}// Test 10// this version uses iterators with a binary maskvoid colorReduce10(cv::Mat image, int div = 64) {    // div must be a power of 2    int n = static_cast&lt;int&gt;(log(static_cast&lt;double&gt;(div)) / log(2.0) + 0.5);    // mask used to round the pixel value    uchar mask = 0xFF &lt;&lt; n; // e.g. for div=16, mask= 0xF0    uchar div2 = div &gt;&gt; 1; // div2 = div/2    // get iterators    cv::Mat_&lt;cv::Vec3b&gt;::iterator it = image.begin&lt;cv::Vec3b&gt;();    cv::Mat_&lt;cv::Vec3b&gt;::iterator itend = image.end&lt;cv::Vec3b&gt;();    // scan all pixels    for (; it != itend; ++it) {        // process each pixel ---------------------        (*it)[0] &amp;= mask;        (*it)[0] += div2;        (*it)[1] &amp;= mask;        (*it)[1] += div2;        (*it)[2] &amp;= mask;        (*it)[2] += div2;        // end of pixel processing ----------------    }}// Test 11// this versions uses ierators from Mat_ void colorReduce11(cv::Mat image, int div = 64) {    // get iterators    cv::Mat_&lt;cv::Vec3b&gt; cimage = image;    cv::Mat_&lt;cv::Vec3b&gt;::iterator it = cimage.begin();    cv::Mat_&lt;cv::Vec3b&gt;::iterator itend = cimage.end();    uchar div2 = div &gt;&gt; 1; // div2 = div/2    for (; it != itend; it++) {        // process each pixel ---------------------        (*it)[0] = (*it)[0] / div * div + div2;        (*it)[1] = (*it)[1] / div * div + div2;        (*it)[2] = (*it)[2] / div * div + div2;        // end of pixel processing ----------------    }}// Test 12// this version uses the at methodvoid colorReduce12(cv::Mat image, int div = 64) {    int nl = image.rows; // number of lines    int nc = image.cols; // number of columns    uchar div2 = div &gt;&gt; 1; // div2 = div/2    for (int j = 0; j &lt; nl; j++) {        for (int i = 0; i &lt; nc; i++) {            // process each pixel ---------------------            image.at&lt;cv::Vec3b&gt;(j, i)[0] = image.at&lt;cv::Vec3b&gt;(j, i)[0] / div * div + div2;            image.at&lt;cv::Vec3b&gt;(j, i)[1] = image.at&lt;cv::Vec3b&gt;(j, i)[1] / div * div + div2;            image.at&lt;cv::Vec3b&gt;(j, i)[2] = image.at&lt;cv::Vec3b&gt;(j, i)[2] / div * div + div2;            // end of pixel processing ----------------        } // end of line    }}// Test 13// this version uses Mat overloaded operatorsvoid colorReduce13(cv::Mat image, int div = 64) {    int n = static_cast&lt;int&gt;(log(static_cast&lt;double&gt;(div)) / log(2.0) + 0.5);    // mask used to round the pixel value    uchar mask = 0xFF &lt;&lt; n; // e.g. for div=16, mask= 0xF0    // perform color reduction    image = (image &amp; cv::Scalar(mask, mask, mask)) + cv::Scalar(div / 2, div / 2, div / 2);}// Test 14// this version uses a look up tablevoid colorReduce14(cv::Mat image, int div = 64) {    cv::Mat lookup(1, 256, CV_8U);    for (int i = 0; i &lt; 256; i++) {        lookup.at&lt;uchar&gt;(i) = i / div * div + div / 2;    }    cv::LUT(image, lookup, image);}#define NTESTS 15#define NITERATIONS 10int main(){    // read the image    cv::Mat image = cv::imread(\"D:/colleage learning/Freshman_Summer Holiday Practice/opencv learning/Resources/OpenCVBook/boldt.jpg\");    // time and process the image    const int64 start = cv::getTickCount();    colorReduce(image, 64);    //Elapsed time in seconds    double duration = (cv::getTickCount() - start) / cv::getTickFrequency();    // display the image    std::cout &lt;&lt; \"Duration= \" &lt;&lt; duration &lt;&lt; \"secs\" &lt;&lt; std::endl;    cv::namedWindow(\"Image\");    cv::imshow(\"Image\", image);    cv::waitKey();    // test different versions of the function    int64 t[NTESTS], tinit;    // timer values set to 0    for (int i = 0; i &lt; NTESTS; i++)        t[i] = 0;    cv::Mat images[NTESTS];    cv::Mat result;    // the versions to be tested    typedef void(*FunctionPointer)(cv::Mat, int);    FunctionPointer functions[NTESTS] = { colorReduce, colorReduce1, colorReduce2, colorReduce3, colorReduce4,                                          colorReduce5, colorReduce6, colorReduce7, colorReduce8, colorReduce9,                                          colorReduce10, colorReduce11, colorReduce12, colorReduce13, colorReduce14 };    // repeat the tests several times    int n = NITERATIONS;    for (int k = 0; k &lt; n; k++) {        std::cout &lt;&lt; k &lt;&lt; \" of \" &lt;&lt; n &lt;&lt; std::endl;        // test each version        for (int c = 0; c &lt; NTESTS; c++) {            images[c] = cv::imread(\"boldt.jpg\");            // set timer and call function            tinit = cv::getTickCount();            functions[c](images[c], 64);            t[c] += cv::getTickCount() - tinit;            std::cout &lt;&lt; \".\";        }        std::cout &lt;&lt; std::endl;    }    // short description of each function    std::string descriptions[NTESTS] = {        \"original version:\",        \"with dereference operator:\",        \"using modulo operator:\",        \"using a binary mask:\",        \"direct ptr arithmetic:\",        \"row size recomputation:\",        \"continuous image:\",        \"reshape continuous image:\",        \"with iterators:\",        \"Vec3b iterators:\",        \"iterators and mask:\",        \"iterators from Mat_:\",        \"at method:\",        \"overloaded operators:\",        \"look-up table:\",    };    for (int i = 0; i &lt; NTESTS; i++) {        cv::namedWindow(descriptions[i]);        cv::imshow(descriptions[i], images[i]);    }    // print average execution time    std::cout &lt;&lt; std::endl &lt;&lt; \"-------------------------------------------\" &lt;&lt; std::endl &lt;&lt; std::endl;    for (int i = 0; i &lt; NTESTS; i++) {        std::cout &lt;&lt; i &lt;&lt; \". \" &lt;&lt; descriptions[i] &lt;&lt; 1000. * t[i] / cv::getTickFrequency() / n &lt;&lt; \"ms\" &lt;&lt; std::endl;    }    cv::waitKey();    return 0;}\n\n为了说明图像扫描的过程，我们通过减少图像中颜色的数量来体现。\n用指针扫描图像用迭代器扫描图像图像扫描循环扫描并访问相邻像素","categories":["HDU's Learning"],"tags":["OpenCV"]},{"title":"bitmask 状压DP","url":"/2022/06/29/bitmask/","content":"”我已经学会了如何活在当下。“\n”怎么做？“男孩问。\n”找一个安静的地方，闭上眼睛，然后呼吸。“\n”听起来真不错，然后呢？“\n”然后集中注意力。“\n“集中在什么上？”\n”蛋糕上。“ 鼹鼠回答。\n\n二进制运算技巧&amp; ：判断一个数字的二进制表示第  位是否为  if (n &amp; (1 &lt;&lt; k))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \n| ：将数  的第  位置一 n = n | (1 &lt;&lt; k)\n~ ：所有位都取反\n状压DPEva学的状压DP，就是用一个二进制数来表示一个集合。\n常见的状压DP分为两类，一种是有比较明显的结构的，如图、二维平面坐标等，另一种是较抽象的，比如物品等。\n通常来说在压缩状态的基础上，我们还需要一个额外的信息来帮助我们转移，它通常会是关于”最后“的一个信息。\n题目洛谷P1433\n题意：在二维平面上给  个点，初始坐标为原点，求遍历所有点的最小距离。\n思路：大概就是，比如我现在走到了一个点，我关心的是，有哪些点我还没走过，从当前点往后怎么走最短，我并不关心前面是怎么走的。\n设置状态 f[s][id] ，表示我走过了 s 里为  的对应的点，且最后一个点是 id 。我用当前这个状态取更新下一步，也就是说，假设与当前点 id 相连的点是 v ，那么f[s | (1 &lt;&lt; v)][v] = min(f[s | (1 &lt;&lt; v)][v], f[s][id] + w(id, v)) 。\nstruct point {    double x, y;    inline double sqr(const double &amp;x) {return x * x;}    inline double dis(const point &amp;obj) {return sqrt(sqr(x - obj.x) + sqr(y - obj.y));}}c[15];double f[(1 &lt;&lt; 15)][15];int main() {    int n; cin &gt;&gt; n;    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; c[i].x &gt;&gt; c[i].y;    int S = (1 &lt;&lt; n) - 1;    for (int i = 0; i &lt;= S; ++i)        for (int u = 0; u &lt; n; ++u) f[i][u] = 1e18;    point o{0, 0};    for (int u = 0; u &lt; n; ++u) f[(1 &lt;&lt; u)][u] = c[u].dis(o); // 枚举第一个点是谁    for (int s = 0; s &lt;= S; ++s) // 枚举状态        for (int u = 0; u &lt; n; ++u) // 枚举最后一个点是谁            if (s &amp; (1 &lt;&lt; u)) { // 判断当前枚举是否合法                for (int v = 0; v &lt; n; ++v) // 枚举要更新的点                    if (!(s &amp; (1 &lt;&lt; v))) f[s | (1 &lt;&lt; v)][v] = min(f[s | (1 &lt;&lt; v)][v], f[s][u] + c[u].dis(c[v]));            }    double ans = 1e18;    for (int i = 0; i &lt; n; ++i) ans = min(ans, f[S][i]);    printf(\"%.2lf\\n\", ans);    return 0;}\n洛谷P1879\n给一个二维的矩阵，矩阵里为  的位置不能放东西， 的位置才可以放东西，但放的东西不能相邻（上下左右都不能挨着），问方案数。\n思路：压缩行或者列，这里选取压缩行。如果我从上到下一行行考虑，我在考虑第  行的时候，我只关心  行是怎么放的，而不关心再往上的行是怎么放的。对于不能相邻放  这个条件，行内判断挨着可以用 s &amp; (s &gt;&gt; 1) 若结果  则有挨着的位置。考虑相邻的两行，只需要判断 s &amp; s_ ，如果结果  ，则有上下挨着的位置。在转移的过程中，需要枚举当前行的状态和下一行的状态，而每一行的状态是  （），所以如果要枚举两行的状态，其运算量大概在  ，显然，这不行。但我们可以注意到，首先如果一行的状态本身就不合法，那我们就不用再考虑它和别的行拼在一起的情况，并且在  个状态中，一大部分都是非法的，就是有相邻的  ，故为了简化后面的枚举状态，我们预处理出来对于一行来说，哪些状态是合法的，后面枚举的时候，就不用枚举那么多了。\n状态设置：f[i][s]，表示当前在处理的是第  行，改行的状态为 s 。\n#define mod 100000000int f[13][1 &lt;&lt; 12];vector&lt;int&gt; v; // 存行内可行的状态int main() {    int m = rd(), n = rd();    int S = (1 &lt;&lt; n) - 1;    for (int s = 0; s &lt;= S; ++s)        if (!(s &amp; (s &gt;&gt; 1))) v.push_back(s);    f[0][0] = 1;    for (int i = 1; i &lt;= m; ++i) {        int sta = 0;        for (int j = 1; j &lt;= n; ++j) sta = (sta &lt;&lt; 1) | rd(); // 读入该行的合法要求        for (auto s : v)            if ((s &amp; sta) == s) // s 是 sta 的子集                for (auto s_ : v) { // 枚举上一行的状态                    if (!(s_ &amp; s)) f[i][s] = (f[i][s] + f[i - 1][s_]) % mod;                }    }    int ans = 0;    for (auto s : v) ans = (ans + f[m][s]) % mod; // 对所有情况的方案数求和    printf(\"%d\\n\", ans);    return 0;}\n又写了一版用当前行更新下一行的。\n#define mod 100000000int f[13][1 &lt;&lt; 12];vector&lt;int&gt; v;int main() {    int m = rd(), n = rd();    int S = (1 &lt;&lt; n) - 1;    for (int s = 0; s &lt;= S; ++s)        if (!(s &amp; (s &gt;&gt; 1))) v.push_back(s);    f[0][0] = 1;    for (int i = 0; i &lt; m; ++i) {        int sta = 0; //下一行的sta        for (int j = 1; j &lt;= n; ++j) sta = (sta &lt;&lt; 1) | rd();        for (auto s : v) //current line            for (auto s_ : v) { //next line                if (!(s_ &amp; s) &amp;&amp; (sta &amp; s_) == s_) f[i + 1][s_] = (f[i + 1][s_] + f[i][s]) % mod;            }    }    int ans = 0;    for (auto s : v) ans = (ans + f[m][s]) % mod;    printf(\"%d\\n\", ans);    return 0;}\n洛谷P3052\n给  个物品和他们各自的体积，限制每组最多放  体积的物品，问最少要分几组。\n思路：枚举箱子编号，和哪些物品已经放过了，f[s][i] 表示已经放进箱子的物品的集合是 s ，最后一个箱子为  ，如果这个箱子还放得下，我就放这个箱子，放不下了我就放下一个箱子里。\nint f[1 &lt;&lt; 18][18], w[18];int main() {    int n = rd(), W = rd();    for (int i = 0; i &lt; n; ++i) w[i] = rd();    for (int i = 0; i &lt; (1 &lt;&lt; n); ++i)        for (int j = 0; j &lt; n; ++j) f[i][j] = 1e9;    f[0][0] = 0;    int S = (1 &lt;&lt; n) - 1;    for (int s = 0; s &lt;= S; ++s) //当前哪些物品已经放进去了        for (int k = 0; k &lt; n; ++k) { //箱子编号            if (f[s][k] == 1e9) continue;            for (int v = 0; v &lt; n; ++v) { //现在要放的物品                if (!((1 &lt;&lt; v) &amp; s)) {                    if (f[s][k] + w[v] &lt;= W) f[s | (1 &lt;&lt; v)][k] = min(f[s | (1 &lt;&lt; v)][k], f[s][k] + w[v]);                    else f[s | (1 &lt;&lt; v)][k + 1] = min(f[s | (1 &lt;&lt; v)][k + 1], w[v]);                }            }        }    int ans = 1e9;    for (int k = 0; k &lt; n; ++k) {        if (f[S][k] != 1e9) ans = min(ans, k + 1);    }    printf(\"%d\\n\", ans);    return 0;}\n洛谷P4802\n有  个点 （）， 条边，在满足不重复访问点的前提下，求以  号点为起点， 号点为终点的最长路径长度。\n思路：枚举已访问过的点集，和最后一个访问的点，来更新与该最后一个点相连的点，最终目标就是最后一个点是  。因为起点为  ，所以初态为 f[1][0] = 0; 别的都是负无穷。\nint f[1 &lt;&lt; 18][18];vector&lt;pair&lt;int, int&gt; &gt; V[18];int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= m; ++i) {        int u = rd(), v = rd(), w = rd();        V[u].push_back(make_pair(v, w));    }    int S = (1 &lt;&lt; n) - 1;    for (int i = 0; i &lt;= S; ++i)        for (int j = 0; j &lt; n; ++j) f[i][j] = -1e9;    f[1][0] = 0;    for (int s = 0; s &lt;= S; ++s)        for (int u = 0; u &lt; n; ++u) {            if (s &amp; (1 &lt;&lt; u))                for (auto node : V[u]) {                    int v = node.first, w = node.second;                    if (!(s &amp; (1 &lt;&lt; v))) f[s | (1 &lt;&lt; v)][v] = max(f[s | (1 &lt;&lt; v)][v], f[s][u] + w);                }        }    int ans = 0;    for (int s = 0; s &lt;= S; ++s)        if (s &amp; (1 &lt;&lt; (n - 1))) ans = max(ans, f[s][n - 1]);    printf(\"%d\\n\", ans);    return 0;}\n洛谷P3092\n有  个物品， 个硬币，要求顺序购买  个物品，每个物品有自己的价格，硬币不找零，问买完所有的物品后，剩下的钱最多是多少，如果无法购买，输出  。\n思路：首先  的范围很大，上界是  ， 的范围比较小，只有  。枚举硬币使用情况的集合，枚举新加进来的硬币是哪个，DP数组记录的就是能买到第几个物品。需要注意的是，因为每一次我们都需要知道在每种情况下，最多能买到第几个物品，如果一个个枚举的话，总体复杂度就是  ，这大概是 ，必然 T。所以在计算最多能买到第几个物品的时候，需要套一个二分。还有就是，因为我们总是关心一个区间里物品的价格和，所以采用前缀和来优化这一子问题。\n#define K 16#define N 100007int w[K], sum[N], f[1 &lt;&lt; K];inline int find(int L, int R, int limit) { // 找到最多能买到第几个物品    limit += sum[L - 1]; // sum[R] - sum[L - 1] &lt;= limit 但因为L和R下面会变，但实际上这个式子里的L不应该变，所以在一开始就加到limit里    while (L &lt; R) {        int mid = ((L + R + 1) &gt;&gt; 1);        if (sum[mid] &lt;= limit) L = mid;        else R = mid - 1;    }    return L;}inline int solve(int s, int k) { // 计算剩下硬币的价值    int ans = 0;    for (int i = 0; i &lt; k; ++i)        if (!(s &amp; (1 &lt;&lt; i))) ans += w[i];    return ans;}int main() {    int k = rd(), n = rd();    for (int i = 0; i &lt; k; ++i) w[i] = rd();    sum[1] = rd();    for (int i = 2; i &lt;= n; ++i) sum[i] = sum[i - 1] + rd();    int S = (1 &lt;&lt; k) - 1;    for (int s = 0; s &lt;= S; ++s) // 已经用了的硬币集合        for (int k_ = 0; k_ &lt; k; ++k_) { // 打算新加入的硬币是哪个            if (!((1 &lt;&lt; k_) &amp; s)) {                f[s | (1 &lt;&lt; k_)] = max(f[s | (1 &lt;&lt; k_)], find(f[s] + 1, n, w[k_]));            }        }    int ans = -1;    for (int s = 0; s &lt;= S; ++s)        if (f[s] == n) ans = max(ans, solve(s, k));    printf(\"%d\\n\", ans);    return 0;}\n总结状压DP是一个优化爆搜的方式，爆搜我们有好多好多状态，状压DP可以把状态压到一起，然后一起转移，这就起到了优化的效果。\n可以观察到的是，用状压解决的问题，被压的状态因为是指数级别的，所以不会很大，一般只有十几。\n继续做题洛谷P2704\n给一网格图，网格图上有些位置可以放士兵，有些不可以，一个士兵的攻击范围是上下左右各两格，要求摆放士兵的时候不能在别人的攻击范围里，问最多能放多少个士兵。\n思路：采取前面做题的思路，把一行的状态压起来，行内冲突提前预处理。不一样的是，这次不仅需要知道上一行的状态，需要知道上上行的状态，才能决定当前行能怎么放，所以定义状态为 f[i][s1][s2] 表示，当前处理到了第  行，第  行的状态时  ，再上一行的状态时  ，这样子我们就能DP啦！需要注意的是，在更新答案的时候，如果我们在循环里去数这一行和上一行比，增加了多少  的位置会 T， 所以在预处理的时候就把每个合法的状态里士兵的个数记下来。还有就是，这个DP数组，如果按之前的想法开需要  ，开不下了捏，所以我们需要对合法的 s 进行重编号，那要开多大呢？就是提前打个表数一下。还有这个判断一行的状态是否合法的时候，可以稍微优化一下。\n打表如下：\ninline bool valid (int x) {    if (x &amp; (x &gt;&gt; 1)) return 0;    if (x &amp; (x &gt;&gt; 2)) return 0;    return 1;}int main() { \tint cnt = 0;    int S = (1 &lt;&lt; 10) - 1;    for (int s = 0; s &lt;= S; ++s)        if (valid(s)) cnt++;\tprintf(\"%d\\n\", cnt);}\n打表结果是60。\n#define N 107vector&lt;int&gt; V;int mp[N], f[N][67][67], c[67];inline bool valid (int x) {    if (x &amp; (x &gt;&gt; 1)) return 0;    if (x &amp; (x &gt;&gt; 2)) return 0;    return 1;}inline int count (int s) {    int cnt = 0;    while (s) {        if (s &amp; 1) cnt++;        s &gt;&gt;= 1;    }    return cnt;}int main() {    int n = rd(), m = rd();    for (int i = 1; i &lt;= n; ++i)        for (int j = 0; j &lt; m; ++j) {            char c = getchar();            for (; c != 'H' &amp;&amp; c != 'P'; c = getchar()) ;            mp[i] = ((mp[i] &lt;&lt; 1) | (c == 'P'));        }    int S = (1 &lt;&lt; m) - 1;    for (int s = 0; s &lt;= S; ++s)        if (valid(s)) {            V.push_back(s);            c[V.size() - 1] = count(s);        }    int tot = V.size();    for (int i = 1; i &lt;= n; ++i) // 枚举行数        for (int i1 = 0; i1 &lt; tot; ++i1) { // 枚举当前行的状态            int s1 = V[i1];            if ((s1 &amp; mp[i]) != s1) continue;            for (int i2 = 0; i2 &lt; tot; ++i2) { // 枚举上一行的状态                int s2 = V[i2];                if (i &gt; 1 &amp;&amp; (s2 &amp; mp[i - 1]) != s2) continue;                if ((s1 &amp; s2)) continue;                for (int i3 = 0; i3 &lt; tot; ++i3) { // 枚举上上行的状态                    int s3 = V[i3];                    if (i &gt; 2 &amp;&amp; (s3 &amp; mp[i - 2]) != s3) continue;                    if ((s1 &amp; s3) &gt; 0 || (s2 &amp; s3) &gt; 0) continue;                    f[i][i1][i2] = max(f[i][i1][i2], f[i - 1][i2][i3] + c[i1]);                }            }        }    int ans = 0;    for (int i1 = 0; i1 &lt; tot; ++i1)        for (int i2 = 0; i2 &lt; tot; ++i2)            ans = max(ans, f[n][i1][i2]);    printf(\"%d\\n\", ans);    return 0;}\n 2021女生赛C连锁超市\n有  个景点，每个景点隶属于一个公司，一个公司有一个红包金额，走到一个景点就可以领取该公司的红包，但一个公司的红包只能领一次。景点之间通过缆车连接，且只会网海拔高的地方走。\n思路：看到这个数据范围，感觉压谁都不对……首先，我们来判断我们需要哪些条件来进行转移，首先我要知道哪些公司的红包我已经领过了，其次我还得知道，我现在在哪个景点，这将决定我接下来能往哪里走。知道自己需要什么以后，其实还是挺清晰的，刚开始我还在想要把景点压一起，但确实，其实我并不关心我走过哪些点，因为我只会沿着这个缆车往上走，我肯定不会经过重复的点。所以我们要压的是公司，问题是公司的数量跟景点的数量是一样的……呜呜呜，这我咋压。理性分析以后，我们可以发现，其实我们并不关心所有的公司，如果一个公司只有一个景点，那我想也不用想，走到就拿，不需要关心之前有没有走到过，因为必不可能，这样子想想，最差情况下，被压的公司数，就是点数的一半，啊！我能压了！对于初态，因为强制从  号点开始，分两种情况讨论：1.该点的公司只有一个景点 2.该点的公司不只有一个景点，就这样，初态也解决啦！\nint f[1 &lt;&lt; 18][36], cnt[36], c[36], w[36], ans[36], id[36];bool vis[36];vector&lt;int&gt; V[36]; int main() {    int n = rd(), m = rd();    for (int i = 0; i &lt; n; ++i) ++cnt[c[i] = rd() - 1];    for (int i = 0; i &lt; n; ++i) w[i] = rd();    for (int i = 0; i &lt; m; ++i) {        int u = rd(), v = rd();        V[u - 1].push_back(v - 1);    }    int n_ = 0;    for (int i = 0; i &lt; n; ++i)        if (!vis[c[i]] &amp;&amp; cnt[c[i]] &gt; 1) {            id[c[i]] = n_++;            vis[c[i]] = 1;        }    if (vis[c[0]]) f[1 &lt;&lt; id[c[0]]][0] = w[c[0]];    else f[0][0] = w[c[0]];    int S = (1 &lt;&lt; n_) - 1;    for (int s = 0; s &lt;= S; ++s)        for (int u = 0; u &lt; n; ++u) {            ans[u] = max(ans[u], f[s][u]);            for (auto v : V[u]) {                if (cnt[c[v]] &gt; 1 &amp;&amp; !(s &amp; (1 &lt;&lt; id[c[v]]))) f[s | (1 &lt;&lt; id[c[v]])][v] = max(f[s | (1 &lt;&lt; id[c[v]])][v], f[s][u] + w[c[v]]);                else if (cnt[c[v]] == 1) f[s][v] = max(f[s][v], f[s][u] + w[c[v]]);                else f[s][v] = max(f[s][v], f[s][u]);            }        }    for (int i = 0; i &lt; n; ++i) printf(\"%d\\n\", ans[i]);    return 0;}\narc058E\n问一个长度为  的数字序列，数字的范围是 0~10 。有多少种满足：有一段区间，把它拆成三段后，三段的区间和从前往后依次为  。答案对  取模。\n思路：这题看起来跟状压也没啥关系……被Co老师喂了奇妙做法。其实这个问题可以转换成，问一个序列里，是否存在一个位置，满足以它结尾的后缀和里，包含  。所以我们就记状态集为从 0 ~ x + y + z 是否在以  为结尾的后缀和里。（呜呜，中文好难，不知道自己在写啥……）。如果一个位置满足了这个条件，那它后面的数字就可以随便放了，也就是  ，其中 len 表示，后面的长度，所以我们需要预处理出来 10 的各个幂次。写到这里，再来明确一下状态，状态 f[i][s] 表示，当前处理到序列中第  个数，且以该数结尾的后缀和中出现了的在 0 ~ x + y + z 的数字的集合为 s 。目标状态是啥呢？就是包含 z, y + z, x + y + z  即代码里的 tar 。下一个头疼的就是，长度 +1 的时候，我的集合 s 要怎么变，首先之前所有的后缀和都要加上这个新加的数，并且新增了一个后缀和就是这个新加的数，需要注意的是，可能会有状态溢出 x + y + z ，一旦溢出了，我们在枚举状态的时候就枚举不到了，所以需要和全局最大的 S 与一下。\n#define mod 1000000007#define ll long long int f[47][1 &lt;&lt; 18], pw10[47]; int main() {    int n = rd(), x = rd(), y = rd(), z = rd();    ll ans = 0;    pw10[0] = 1;    for (int i = 1; i &lt;= n; ++i) pw10[i] = 1ll * pw10[i - 1] * 10 % mod;    int S = (1 &lt;&lt; (x + y + z + 1)) - 1;    int tar = (1 &lt;&lt; (x + y + z)) | (1 &lt;&lt; (y + z)) | (1 &lt;&lt; z);    f[0][0] = 1;    for (int i = 0; i &lt;= n; ++i)        for (int s = 0; s &lt;= S; ++s) {            if ((s &amp; tar) == tar) ans = (ans + 1ll * f[i][s] * pw10[n - i]) % mod;            else {                for (int j = 1; j &lt;= 10; ++j) {                    int s_ = (((s &lt;&lt; j) | (1 &lt;&lt; j)) &amp; S);                    f[i + 1][s_] = (f[i + 1][s_] + f[i][s]) % mod;                }            }        }    printf(\"%lld\\n\", ans);    return 0;}\n","categories":["HDU's Learning"],"tags":["Algorithm"]}]